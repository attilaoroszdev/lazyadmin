#!/bin/bash
#
# Copyright (C) 2017  Attila Orosz
#
# This file is part of Lazy Admin
#
# Lazy Admin is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Lazy Admin.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact: attila.orosz@mail.com



#This file fontains the functions providing basic functionality of the menu system
#Cusom "user functions" will be stored in ./n-functions


if [[ -f $menufile ]]; then
    echo "Setting menus..."
else
	clear
	echo
    echo "Looked for menus in:"
    echo $menufile
    echo
	echo "Error: Cannot find menuentries file in default location. Exiting..."
    echo
    exit 65
fi

#This function will read the menu entries from the menu entries file as set in defaults
function read_menu_items {



if [[ "$submenu" = "true" ]]; then

	OLDIFS="$IFS"
	IFS=$'\n'
	menuentry=( `cat $menufile | sed -n '/'_submenu$1$2'/{:a;n;/'_endsubmenu$1$2'/q;p;ba}'` )
	menuheight=$submenuheight
	IFS="$OLDIFS"
	menulength=${#menuentry[@]}

else
	OLDIFS="$IFS"
	IFS=$'\n'
	menuentry=( `cat $menufile | sed -n '/'_menu$tabpos'/{:a;n;/'_endmenu$tabpos'/q;p;ba}'` )
	menuheight=$normalmenuheight+1
	IFS="$OLDIFS"
	menulength=${#menuentry[@]}

fi



}

function set_flags_submenu_items {
	#Parse the argument list into the array, starting form the 3rd argument
	arrayoffset=2
	arraycounter=1


	for i in "$@"; do

		if [[ $arraycounter -gt $arrayoffset ]] && [[ $arraycounter -le 11 ]]; then

			let currentflagitem=$arraycounter-2
			menuentry[currentflagitem-1]="$currentflagitem - Set flag $i"

		fi
		((arraycounter++))

	done

	#Check if entries have already been written, by checking last element
	lastentry=${menuentry[${#menuentry[@]}-1]}
	if [[ "$lastentry" != "x - Delete set flags" ]]; then
		menuentry+=("m - Manually enter flags ")
		menuentry+=("c - Commit with flags")
		menuentry+=("x - Delete set flags")
	fi

	menulength=${#menuentry[@]}

}

function write_flags_descriptor {
	cursorpos=$(( $headerheight+$menuheight+$descriptorheight ))
	tput cup $cursorpos $menuwidth
	echo -e "\033[1K"
	tput cup $cursorpos 2

	case ${menuentry[$menupos]} in

	"m - Manually enter flags ")
	echo "Manually enter flags for the command specified"
	;;
	"c - Commit with flags")
	echo "Finished entering flags, proceed with command"
	;;
	"x - Delete set flags")
	echo "Clear list of set flags to start over again"
	;;
	*)
	echo "Set the specified flag"
	;;
	esac
	}



# read descriptor lines for menu items
function read_descriptor {

	if [[ "$submenu" = "true" ]]; then

	OLDIFS="$IFS"
	IFS=$'\n'
	if [[ "$activepanel" = "right" ]]; then
		menudescentry=( `cat $menufile | sed -n '/'_subrightpaneldesc'/{:a;n;/'_endsubrightpaneldesc'/q;p;ba}'` )
	else
		menudescentry=( `cat $menufile | sed -n '/'_descsubmenu$1$2'/{:a;n;/'_enddescsubmenu$1$2'/q;p;ba}'` )
	fi
	IFS="$OLDIFS"

	else

	OLDIFS="$IFS"
	IFS=$'\n'
	if [[ "$activepanel" = "right" ]]; then
		menudescentry=( `cat $menufile | sed -n '/'_rightpaneldesc'/{:a;n;/'_endrightpaneldesc'/q;p;ba}'` )
	else
		menudescentry=( `cat $menufile | sed -n '/'_descmenu$tabpos'/{:a;n;/'_enddescmenu$tabpos'/q;p;ba}'` )
	fi
	IFS="$OLDIFS"

	fi
}


# Load the items shown in the tab
function read_tab_items {
OLDIFS="$IFS"
IFS=$'\n'

if $altmenu; then
	tabentry=( `cat $menufile | sed -n '/'_submenutab$tabpos$menupos'/{:a;n;/'_endsubmenutab$tabpos$menupos'/q;p;ba}'` )
else
	tabentry=( `cat $menufile | sed -n '/'_menutab'/{:a;n;/'_endmenutab'/q;p;ba}'` )
fi

IFS="$OLDIFS"

tablength=$(( ${#tabentry[@]} -1 ))
}

function read_rightpanel_items {
	OLDIFS="$IFS"
	IFS=$'\n'
	if [[ "$submenu" = "true" ]]; then
		rightpanelentry=( `cat $menufile | sed -n '/'_subrightpanel'/{:a;n;/'_endsubrightpanel'/q;p;ba}'` )
	else
		rightpanelentry=( `cat $menufile | sed -n '/'_rightpanel'/{:a;n;/'_endrightpanel'/q;p;ba}'` )
	fi
	IFS="$OLDIFS"

	rightpanellength=${#rightpanelentry[@]}
}


function read_help_rightpanel_items {
	OLDIFS="$IFS"
	IFS=$'\n'
	
	rightpanelentry=( `cat $menufile | sed -n '/'_helprightpanel'/{:a;n;/'_endhelprightpanel'/q;p;ba}'` )
	
	IFS="$OLDIFS"

	rightpanellength=${#rightpanelentry[@]}
}



#Display the menu tabs
function write_tab_items {

    # Mpodify top line first, draw connectors
    
    if [[ $displaylineconnectors == "true" ]]; then
    
        horizontalconnectorposition=0
        
        tput cup $(( headerheight - 2 )) $horizontalconnectorposition
        
	    for (( n=0; n < $tablength; n++ ))
	    do
		    if [[ n -eq $tabpos ]]; then
		
		        horizontalconnectorposition=$(( $horizontalconnectorposition + ${#tabentry[$tabpos]} + 3 ))
		
		
		        tput cup $(( headerheight - 2 )) $horizontalconnectorposition
		
		    echo -n "┯"

			

		    else
		        
		        horizontalconnectorposition=$(( $horizontalconnectorposition + ${#tabentry[n]} + 3 ))

		        tput cup $(( headerheight - 2 )) $horizontalconnectorposition
		
		    echo -n "┯"


		    fi
	    done
    
    fi
    
    # Then write out the tab items, with separators

	tput cup $(( headerheight - 1 )) 1
	for (( n=0; n <= $tablength; n++ ))
	do
		if [[ n -eq $tabpos ]]; then

			echo -n -e "\e[00;30;47m ${tabentry[$tabpos]} \e[00m"
			
			# Do not write separator after last item
			if [[ n -lt $tablength ]]; then
			
			    echo -n "│"
			
			fi

		else

			echo -n " ${tabentry[n]} "
			
			# Do not write separator after last item
			if [[ n -lt $tablength ]]; then
			
			    echo -n "│"
			
			fi
			
			

		fi
	done
	

    if [[ $displaylineconnectors == "true" ]]; then

        # Then draw connectors ont he bottom line
	    horizontalconnectorposition=0
        
        tput cup $(( headerheight )) $horizontalconnectorposition
        
	    for (( n=0; n < $tablength; n++ ))
	    do
		    if [[ n -eq $tabpos ]]; then
		
		        horizontalconnectorposition=$(( $horizontalconnectorposition + ${#tabentry[$tabpos]} + 3 ))
		
		
		        tput cup $(( headerheight )) $horizontalconnectorposition
		
		    echo -n "┷"

			

		    else
		        
		        horizontalconnectorposition=$(( $horizontalconnectorposition + ${#tabentry[n]} + 3 ))

		        tput cup $(( headerheight )) $horizontalconnectorposition
		
		    echo -n "┷"


		    fi
	    done
	    
	fi
	
	
}

# Populate the drawn menu template with themenuitelms
function write_menu_items {

#draw the menu items
#If the position is right, it changes the background.
#As the variable does not get modified, this needs no resetting

for (( n=0; n < $menulength; n++ ))
do
	if [[ "${menuentry[n]}" = "skip" ]]; then

	((n++))

	fi
	if [[ n -eq $menupos ]] && [[ "$activepanel" = "left" ]];then
		tput cup $(( n + $headerheight + 2 )) 2
		echo -e "\e[00;30;47m${menuentry[$menupos]}\e[00m"
	else
		tput cup $(( n + $headerheight + 2 )) 2
		echo "${menuentry[n]}"

	fi

done

cursorpos=`tput lines`
tput cup $cursorpos 0

}



# This is hardcoded for now
function write_help_menu_items {

    menulength=3

    helpmenuentry[0]="1 - Basic usage guide (MarkDown)"
    helpmenuentry[1]="2 - Configuration and scripting guide (MarkDown)"
    helpmenuentry[2]="3 - The Lazy Admin man page (man)"
    
    

    for (( n=0; n < $menulength; n++ ))
do
	if [[ "${helpmenuentry[n]}" = "skip" ]]; then

	((n++))

	fi
	if [[ n -eq $menupos ]] && [[ "$activepanel" = "left" ]];then
		tput cup $(( n + $headerheight + 2 )) 2
		echo -e "\e[00;30;47m${helpmenuentry[$menupos]}\e[00m"
	else
		tput cup $(( n + $headerheight + 2 )) 2
		echo "${helpmenuentry[n]}"

	fi

done


}







# Draw rightpanel items
function write_rightpanel_items {

for (( n=0; n < $rightpanellength; n++ ))
do
	if [[ "${rightpanelentry[n]}" = "skip" ]]; then

	((n++))

	fi
	if [[ n -eq $menupos ]] && [[ "$activepanel" = "right" ]]; then
		tput cup $(( n + $headerheight + 2 )) $(( $menuwidth-$rightpanelwidth+3 ))
		echo -e "\e[00;30;47m${rightpanelentry[$menupos]}\e[00m"
	else
		tput cup $(( n + $headerheight + 2 )) $(( $menuwidth-$rightpanelwidth+3 ))
		echo "${rightpanelentry[n]}"

	fi
done

cursorpos=`tput lines`
tput cup $cursorpos 0
}

#Draws a line
function draw_line {

	#draw line with the length of the screen/window width
	for (( i=0; i<$menuwidth; i++ ))
	do
		echo -n "━"
	done
	#cursor goes to next row

}

#clear menu area
function clear_menu {
	for (( n=1; n<$menuheight; n++ ))
	do
		tput cup $(( n + $headerheight )) $(( $menuwidth-$rightpanelwidth-1 ))
		echo -e "\033[1K"
	done
}

#Draws the outline of the menu, with spaces left out for inclusion of items
function draw_menu {

	if [[ $subflagsmenu == "true" ]]; then
		let menuheight=$menulength+3
		headerheight=$subheaderheight;
		title=$subflagsmenutitle

	elif [[ $submenu == "true" ]]; then
		headerheight=$subheaderheight;
		title=$submenutitle
	else
		headerheight=$mainheaderheight
		title=$maintitle
	fi

	if [[ "$root" == "true" ]]; then

		title=$title$roottitle
	fi

	## Set width of screen and panels
	menuwidth=( `tput cols` - 1 )

	if ! $rightpanel; then
		rightpanelwidth=0
	fi

	leftpanelwidth=$(( $menuwidth-$rightpanelwidth ))

	#clear menu area. Should be done each time tabs or submenus are changed
	clear_menu

	#draw title
	cursorpos=0
	tput cup $cursorpos 0
	draw_line
	((cursorpos++))
	tput cup $cursorpos 0
	#echo "│       "
	tput cup $cursorpos $(( menuwidth/2 - (${#title}/2) ))

	#title must be set by function for submenus...
	if [[ "$root" != "true" ]]; then
		echo -e "\e[01m$title\e[00m"
	else
		echo -e "\e[01m\e[01;31m$title\e[00m"
	fi
	#tput cup $cursorpos $menuwidth
	#echo "│"
	((cursorpos++))
	draw_line

	#Draw top and bottom border of menu tabs
	#Skip this for submenus
	if ! $submenu; then
		((cursorpos++))
		tput cup $cursorpos 0
		#echo -n "│"
		tput cup $cursorpos $menuwidth
		#echo "│"
		((cursorpos++))
		tput cup $cursorpos 0
		draw_line
	fi

	# If rigth panel is on, draw its separator
	if $rightpanel; then
	
	    cursorpos=$headerheight
	    
	    if $rightpanel && [[ $displaylineconnectors == "true" ]]; then
	    
	        tput cup $cursorpos $(( $menuwidth-$rightpanelwidth ))
	        echo "┯"
	    
	    fi
	
	    ((cursorpos++))

	    for (( i=0; i<menuheight; i++ ))
	    do
	        tput cup $cursorpos $(( $menuwidth-$rightpanelwidth ))
	        echo "│"
        	((cursorpos++))
	    done
          
	    
	    
	fi

	cursorpos=$(( $headerheight+$menuheight ))

	tput cup $cursorpos 0
	draw_line
	
	
	if $rightpanel && [[ $displaylineconnectors == "true" ]]; then
	
	    tput cup $cursorpos $(( $menuwidth-$rightpanelwidth ))
	    echo "┷"
	    
	fi
	
	(( cursorpos+=$(( $descriptorheight+1 )) ))

	tput cup $cursorpos 0
	draw_line

}

# Simply write a one line descriptor, as read from the menu file
function write_descriptor {
	cursorpos=$(( $headerheight+$menuheight+$descriptorheight ))
	tput cup $cursorpos $menuwidth
	echo -e "\033[1K"
	tput cup $cursorpos 2
  	echo "${menudescentry[$menupos]}"
}

# Simply write a one line descriptor, as read from the menu file
function write_help_descriptor {

    helpmenudescentry[0]="Basic everyday usage"
    helpmenudescentry[1]="imn depth configuration guide"
    helpmenudescentry[2]="Display the traditional man paghe"

	cursorpos=$(( $headerheight+$menuheight+$descriptorheight ))
	tput cup $cursorpos $menuwidth
	echo -e "\033[1K"
	tput cup $cursorpos 2
    
    if [[ "$activepanel" = "right" ]]; then
    
        echo "${menudescentry[$menupos]}"
    
    else

    	echo "${helpmenudescentry[$menupos]}"
	
	fi
}






# Causes the selector to jump to the "other end" of the menu, if reaching either the top or the bottom
function infinite_menu {

	if [[ "$activepanel" = "right" ]]; then
		limit=$rightpanellength
	else
		limit=$menulength
	fi


	if [[ $menupos -ge $limit ]]; then
		menupos=0
	fi
	if [[ $menupos -lt 0 ]]; then
		menupos=$(( $limit-1 ))
	fi

}

# This function will invoke a submenu where you can set flags/arguments/parameters for the spcified command or function
# Call with parameters (args), like this:
#
# submenu_flags_function $tabpos $menupos "Title" function_or_command_to_call 1st_flag 2nd_flag 3rd_flag 4th_flag 5th_flag
#
# submenu_flags_function currently supports five preset flags, this can be changed by modifying the menu structure below
#

function pick_menu_item {

# Credit for the below picking solution (first 5 lines) goes for eMPee584
# where he has originally presented it in his answer on stackoverflow.com
# It does allows to read both arrow keys and single characters from a keyboard
#
# original thread:
#
# http://stackoverflow.com/questions/10679188/casing-arrow-keys-in-bash
#
#Original comment lines:
#
#check for input
#The picker sets the position of the highlighter.
#Arrow keys are 3 character, but want to be able to read single chars too

   read -sN1 key # 1 char (not delimiter), silent
  read -sN1 -t 0.0001 k1 # timed reads to check for second third etc characters
  read -sN1 -t 0.0001 k2
  read -sN1 -t 0.0001 k3
  read -sN1 -t 0.0001 k4 # timed reads to check for second third etc characters
  read -sN1 -t 0.0001 k5
  read -sN1 -t 0.0001 k6
  key+=${k1}${k2}${k3}${k4}${k5}${k6}

    case $key in

         $'\e[A'|$'\e0A'|"w"|"W")

	        #Double jump if run on skip
	        if [[ "$activepanel" = "left" ]] && [[ "${menuentry[$menupos-1]}" = "skip" ]]; then
		        ((menupos--))
	        fi
	        #Check for right panel too
	        if [[ "$activepanel" = "right" ]] && [[ "${rightpanelentry[$menupos-1]}" = "skip" ]]; then
		        ((menupos--))
	        fi

	        ((menupos--))
	         ;;

         $'\e[B'|$'\e0B'|"s"|"S")

	        #Double jump if running on skip
	        if [[ "$activepanel" = "left" ]] && [[ "${menuentry[$menupos+1]}" = "skip" ]]; then
		        ((menupos++))
	        fi
	        #Chexck for right panel too
	        if [[ "$activepanel" = "right" ]] && [[ "${rightpanelentry[$menupos+1]}" = "skip" ]]; then
		        ((menupos++))
	        fi

	        ((menupos++))
	        ;;

         $'\e[D'|$'\e0D'|"a"|"A")

	        if [[ "$submenu" = "false" ]]; then
		        if [[ $tabpos -gt 0 ]]; then
			        clear_menu
			        menupos=0
			        ((tabpos--))
		        fi
	        fi
	        ;;

         $'\e[C'|$'\e0C'|"d"|"D")
	        if [[ "$submenu" = "false" ]]; then
		        if [[ $tabpos -lt $tablength ]]; then
			        clear_menu
			        menupos=0
			        ((tabpos++))
		        fi
	        fi
	        ;;
	     $'\e[1;5C'|$'\e01;5C'|"r"|"R")
            if $rightpanel && [[ "$activepanel" = "left" ]]; then
			    activepanel="right"
			    menupos=0
		    fi
            ;;
         $'\e[1;5D'|$'\e01;5D'|"l"|"L")
            if $rightpanel && [[ "$activepanel" = "right" ]]; then
			    activepanel="left"
			    menupos=0
		    fi
            ;;
      

         [0-9])

	        # If numeric input is selected
	        if [[ $key -le $menulength ]] && [[ $key -ge 0 ]]; then
	        ((key--))
	        menupos=$key
	        if [[ "$submenu" = "true" ]]; then
		        subfunct$tabpos$mainmenupos$key $tabpos $menupos
	        else
		        funct$tabpos$key $tabpos $menupos
	        fi

	        fi
	         ;;

         '')
	        # If enter is pressed
	        if [[ "$activepanel" = "right" ]]; then
		        functright$menupos
	        else
		        if [[ "$submenu" = "true" ]]; then
			        subfunct$tabpos$mainmenupos$menupos $tabpos $menupos
		        else

				        funct$tabpos$menupos $tabpos $menupos

		        fi
	        fi

	        init_menu
	         ;;

        #right menu items (on keypress)
         "f" | "F")	#put this into a function so that enter can be used, along with alias
	        reflow_menu
	        ;;
        "h" | "H")
	        display_help
	        ;;
         "q" | "Q") #this handles exit function
	        functright3
	        ;;
        "b" | "B")
		        if [[ "$submenu" = "true" ]]; then
			        back_to_main_menu
			        break
		        fi
		        ;;
        "e" | "E")
	        if [[ $tabpos = $tablength  ]]; then
		        functsetup0
		        init_menu
	        fi
	        ;;
        "u" | "U")
	        if [[ $tabpos = $tablength  ]]; then
		        functsetup1
		        init_menu
	        fi
	        ;;
        "m" | "M")
	        if [[ $tabpos = $tablength  ]]; then
		        functsetup2
		        init_menu
	        fi
	        ;;
        "v" | "V")
	        if [[ $tabpos = $tablength  ]]; then
		        functsetup3
		        init_menu
	        fi
	        ;;


    esac

}


function pick_help_menu_item {

  read -sN1 key # 1 char (not delimiter), silent
  read -sN1 -t 0.0001 k1 # timed reads to check for second third etc characters
  read -sN1 -t 0.0001 k2
  read -sN1 -t 0.0001 k3
  read -sN1 -t 0.0001 k4 # timed reads to check for second third etc characters
  read -sN1 -t 0.0001 k5
  read -sN1 -t 0.0001 k6
  key+=${k1}${k2}${k3}${k4}${k5}${k6}
  
  case $key in

 $'\e[A'|$'\e0A'|"w"|"W")

	
	#Check for right panel skip
	if [[ "$activepanel" = "right" ]] && [[ "${rightpanelentry[$menupos-1]}" = "skip" ]]; then
		((menupos--))
	fi

	((menupos--))
	 ;;

 $'\e[B'|$'\e0B'|"s"|"S")

	
	#Chexck for right panel skip
	if [[ "$activepanel" = "right" ]] && [[ "${rightpanelentry[$menupos+1]}" = "skip" ]]; then
		((menupos++))
	fi

	((menupos++))
	;;
 $'\e[1;5C'|$'\e01;5C'|"r"|"R")
    if $rightpanel && [[ "$activepanel" = "left" ]]; then
		activepanel="right"
		menupos=0
	fi
    ;;
 $'\e[1;5D'|$'\e01;5D'|"l"|"L")
    if $rightpanel && [[ "$activepanel" = "right" ]]; then
		activepanel="left"
		menupos=0
	fi
    ;;
  
   [0-2])

	# If numeric input is selected
	if [[ $key -le 2 ]] && [[ $key -ge 0 ]]; then
	    ((key--))
	    menupos=$key
	    functhelp$key

	fi
	;;
    '')
	# If enter is pressed
	

	
	if [[ "$activepanel" = "right" ]]; then
		functright$menupos
	else
		
		functhelp$menupos
		
	fi
	init_menu
	 ;;

    #right menu items (on keypress)
     "f" | "F")	#put this into a function so that enter can be used, along with alias
	    reflow_menu
	    ;;
     "q" | "Q") #this handles exit function
	    functright3
	    ;;
    'b' | "B")
		    if [[ "$submenu" = "true" ]]; then
			    back_to_main_menu "reflow"
			    break
		    fi
		    ;;
        
    
    esac
}

function menu_item_picker_subflags	{

	  read -sN1 key # 1 char (not delimiter), silent
      read -sN1 -t 0.0001 k1 # timed reads to check for second third etc characters
      read -sN1 -t 0.0001 k2
      read -sN1 -t 0.0001 k3
      read -sN1 -t 0.0001 k4 # timed reads to check for second third etc characters
      read -sN1 -t 0.0001 k5
      read -sN1 -t 0.0001 k6
      key+=${k1}${k2}${k3}${k4}${k5}${k6}


		case $key in

		$'\e[A'|$'\e0A'|"w"|"W")
			#Double jump if run on skip
			if [[ "${menuentry[$menupos-1]}" = "skip" ]]; then
				((menupos--))
			fi
			((menupos--))
			;;
		$'\e[B'|$'\e0B'|"s"|"S")
			#Double jump if running on skip
			if [[ "${menuentry[$menupos+1]}" = "skip" ]]; then
				((menupos++))
			fi
			((menupos++))
			;;

		[0-9])

		# If numeric input is selected
		let argstoset=$#-3
		if [[ $key -le "$argstoset+1" ]] && [[ $key -ge 0 ]]; then
		((key+=2))

		set_args=$set_args' '${!key}
		fi
		;;


		'm' | 'M')  echo
            tput cnorm
		    echo "Type your arguments here, and press enter "
			echo
			read -p "> " lineargs
			set_args=$set_args' '$lineargs
            tput civis
			clear
			draw_menu
			;;

		'c' | 'C')

			clear
			echo
			echo "Executing:"
			echo "$submenucommand $set_args"
			echo
			$submenucommand $set_args
			echo
			echo "Now press a key to get back to the menu"
			read -n 1 -s keypress
			break
			;;

		'x' | 'X') set_args=''
			clear
			draw_menu
			;;


		'')
			# If enter is pressed
			if [[ "$activepanel" = "right" ]]; then

				functright$menupos

			else

                    # Alllow maximum 9 items.
                    # 9 have been written, but this counts the offset
                    # in args instead of what was really selected
                    # The total number of args is 11 (the title, command itself, then the
                    # "real" args)
                    maxlengthoffset=0;

                    if [[ $# -gt 11 ]]; then

                        let lenghtdiff=$#-11
                        let maxlengthoffset=$maxlengthoffset+$lenghtdiff

                    fi


                    let argstoset=$#-3-$maxlengthoffset



					if [[ $menupos -le "$argstoset" ]] && [[ $menupos -ge 0 ]]; then

							#reference parameters by number according to menuposition
							let addarg=$menupos+3

							set_args=$set_args' '${@:$addarg:1}

					else

					let manual_flags=$argstoset+1
					let commit_flags=$argstoset+2
					let delete_flags=$argstoset+3

					case $menupos in

					$manual_flags)  echo
                        tput cnorm
						echo "Type your arguments here, and press enter"
						echo
						read -p "> " lineargs
						set_args=$set_args' '$lineargs
                        tput civis
						clear
						draw_menu

						;;

					$commit_flags)
						clear
						echo "Executing:"
			            echo "$submenucommand $set_args"
			            echo
						$submenucommand $set_args
						echo
						echo "Now press a key to get back to the menu"
						read -n 1 -s keypress
						break
						;;

					$delete_flags) set_args=''
						clear
						draw_menu
					;;

					esac
				fi

			fi
			;;

	#switch between left and right menus
	
	 $'\e[1;5C'|$'\e01;5C'|"r"|"R")
        if $rightpanel && [[ "$activepanel" = "left" ]]; then
			activepanel="right"
			menupos=0
		fi
        ;;
     $'\e[1;5D'|$'\e01;5D'|"l"|"L")
        if $rightpanel && [[ "$activepanel" = "right" ]]; then
			activepanel="left"
			menupos=0
		fi
        ;;
	
	
	

	#right menu items (on keypress)
	"f" | "F")
		reflow_menu
		;;
	"h" | "H")
		display_help
		;;
	"q" | "Q")
		#this handles exit
		functright3
		;;
	'b' | "B")
		back_to_main_menu
		break
		;;

	esac

}


function flags_submenu_function {

    menuentry=()

    set_args=""
    
  if [[ $submenu == "true" ]]; then

        remaininsubmenu="true"
        oldsubmenutitle="$submenutitle"
        oldtabpos=$tabpos
        oldmainmenupos=$mainmenupos
	    
       
    else
    
        remaininsubmenu="false"
        
    fi
    

      
    submenu="true"
	subflagsmenu="true"
    	
  
	subflagsmenutitle="$1"
	submenucommand="$2"
	submenucall="${@:3}"
	menupos=0

	#Have to empty the arguments each time, as set_submenu_function is not an "object", but just a single instance of a function.
	#Best avoid confusion
	

	clear

	set_flags_submenu_items "$@"

	read_rightpanel_items
	draw_menu
	while true; do

		set_flags_submenu_items "$@"

		read_rightpanel_items
		infinite_menu
		write_menu_items

		if $rightpanel; then
			write_rightpanel_items
		fi

		write_flags_descriptor

		echo
		echo

		## TODO: Got to make sure this does not go ovber the screen limit
		echo "Active command: "$submenucommand $set_args


		#if [[ -n $set_args ]]; then
	    #   echo "The active flags (args) are: $set_args"
		#else
		#	echo "No flags (args) specified"
		#fi

	menu_item_picker_subflags "$@"


	done
	#submenu="$sourcesubmenu"
	subflagsmenu="false"
	
}

#Right panel functions
#this is the standard reflow function

function reflow_menu {

	clear
	draw_menu
	infinite_menu
	write_menu_items
	write_descriptor

}

function display_help {
    
      
      
    if [[ $subflagsmenu == "true" ]]; then
    
        functhelp_commanbuilder
    
        reflow_menu
   
    
    else
        
       	enter_helpmenu
    
    fi
    
	
	
	
}

function exit_la_menus {


    if [[ $restorecursor == "true"  ]]; then

        tput cnorm

    fi

    if [[  $rootexitflag == "true" ]]; then

        tput cnorm

    fi
	clear
	echo
	echo "$@"
	echo
	exit 0

}




function back_to_main_menu {

    activepanel="left"
	#mainmenupos=0
	menupos=0
	
	subflagsmenu="false"
	
    helpsubmenu="false"
	

    if [[ $remaininsubmenu == "true" ]]; then

        submenu="true"      
        remaininsubmenu="false"
        submenutitle="$oldsubmenutitle"
        tabpos=$oldtabpos
        mainmenupos=$oldmainmenupos
    
    else
      
    	submenu="false"
     
	fi
	
	read_rightpanel_items
    #init_menu
    clear_menu

    if [[ $1 == "reflow" ]]; then

        reflow_menu
    
    fi
    
    break
		
}


# redraws items of main menu and includes the picker
function main_menu {

submenu="false"
subflagsmenu="false"

read_tab_items
read_menu_items
read_descriptor
infinite_menu

write_tab_items
write_menu_items

if $rightpanel; then
	write_rightpanel_items
fi

#Write basic description
write_descriptor


pick_menu_item

}

function sub_menu {

    submenu="true"
    subflagsmenu="false"

    read_tab_items
    read_menu_items $1 $2
    read_descriptor $1 $2
    infinite_menu

    write_menu_items

    if $rightpanel; then
	    write_rightpanel_items
    fi

    #Write basic description
    write_descriptor


    pick_menu_item

}


function help_menu {

    #submenu="true"
    subflagsmenu="false"
    read_descriptor $1 $2
    infinite_menu
    write_help_menu_items
    
    if $rightpanel; then
	    write_rightpanel_items
    fi
    
    write_help_descriptor
    pick_help_menu_item

}


function init_menu {
	if [[ "$(whoami)" != "root" ]]; then
		root="false"
	else
		root="true"
	fi

	clear
	
	
	
    read_menu_items $1 $2
    read_descriptor $2 $2


	read_rightpanel_items
	draw_menu

}

function init_help_menu {

   
    if [[ "$(whoami)" != "root" ]]; then
		root="false"
	else
		root="true"
	fi

	clear

	read_help_rightpanel_items
	read_descriptor $2 $2
	draw_menu



}


function enter_submenu {

	submenu="true"
	submenutitle="$3"
	mainmenupos="$menupos"
	menupos=0

	init_menu $1 $2
	while true; do
		sub_menu $1 $2
	done
}


function enter_helpmenu {

    helpsubmenu="true"
    
    if [[ $submenu == "true" ]]; then

        remaininsubmenu="true"
        oldsubmenutitle="$submenutitle"
        oldtabpos=$tabpos
        oldmainmenupos=$mainmenupos
	    
       
    else
    
        remaininsubmenu="false"
        
    fi

    submenu="true"
	submenutitle="Help"

	mainmenupos="$menupos"
	menupos=0
	
	
	init_help_menu
	while true; do
		help_menu
	done

}



#Right panel functions

function functright0 {

	reflow_menu

}

function functright1 {

   display_help

}

function functright3 {

	if [[ "$root" == "true" ]]; then
		exit_la_menus "Leaving root shell"
	else

		exit_la_menus "Exiting..."
	fi

}

function functright2 {
    
    
    # Need this, to redraw title for some reason...
    if [[ $helpsubmenu == "true" ]]; then
    
        backargument="reflow"
    
    fi
    
   	back_to_main_menu $backargument
   	
   	
}

function functright4 {

	#Your code here
echo "nothing"
}




# Initialises and displays the main menu
function main {

    restorecursor=$2

   #Hide the cursor, we dn't really need it
   tput civis

   if [[ $1 != "default"  ]]; then

       oldmaintitle="$maintitle"
       maintitle="$1"
       
   else

       if [[ "$oldmaintitle" != "" ]]; then

               maintitle="$oldmaintitle"

       fi

   fi



   init_menu

   while true; do

           main_menu

   done
}

