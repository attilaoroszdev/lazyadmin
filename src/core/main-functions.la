#!/bin/bash
#
# Copyright © 2017-2025, Attila Orosz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#This file fontains the functions providing basic functionality of the menu system
#Cusom "user functions" will be stored in $USER-DIR/user-function.la


# normal_menu_height=$(( $MAX_MENU_ITEMS + 3 ))
# submenu_height=$(( $MAX_SUBMENU_ITEMS + 3 )) 
# menu_height=0

menus_force_hidden=false
tabs_dont_fit=false
all_tabs_length=0
right_panel_height_warning=false
right_panel_width_warning=false
height_warning=false
normal_menu_height=0
submenu_height=0
menu_height=0
show_right_panel=$right_panel
max_menu_height=0


declare -a RIGHT_PANEL_ITEMS_KEYS
declare -a SUBMENU_RIGHT_PANEL_ITEMS_KEYS
declare -a CMB_RIGHT_PANEL_ITEMS_KEYS
declare -a HELP_RIGHT_PANEL_ITEMS_KEYS

declare -a RIGHT_PANEL_ITEMS
declare -a SUBMENU_RIGHT_PANEL_ITEMS
declare -a CMB_RIGHT_PANEL_ITEMS
declare -a HELP_RIGHT_PANEL_ITEMS

declare -a RIGHT_PANEL_ITEMS_DESC
declare -a SUBMENU_RIGHT_PANEL_ITEMS_DESC
declare -a CMB_RIGHT_PANEL_ITEMS_DESC
declare -a HELP_RIGHT_PANEL_ITEMS_DESC


declare -a RIGHT_PANEL_ITEM_ROWS
declare -a SUBMENU_RIGHT_PANEL_ITEM_ROWS
declare -a CMB_RIGHT_PANEL_ITEM_ROWS
declare -a HELP_RIGHT_PANEL_ITEM_ROWS



declare -i RIGHT_PANEL_LENGTH
declare -i CMB_RIGHT_PANEL_LENGTH

# TODO find and declare all global variables here, use `declare`, see https://unix.stackexchange.com/questions/510220/what-is-declare-in-bash
# TODO, all global variables should be UPPER_CASE, 
# TODO Make constants `readonly`
# TODO make local variables really local with the `local` keyword
set_menu_sizes() {
    terminal_height=$(tput lines)
    terminal_width=$(tput cols)

    # echo "Terminal height: $terminal_height"
    # sleep 1

    if [[ $terminal_height -lt $MIN_TERMINAL_HEIGHT ]] || [[ $terminal_width -lt $MIN_TERMINAL_WIDTH ]]; then
        menus_force_hidden=true
        show_force_hide_error
    else
        menus_force_hidden=false
        right_panel_height_warning=false
        right_panel_width_warning=false
        height_warning=false
        normal_menu_height=$(( $MAX_MENU_ITEMS + 3 ))
        submenu_height=$(( $MAX_SUBMENU_ITEMS + 3 )) 
        menu_height=0

        show_right_panel=$right_panel

        if [[ $terminal_height -lt $MIN_TERM_HEIGHT_FOR_R_PANEL ]]; then
            show_right_panel=false
            if $right_panel; then
                right_panel_height_warning=true
            fi
        fi

        if [[ $terminal_width -lt $(($RIGHT_PANEL_WIDTH * 2)) ]]; then
            show_right_panel=false
            if $right_panel; then
                right_panel_width_warning=true
            fi
        fi

        if ! $show_right_panel $$ [[ $active_panel -eq "right" ]]; then
            active_panel="left"
        fi

        max_menu_height=$(($terminal_height - 10))

        # Got to make sure we fit inside whatever size the terminal currently is
        if [[ $normal_menu_height -gt $max_menu_height ]]; then
            normal_menu_height=$max_menu_height
            height_warning=true
        else
            height_warning=false
        fi

        if [[ $submenu_height -gt $(($max_menu_height + 2)) ]]; then
            submenu_height=$(($max_menu_height + 2))
        fi

        if $show_right_panel; then
            
            if [[ $normal_menu_height -lt $MIN_MENU_HEIGHT ]]; then
                normal_menu_height=$MIN_MENU_HEIGHT
            fi

            if [[ $submenu_height -lt $MIN_MENU_HEIGHT ]]; then
                submenu_height=$MIN_MENU_HEIGHT
            fi

        else
            
            if [[ $normal_menu_height -lt $MIN_MENU_HEIGHT_SINGLE_PANEL ]]; then
                normal_menu_height=$MIN_MENU_HEIGHT_SINGLE_PANEL
            fi

            if [[ $submenu_height -lt $MIN_MENU_HEIGHT_SINGLE_PANEL ]]; then
                submenu_height=$MIN_MENU_HEIGHT_SINGLE_PANEL
            fi

        fi
        
        $menu_height=$normal_menu_height
    fi

}

show_force_hide_error() {
    clear
        echo
        echo -n "Cannot display menus on this terminal. If you are in an emulator, you need to resize the window"
        if ! $AUTO_REFLOW; then
            echo -n ", and press 'f' to re-draw the menu; "
        else
            echo -n "; "
        fi
        
        echo -n "or press 'q' to quit."
        echo -e '\n'

        if [[ $terminal_height -lt $MIN_TERMINAL_HEIGHT ]]; then
            echo "Minimum supported height: $MIN_TERMINAL_HEIGHT characters."
            echo -e "Current height: \e[01m\e[091m$terminal_height\e[00m characters"
            echo
        fi
        if [[ $terminal_width -lt $MIN_TERMINAL_WIDTH ]]; then
            echo "Minimum supported width: $MIN_TERMINAL_WIDTH characters."
            echo -e "Current width: \e[01m\e[091m$terminal_width\e[00m characters"
            echo
        fi
}


check_for_size_changes() {
    if [[ $terminal_height -ne $(tput lines) ]] || [[ $terminal_width -ne $(tput cols) ]]; then
        reflow_menu
        return 1
    fi

    return 0
}

set_up_menus() {
    tick=$AUTO_REFLOW_TICK


    # Safe value for $tick, we don't want the system to freeze...    
    if [[ ! $tick -ge 1 ]] || [[ $tick -lt 1 ]]; then
        tick=0.5
    fi

    if [[ -f $menu_file ]]; then
        echo "Setting menus..."
        set_menu_sizes     
    else
        clear
        echo
        echo "Looked for menus in:"
        echo $menu_file
        echo
        echo "Error: Cannot find menuentries file in default location. Exiting..."
        echo
        exit 65
    fi
}

find_menu_type() {     
    OLDIFS="$IFS"
    IFS=$'\n'
    menu_type=($(cat $menu_file | sed -n '/'_menutype'/{:a;n;/'_endmenutype'/q;p;ba}'))
    IFS="$OLDIFS"
}


#This function will read the menu entries from the menu entries file as set in defaults
read_menu_items() { 
    menu_item=$tab_pos
    sub_parent=$1
    sub_item=$2

    if [[ $menu_type == "simple" ]]; then
        ((menu_item++))
        ((sub_parent++))
        ((sub_item++))
    fi

    menu_entry=""

    if $submenu; then
        OLDIFS="$IFS"
        IFS=$'\n'
        menu_entry=($(cat $menu_file | sed -n '/'_submenu$sub_parent$sub_item'/{:a;n;/'_endsubmenu$sub_parent$sub_item'/q;p;ba}'))

        
        if $sub_flags_menu; then
            menu_height=$($submenu_height+1)
            max_menu_length=$(($submenu_height - 2))
        elif $help_submenu; then
            menu_height=$HELP_SUB_MENU_HEIGHT
            max_menu_length=$((HELP_SUB_MENU_HEIGHT - 2))
        else
            menu_height=$submenu_height
            max_menu_length=$(($submenu_height - 3))
        fi

        IFS="$OLDIFS"
    else
        OLDIFS="$IFS"
        IFS=$'\n'
        menu_entry=($(cat $menu_file | sed -n '/'_menu$menu_item'/{:a;n;/'_endmenu$menu_item'/q;p;ba}'))
        menu_height=$normal_menu_height
        max_menu_length=$(($normal_menu_height - 3))
        IFS="$OLDIFS"
    fi
    
    menu_length=${#menu_entry[@]}

    # if [[ $menu_length -gt $max_menu_length ]]; then
    #     for ((i = $max_menu_length; i < $menu_length; i++)); do
    #         unset "menu_entry[$i]"
    #     done
    # fi

    # menu_length=${#menu_entry[@]}
}


set_command_builder_items() {     
    #Parse the argument list into the array, starting form the 3rd argument
    array_offset=2
    array_counter=1

    for i in "$@"; do
 
        if [[ $array_counter -gt $array_offset ]]; then
            if [[ $array_counter -ge $(($max_menu_height - 5)) ]]; then
                break
            fi

            local current_flag_item=$(($array_counter-2))
            menu_entry[$current_flag_item - 1]="$current_flag_item - Set arg. $i"
        
        fi

        ((array_counter++))

    done
    
    local last_entry=""
    
    if [[ -n $menu_entry ]]; then
        last_entry=${menu_entry[${#menu_entry[@]} - 1]}
    fi

    # #Check if entries have already been written, by checking last element
    # if [[ "$last_entry" != "x - Delete set flags" ]]; then
    #     menu_entry+=("m - Enter arguments manually")
    #     menu_entry+=("o - Enter flag-options (no space)")
    #     menu_entry+=("c - Commit with flags")
    #     menu_entry+=("x - Delete set flags")
    # fi

    menu_length=${#menu_entry[@]}
}


write_flags_descriptor() { 
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2
    case ${menu_entry[$menu_pos]} in
    "m - Manually enter flags ")
        echo "Manually enter flags for the command specified"
        ;;
    "c - Commit with flags")
        echo "Finished entering flags, proceed with command"
        ;;
    "x - Delete set flags")
        echo "Clear list of set flags to start over again"
        ;;
    *)
        echo "Set the specified flag"
        ;;
    esac
}


# read descriptor lines for menu items
# years later: I have no idea how sed works any more, so this all looks like magic
read_descriptor() { 
    if [[ -z $menu_type || $menu_type == "old" ]]; then
        
        if $submenu; then
            OLDIFS="$IFS"
            IFS=$'\n'

            if [[ "$active_panel" == "right" ]]; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_subrightpaneldesc'/{:a;n;/'_endsubrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_descsubmenu$1$2'/{:a;n;/'_enddescsubmenu$1$2'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        else
            OLDIFS="$IFS"
            IFS=$'\n'

            if [[ "$active_panel" == "right" ]]; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_rightpaneldesc'/{:a;n;/'_endrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_descmenu$tab_pos'/{:a;n;/'_enddescmenu$tab_pos'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        fi

    else

        if [[ "$active_panel" == "right" ]]; then
            for ((n = 0; n < $menu_length; n++)); do
                eval $(echo ${menu_entry[$n]} | sed 's:^:V1=":; /\:\:/ s::";V2=": ;s:$:":')
                menu_entry[$n]="$(echo $V1)"
            done

            OLDIFS="$IFS"
            IFS=$'\n'

            if $submenu; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_subrightpaneldesc'/{:a;n;/'_endsubrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_rightpaneldesc'/{:a;n;/'_endrightpaneldesc'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        else
            for ((n = 0; n < $menu_length; n++)); do
                eval $(echo ${menu_entry[$n]} | sed 's:^:V1=":; /\:\:/ s::";V2=": ;s:$:":')
                menu_entry[$n]="$(echo $V1)"
                menu_desc_entry[$n]="$(echo $V2)"
            done
        fi
    fi
}


# Load the items shown in the tab
read_tab_items() {     
    OLDIFS="$IFS"
    IFS=$'\n'

    if $alt_menu; then
        tab_entry=($(cat $menu_file | sed -n '/'_submenutab$tab_pos$menu_pos'/{:a;n;/'_endsubmenutab$tab_pos$menu_pos'/q;p;ba}'))
    else
        tab_entry=($(cat $menu_file | sed -n '/'_menutab'/{:a;n;/'_endmenutab'/q;p;ba}'))
    fi

    IFS="$OLDIFS"
    tab_length=$((${#tab_entry[@]} - 1))

    if [[ $tab_length -gt 9 ]]; then
        for ((i = 10; i < $tab_length + 1; i++)); do
            unset "tab_entry[$i]"
        done

        tab_length=9
    fi
}


read_rightpanel_items() {     
    # OLDIFS="$IFS"
    # IFS=$'\n'

    # RIGHT_PANEL_ITEM_ROWS=($(cat $menu_file | sed -n '/'_rightpanel'/{:a;n;/'_endrightpanel'/q;p;ba}'))

    declare -a menu_file_contents
    

    while IFS= read -r line; do
        if [[ ! "$line" == "#"* ]] && [[ -n "$line" ]]; then
            menu_file_contents+=("$line")
        fi
    done < $menu_file
    
    # echo "menu files cxontents raw: ${menu_file_contents[@]}"


    for ((n = 0; n <= ${#menu_file_contents[@]}; n++)); do
        echo ${menu_file_contents[$n]}
    done

    sleep 5

    # TODO: Now proceed from item to item to test if it contains the correct thing, then save appropriately
    # TODO: Menu should only be read once
    # TODO: Do the same with regular menu items, only porepend thenm with TabName :: for later grouping



    # SUBMENU_RIGHT_PANEL_ITEM_ROWS=($(cat $menu_file | sed -n '/'_subrightpanel'/{:a;n;/'_endsubrightpanel'/q;p;ba}'))
    # CMB_RIGHT_PANEL_ITEM_ROWS=($(cat $menu_file | sed -n '/'_cmbrightpanel'/{:a;n;/'_endcmbrightpanel'/q;p;ba}'))
    # HELP_RIGHT_PANEL_ITEM_ROWS=($(cat $menu_file | sed -n '/'_helprightpanel'/{:a;n;/'_endhelprightpanel'/q;p;ba}'))

    # RIGHT_PANEL_LENGTH=${#RIGHT_PANEL_ITEM_ROWS[@]}
    # CMB_RIGHT_PANEL_LENGTH=${#CMB_RIGHT_PANEL_ITEM_ROWS[@]}
      
    # IFS="$OLDIFS"
}


read_help_rightpanel_items() {     
    OLDIFS="$IFS"
    IFS=$'\n'
    right_panel_entry=($(cat $menu_file | sed -n '/'_helprightpanel'/{:a;n;/'_endhelprightpanel'/q;p;ba}'))
    IFS="$OLDIFS"
    right_panel_length=${#right_panel_entry[@]}
}


#Display the menu tabs
write_tab_items() {  
    # Modify top line first, draw connectors
    tabs_dont_fit=false
    local current_tabs_length=0
    displayed_tab_entries=1

    all_tabs_length=0 #TODO:Global
    for ((n = 0; n <= $tab_length; n++)); do
        all_tabs_length=$(($all_tabs_length + ${#tab_entry[$n]} + 3))
    done
    ((all_tabs_length++))

    # Make sure tabs will fit
    for ((n = 0; n <= $tab_length; n++)); do
        current_tabs_length=$(($current_tabs_length + ${#tab_entry[$n]} + 3))
        if [[ $current_tabs_length -ge $terminal_width ]]; then
            tabs_dont_fit=true
            ((displayed_tab_entries--))
             if [[ $tab_pos -ge $displayed_tab_entries ]]; then
                select_tab $displayed_tab_entries
                reflow_menu
            fi
            break
        fi
        ((displayed_tab_entries++))
    done


    # Display joints if on, but not for the last item
    if $DISPLAY_LINE_CONNECTORS; then
        horizontal_connector_position=0
        tput cup $((header_height - 2)) $horizontal_connector_position

        for ((n = 0; n < $(($displayed_tab_entries - 2)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#tab_entry[$n]} + 3))
            tput cup $((header_height - 2)) $horizontal_connector_position
            echo -n "┯"
        done
    fi

    # Then write out the tab items, with separators
    tput cup $((header_height - 1)) 1
    for ((n = 0; n < $displayed_tab_entries; n++)); do
       
        if [[ $n -eq $tab_pos ]]; then
            echo -n -e "\e[00;30;47m ${tab_entry[$n]} \e[00m"
        else
            echo -n " ${tab_entry[$n]} "
        fi

        # Do not write separator after last item
        if [[ $n -lt $tab_length ]]; then
            echo -n "│"
        fi       
    
    done

    if $DISPLAY_LINE_CONNECTORS; then
        # Then draw connectors ont he bottom line, but not for the last item
        horizontal_connector_position=0
        tput cup $((header_height)) $horizontal_connector_position

        for ((n = 0; n < $(($displayed_tab_entries - 2)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#tab_entry[$n]} + 3))
            tput cup $((header_height)) $horizontal_connector_position

            if $show_right_panel && [[ $horizontal_connector_position == $(($menu_width - $active_right_panel_width)) ]]; then
                echo -n "┿"
            else
                echo -n "┷"
            fi
        done
    fi

    if $tabs_dont_fit; then
        tput cup $((header_height - 2)) $(($terminal_width-1)) 
        # echo -e "\e[091mm┓\e[0m"
        echo -e "\e[091m━\e[0m"
        tput cup $((header_height - 1)) $(($terminal_width-1))
        echo -e "\e[091m┋\e[0m"
        tput cup $((header_height)) $(($terminal_width-1))
        # echo -e "\e[01m\e[091m┛\e[00m"
        echo -e "\e[091m━\e[0m"
    fi

    check_for_warnings
}


# Populate the drawn menu template with the menu items
write_menu_items() { 
    # Draw the menu items
    # If the position is right, it changes the background.
    # As the variable does not get modified, this needs no resetting

    max_entry_lenght=$(($left_panel_width - 4))

    for ((n = 0; n < $max_menu_length; n++)); do

        if [[ ! "${menu_entry[$n]}" == "skip" ]]; then
         
            menu_item_line=$(truncate_text "${menu_entry[$n]}" $max_entry_lenght)

            tput cup $(($n + $header_height + 2)) 2

            if [[ $n -eq $menu_pos ]] && [[ "$active_panel" == "left" ]]; then
                echo -e "\e[00;30;47m$menu_item_line\e[00m"
            else
                echo "$menu_item_line"
            fi
        fi

    done

    local -i line_offset=3

    if $sub_flags_menu; then
        line_offset=4
    fi

    tput cup $(($max_menu_length + $header_height + $line_offset)) 1

    # If the item list was truncated, display a visual clue at the bottom
    if [[ $menu_length -gt $max_menu_length ]]; then
        for ((i = 0; i < $(($left_panel_width-2)); i++)); do
            echo -en "\e[01m\e[091m┅\e[00m"
        done
    else
        # Reset normal line, otherwise
        for ((i = 0; i < $(($left_panel_width-2)); i++)); do
            echo -n "━"
        done
    fi

    cursor_pos=$(tput lines)
    tput cup $cursor_pos 0
}


# This is hardcoded for now.
# Might gonna get its own resource file in a future release
# TODO Move these into a help-entries file, or something
write_help_menu_items() { 
    menu_length=3
    help_menu_entry[0]="1 - Lazy Admin usage guide"
    help_menu_entry[1]="2 - Configuration and scripting guide"
    help_menu_entry[2]="3 - Command builder usage guide"

    max_entry_lenght=$(($left_panel_width - 4))

    for ((n = 0; n < $menu_length; n++)); do
                
        if [[ "${help_menu_entry[$n]}" == "skip" ]]; then
            ((n++))
        fi

        help_item_line=$(truncate_text "${help_menu_entry[$n]}" $max_entry_lenght)

        tput cup $((n + $header_height + 2)) 2

        if [[ $n -eq $menu_pos ]] && [[ "$active_panel" == "left" ]]; then
            echo -e "\e[00;30;47m$help_item_line\e[00m"
        else
            echo "$help_item_line"
        fi

    done
}


write_rightpanel_items() { 
   
    local -i items_length=$RIGHT_PANEL_LENGTH
    # local -1 keys
    # local -a entries
    # local -a descriptions

    # if $sub_flags_menu; then
    #     items_length=("${CMB_RIGHT_PANEL_LENGTH[@]}")
    #     keys=("${CMB_RIGHT_PANEL_ITEMS_KEYS[@]}")
    #     entries=("${CMB_RIGHT_PANEL_ITEMS[@]}")
    #     descriptions=("${CMB_RIGHT_PANEL_ITEMS_DESC[@]}")
    # elif $submenu; then
    #     keys=("${SUBMENU_RIGHT_PANEL_ITEMS_KEYS[@]}")
    #     entries=("${SUBMENU_RIGHT_PANEL_ITEMS[@]}")
    #     descriptions=("${SUBMENU_RIGHT_PANEL_ITEMS_DESC[@]}")
    # elif $help_submenu; then
    #     keys=("${HELP_RIGHT_PANEL_ITEMS_KEYS[@]}")
    #     entries=("${HELP_RIGHT_PANEL_ITEMS[@]}")
    #     descriptions=("${HELP_RIGHT_PANEL_ITEMS_DESC[@]}")
    # else
    #     keys=("${RIGHT_PANEL_ITEMS_KEYS[@]}")
    #     entries=("${RIGHT_PANEL_ITEMS[@]}")
    #     descriptions=("${RIGHT_PANEL_ITEMS_DESC[@]}")
    # fi

    local -a current_item_rows

    if $sub_flags_menu; then
        items_length=("${CMB_RIGHT_PANEL_LENGTH[@]}")
        current_item_rows=("${CMB_RIGHT_PANEL_ITEM_ROWS[@]}")
    elif $submenu; then
        current_item_rows=("${SUBMENU_RIGHT_PANEL_ITEM_ROWS[@]}")
    elif $help_submenu; then
        current_item_rows=("${HELP_RIGHT_PANEL_ITEM_ROWS[@]}")
    else
        current_item_rows=("${RIGHT_PANEL_ITEM_ROWS[@]}")
    fi

    OLD_IFS=$IFS
    IFS="::"



    
    # echo "Items length: $items_length"

    for ((n = 0; n < $items_length; n++)); do
        
        local -a current_row
        read -a current_row <<< "${current_item_rows[$n]}"

        if [[ "${current_row[0]}" == "skip" ]]; then
            continue    
        elif  [[ "${current_row[0]}" == "divider" ]]; then
            tput cup $(($n + $header_height +2)) $(($menu_width - $active_right_panel_width))
            draw_divider_line $active_right_panel_width "right"
            continue
        fi

        tput cup $(($n + $header_height + 2)) $(($menu_width - $active_right_panel_width + 3))

        local displayed_item="${current_row[0]}""-""${current_row[2]}"

        local current_item=$(truncate_text "$displayed_item" $(($active_right_panel_width-4)))

        if [[ $n -eq $menu_pos ]] && [[ "$active_panel" == "right" ]]; then
            echo -e "\e[00;30;47m$current_item\e[00m"
        else
            echo -e "$current_item"
        fi

    done
    IFS=$OLD_IFS
    cursor_pos=$(tput lines)
    tput cup $cursor_pos 0
}


#Draws a line
draw_line() { 
    #draw line with the length of the screen/window width

    local -i line_lenght=$menu_width

    if [[ -n $1 ]] && [[ $1 -gt 0 ]] then
        line_lenght=$1
    fi

    for ((i = 0; i < $line_lenght; i++)); do
        echo -n "━"
    done
    #cursor goes to next row
}

draw_divider_line() {
    local -i line_lenght

    if [[ $2 -eq "right" ]]; then
        line_lenght=$(($active_right_panel_width-1))
    else
        if $show_right_panel; then
            line_lenght==$(($left_panel_width-1))
        else
            line_lenght==$menu_width
        fi
    fi

    if [[ $2 -eq "right" ]]; then
        echo -n "├"
    fi

    for ((i = 0; i < $(($line_lenght-1)); i++)); do
        echo -n "╶"
    done
    echo "╶"

    # if [[ $2 -eq "left" ]] && $show_right_panel; then
    #     echo -n "┤"
    # fi


}


#clear menu area
clear_menu() { 
    for ((n = 1; n < $menu_height; n++)); do
        tput cup $((n + $header_height)) $(($menu_width - $active_right_panel_width - 1))
        echo -e "\033[1K"
    done
}

# Usage clear_line $vertical_position $horizontal_positon $lenght
clear_line() {

    if [[ $# -lt 3 ]]; then
        return 65
    fi

    start_vertical=$1
    start_horizontal=$2
    clear_length=$3

    tput cup $start_vertical $start_horizontal

    for ((i = 0; i < $clear_length; i++)); do
        echo -n " "
    done
}

#Draws the outline of the menu, with spaces left out for inclusion of items
draw_menu() {
    if $menus_force_hidden; then
        show_force_hide_error
        return 1
    fi
    
    tput civis

    if $sub_flags_menu; then
        menu_height=$(($submenu_height-1))
        header_height=$SUB_HEADER_HEIGHT
        title=$sub_flags_menutitle
    else
        if $submenu; then

            if $help_submenu; then
                menu_height=$HELP_SUB_MENU_HEIGHT
            else
                menu_height=$submenu_height
            fi

            header_height=$SUB_HEADER_HEIGHT
            title=$submenu_title
        else
            menu_height=$normal_menu_height
            header_height=$MAIN_HEADER_HEIGHT
            title=$MAIN_TITLE
        fi

    fi

    if $root; then
        title=$title$ROOT_TITLE
    fi

    ## Set width of screen and panels
    menu_width=($(tput cols) - 1)

    if ! $show_right_panel; then
        active_right_panel_width=0
    else
        active_right_panel_width=$RIGHT_PANEL_WIDTH
    fi

    left_panel_width=$(($menu_width - $active_right_panel_width))
    
    #clear menu area. Should be done each time tabs or submenus are changed
    clear_menu
    cursor_pos=0
    tput cup $cursor_pos 0
    draw_line
    ((cursor_pos++))
    tput cup $cursor_pos $((menu_width / 2 - (${#title} / 2)))

    if [[ "$root" != "true" ]]; then
        echo -e "\e[01m$title\e[00m"
    else
        echo -e "\e[01m\e[091m$title\e[00m"
    fi

    ((cursor_pos++))
    draw_line

    #Draw top and bottom border of menu tabs
    #Skip this for submenus
    if ! $submenu; then
        ((cursor_pos+=2))
        tput cup $cursor_pos 0
        draw_line
    fi

    # If rigth panel is on, draw its separator
    if $show_right_panel; then
        cursor_pos=$header_height
        
        if $show_right_panel && $DISPLAY_LINE_CONNECTORS; then
            tput cup $cursor_pos $left_panel_width
            echo "┯"
        fi

        ((cursor_pos++))

        for ((i = 0; i < menu_height; i++)); do
            tput cup $cursor_pos $left_panel_width
            echo "│"
            ((cursor_pos++))
        done
    fi

    cursor_pos=$(($header_height + $menu_height))
    tput cup $cursor_pos 0
    draw_line

    if $show_right_panel && $DISPLAY_LINE_CONNECTORS; then
        tput cup $cursor_pos $left_panel_width
        echo "┷"
    fi

    ((cursor_pos += $(($DESCRIPTOR_HEIGHT + 1))))
    tput cup $cursor_pos 0
    draw_line
    check_for_warnings
    
}

check_for_warnings() {
    warning_position=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT + 2))
    clear_line $warning_position 0 $terminal_width
    clear_line $(($warning_position + 1)) 0 $terminal_width
    msg=""
    if $height_warning || $tabs_dont_fit; then
        menus_label=""
        tabs_label=""
        min_height_msg=""
        min_width_msg=""

        if $height_warning; then
            min_height_msg=" Min. H: "$(($MAX_MENU_ITEMS + 13))" ch."
            menus_label="Menus "
        fi

        if $tabs_dont_fit; then
            min_width_msg=" Min. W: "$all_tabs_length" ch"
            if $height_warning; then
                tabs_label="and tabs "
            else
                tabs_label="Tabs "
            fi
        fi

        msg="$menus_label$tabs_label""won't fit.$min_height_msg$min_width_msg"
        warning_msg=$(truncate_text "$msg" $(($terminal_width-4)))
        tput cup $warning_position 0
        echo -e "\e[01m\e[091m$warning_msg\e[00m"
        ((warning_position++))
        msg=""    
    fi

    if $right_panel_height_warning; then
        msg="Right-panel and cmd-builder disabled. Min. H: $MIN_TERM_HEIGHT_FOR_R_PANEL ch."
    elif $right_panel_width_warning; then
        msg="Right-panel disabled. Min. W: "$(($RIGHT_PANEL_WIDTH * 2))" ch."
    fi

    if [[ -n "$msg" ]]; then
        warning_msg=$(truncate_text "$msg" $(($terminal_width-4)))
        tput cup $warning_position 0
        echo -e "\e[01m\e[091m$warning_msg\e[00m"
    fi

}

truncate_text(){
    text=$1
    max_lenght=$2

    if [[ ${#text} -gt $max_lenght ]]; then
        text="${text:0:$(($max_lenght - 3))}..."
    fi

    echo "$text"
}


# Simply write a one line descriptor, as read from the menu file
write_descriptor() { 
    descriptor_line=$(truncate_text "${menu_desc_entry[$menu_pos]}" $(($terminal_width-4)))
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2
    echo "$descriptor_line"
}

#Simply write a one line descriptor, as read from the menu file
write_help_descriptor() { 
    help_menu_desc_entry[0]="Basic setup and usage guide to Lazy Admin"
    help_menu_desc_entry[1]="In-depth configuration guide"
    help_menu_desc_entry[2]="How to use the command-builder submenu"
    
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    help_descriptor_line=$(truncate_text "${help_menu_desc_entry[$menu_pos]}" $(($terminal_width-4)))

    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2

    if [[ "$active_panel" == "right" ]]; then
        echo "${menu_desc_entry[$menu_pos]}"
    else
        echo "$help_descriptor_line"
    fi
}


# Causes the selector to jump to the "other end" of the menu, if reaching either the top or the bottom
infinite_menu() { 
    if [[ "$active_panel" == "right" ]]; then
        limit=$right_panel_length
    else
        limit=$menu_length
    fi

    if [[ $menu_pos -ge $limit ]]; then
        menu_pos=0
    fi

    if [[ $menu_pos -lt 0 ]]; then
        menu_pos=$(($limit - 1))
    fi
}


infinite_tab() {     
    limit=$(($displayed_tab_entries - 1))

    if [[ $limit -lt $tab_length ]]; then
       ((limit++))
    fi

    if [[ $tab_pos -eq $limit ]]; then
        tab_pos=0
        read_menu_items
        read_descriptor
    fi

    if [[ $tab_pos -lt 0 ]]; then
        tab_pos=$(($limit - 1))
        read_menu_items
        read_descriptor
    fi

}


function_exists() {
    declare -f -F $1 > /dev/null
    return $?
}

###################################
# Movement and menu item handling #
###################################

move_up() {
    #Double jump if run on skip
    if [[ "$active_panel" == "left" ]] && [[ "${menu_entry[$menu_pos - 1]}" == "skip" ]]; then
        ((menu_pos--))
    fi

    #Check for right panel too
    if [[ "$active_panel" == "right" ]] && [[ "${right_panel_entry[$menu_pos - 1]}" == "skip" ]]; then
        ((menu_pos--))
    fi

    ((menu_pos--))
}


move_down() {
    #Double jump if running on skip
    if [[ "$active_panel" == "left" ]] && [[ "${menu_entry[$menu_pos + 1]}" == "skip" ]]; then
        ((menu_pos++))
    fi

    #Chexck for right panel too
    if [[ "$active_panel" == "right" ]] && [[ "${right_panel_entry[$menu_pos + 1]}" == "skip" ]]; then
        ((menu_pos++))
    fi

    ((menu_pos++))
}


tab_left() {
    if ! $submenu && ! $sub_flags_menu && ! $help_submenu; then
        clear_menu
        menu_pos=0
        ((tab_pos--))
    fi
}


tab_right() {
   
    if ! $submenu && ! $sub_flags_menu && ! $help_submenu; then
        clear_menu
        menu_pos=0
        ((tab_pos++))
    fi

}


select_tab() {
    target_tab=$(($1 - 1))
    if [[ $target_tab -lt $displayed_tab_entries ]]; then
        if ! $submenu && ! $sub_flags_menu && ! $help_submenu; then
            if [[ $target_tab -eq 0 || $tab_length -ge $target_tab ]]; then
                clear_menu
                menu_pos=0
                tab_pos=$target_tab
            fi
        fi
    fi
}

# TODO: Add this to help files too
select_tab_by_number() {
    tabkey=""
    read -sN1 -t 1 tabkey

    if [[ -n $tabkey ]]; then 
        if [[ $tabkey -ge 1 ]] && [[ $tabkey -le 9 ]]; then
            select_tab $tabkey
        fi
    fi
}


# "left", "right" or "swap"
change_panel() {
    case $1 in
    "right")
        if $show_right_panel && [[ "$active_panel" == "left" ]]; then
            active_panel="right"
            menu_pos=0
        fi
        ;;
    "left")
        if $show_right_panel && [[ "$active_panel" == "right" ]]; then
            active_panel="left"
            menu_pos=0
        fi
        ;;
    *)
        if $show_right_panel; then
            if [[ "$active_panel" == "right" ]]; then
                active_panel="left"
                menu_pos=0
            else
                active_panel="right"
                menu_pos=0
            fi
        fi
    esac
}

toggle_right_panel() {
    if $right_panel; then
        right_panel=false
    else
        right_panel=true
    fi

    reflow_menu
}



select_menu_item_by_number() {

    key=$1

    # Only read second digit if it makes sense, otherwise avoid the delay
    read_second_digit=false

    if $submenu && [[ $MAX_SUBMENU_ITEMS -gt 9 ]] && [[ $key -le $(($MAX_SUBMENU_ITEMS / 10)) ]]; then
        if ! $help_submenu; then
            read_second_digit=true
        fi
    elif [[ $MAX_MENU_ITEMS -gt 9 ]] && [[ $key -le $(($MAX_MENU_ITEMS/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  

    fi

    is_valid=1

    if [[ $key -le $menu_length ]] && [[ $key -ge 1 ]]; then
        ((key--))
       
        if [[ -z $function_style || $function_style == "old" ]]; then

            if $submenu; then
                subfunct$tab_pos$main_menu_pos$key $tab_pos $menu_pos
            else
                funct$tab_pos$key $tab_pos $menu_pos
            fi

        elif [[ $function_style == "simple" ]]; then

            if $submenu; then
                function_exists tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($key + 1))
                is_valid=$?
                if [[ $is_valid == 0 ]]; then
                    menu_pos=$key
                    tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($key + 1)) $tab_pos $menu_pos
                fi
                
            else
                function_exists tab$(($tab_pos + 1))item$(($key + 1)) && init_menu
                is_valid=$?
                if [[ $is_valid == 0 ]]; then
                    menu_pos=$key
                    tab$(($tab_pos + 1))item$(($key + 1)) $tab_pos $menu_pos
                fi
                
            fi
        fi
    fi
    
    if [[ $is_valid == 0 ]]; then
        init_menu
    fi

}


select_help_menu_item_by_number() {
    key=$1

    if [[ $key -le 3 ]] && [[ $key -ge 0 ]]; then
        ((key--))
        menu_pos=$key
        functhelp$key
    fi
}


select_highlighted_menu_item() {
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else

        if [[ -z $function_style || $function_style == "old" ]]; then

            if $submenu; then
                subfunct$tab_pos$main_menu_pos$menu_pos $tab_pos $menu_pos
            else
                funct$tab_pos$menu_pos $tab_pos $menu_pos
            fi

        elif [[ $function_style == "simple" ]]; then

            if $submenu; then
                tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($menu_pos + 1)) $tab_pos $menu_pos
            else
                tab$(($tab_pos + 1))item$(($menu_pos + 1)) $tab_pos $menu_pos
            fi
        fi
    fi

    init_menu
}


select_highlighted_help_item() {
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else
        functhelp$menu_pos
    fi
    init_menu
}

#########################################
# Command builder specific menu options #
#########################################

set_highlighted_cmb_arg() {
    # If enter is pressed
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else
        max_length_offset=0
        max_cmb_height=$(($MAX_SUBMENU_ITEMS + 2))
        if [[ $# -gt $max_cmb_height ]]; then
            let lenght_diff=$#-$max_cmb_height
            let max_length_offset=$max_length_offset+$lenght_diff
        fi

        let args_to_set=$#-3-$max_length_offset
        
        if [[ $menu_pos -le "$args_to_set" ]] && [[ $menu_pos -ge 0 ]]; then
            #reference parameters by number according to menu_position
            let add_arg=$menu_pos+3
            set_args=$set_args' '${@:$add_arg:1}
        else
            let manual_flags=$args_to_set+1
            let option_flags=$args_to_set+2
            let commit_flags=$args_to_set+3
            let delete_flags=$args_to_set+4

            case $menu_pos in
            $manual_flags)
                cmb_set_manual_args
                ;;
            $option_flags)
                cmb_set_manual_args "nospace"
                ;;
            $commit_flags)
                cmb_commit_with_args
                ;;
            $delete_flags)
                cmb_clear_args
                ;;
            esac
        fi
    fi
}


cmb_set_manual_args() {

    local space=" "
    if [[ "$1" -eq "nospace" ]]; then
        space=""
    fi
    echo
    tput cnorm
    echo "Type your parameters here, and press <Enter>"
    read -p "> " line_args
    set_args=$set_args$space$line_args
    tput civis
    clear
    draw_menu

}


cmb_commit_with_args() {
    clear
    echo
    echo "Executing:"
    echo "$submenu_command $set_args"
    echo
    $submenu_command $set_args
    echo
    echo "Now press a key to get back to the menu"
    read -n 1 -s key_press
    sub_flags_menu=false
    back_to_main_menu
}

cmb_clear_args() {
    set_args=''
    clear
    draw_menu
}

cmb_set_arg_by_number() {
    # echo "All arts passed are: $@"
    key=${!#}

    # echo "Key set to: $key"
    # set -- "${@:1:$#-1}"
    read_second_digit=false
    if [[ $MAX_COMMAND_BUILDER_ARGS -gt 9 ]] && [[ $key -le $(($MAX_COMMAND_BUILDER_ARGS/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi
    
    let args_to_set=$#-4
    if [[ $key -le $(($args_to_set + 1)) ]] && [[ $key -ge 0 ]]; then
        ((key += 2))
        set_args=$set_args' '${!key}
    fi
}

# Credit for the previous picking solution (first 5 lines) goes for eMPee584's 
# answer on the thread below:
# http://stackoverflow.com/questions/10679188/casing-arrow-keys-in-bash
#
# It allowed to read both arrow keys and single characters from a keyboard just 
# fine, but has since been replaced.
#
# Credit now goes to:
# https://stackoverflow.com/a/66500309/6078214
#
# This is the simplest way I have fund yet to read all sorts of special keys

pick_menu_item() { 
    
    while true; do
        
        key=""
        keytap=""
        if $AUTO_REFLOW; then
            check_for_size_changes
            size_changed=$?
            if [[ $size_changed -gt 0 ]]; then
                break
            fi

            read -rsN1 -t $tick keytap
        else
            read -rsN1 keytap
        fi
        
        # loop while read can read any additional character and join all of them ## Original comment, left unchanged
        while [ -n "$keytap" ]; 
        do
            key="${key}${keytap}"
            read -sN1 -t 0.0001 keytap
        done

        if [[ -n $key ]]; then 
            # TODO: Update User guide and key binding guide with F1-9 and t-# keys for tabs access and TAB key for changing panels
            case $key in
            $'\e[A' | $'\e0A' | "w")
                move_up
                ;;
            $'\e[B' | $'\e0B' | "s")
                move_down
                ;;
            $'\e[D' | $'\e0D' | "a")
                tab_left
                ;;
            $'\e[C' | $'\e0C' | "d")
                tab_right
                ;;
            $'\e[11~' | $'\eOP') 
                # F1 - Tab 1
                select_tab 1
                ;;
            $'\e[12~' | $'\eOQ')
                # F2 - Tab 2
                select_tab 2
                ;;
            $'\e[13~' | $'\eOR')
                # F3 - Tab 3
                select_tab 3
                ;;
            $'\e[14~' | $'\eOS') 
                # F4 - Tab 4
                select_tab 4
                ;;
            $'\e[15~')
                # F5 - Tab 5
                select_tab 5
                ;;
            $'\e[17~')
                # F6 - Tab 6
                select_tab 6
                ;;
            $'\e[18~')
                # F7 - Tab 7
                select_tab 7
                ;;
            $'\e[19~') 
                # F8 - Tab 8
                select_tab 8
                ;;
            $'\e[20~')
                # F9 - Tab 9
                select_tab 9
                ;;
            "t")
                select_tab_by_number
                ;;
            "R")
                toggle_right_panel
                ;;
            $'\e[1;5C' | $'\e01;5C' | "r")
                change_panel "right"
                ;;
            $'\e[1;5D' | $'\e01;5D' | "l")
                change_panel "left"
                ;;
            $'\x09')
                change_panel "swap"
                ;;
            [1-9])
                if $sub_flags_menu; then
                    cmb_set_arg_by_number "$@" $key
                elif $help_submenu; then
                    select_help_menu_item_by_number $key
                else
                    select_menu_item_by_number $key
                fi
                ;;
            $'\x0a' | '')
                # If enter is pressed
                if $sub_flags_menu; then
                    set_highlighted_cmb_arg "$@"
                elif $help_submenu; then
                    select_highlighted_help_item
                else
                    select_highlighted_menu_item
                fi
                ;;
            "f") 
                reflow_menu
                ;;
            "h")
                if ! $help_submenu; then
                    display_help
                fi
                ;;
            "k")
                display_hotkeys
                ;;
            "q") #this handles exit function
                functright4
                ;;
            "b")
                if $help_submenu; then
                    back_to_main_menu "read" "reflow"
                elif $submenu || $sub_flags_menu; then
                    back_to_main_menu
                fi

                return
                ;;
            "e")
                if ! $submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup0
                    init_menu
                fi
                ;;
            "u")
                if ! $submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup1
                    init_menu
                fi
                ;;
            "v")
                if ! $submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup3
                    init_menu
                fi
                ;;
            "m")
                if $sub_flags_menu; then
                    cmb_set_manual_args
                elif ! $submenu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup2
                    init_menu
                fi
                ;;
            "o")
                if $sub_flags_menu; then
                    cmb_set_manual_args "nospace"
                fi
                ;;
            "c")
                if $sub_flags_menu; then
                    cmb_commit_with_args
                fi
                ;;
            "x")
                if $sub_flags_menu; then
                    cmb_clear_args
                fi
                ;;
        
            esac
            
            break

        elif ! $AUTO_REFLOW; then
            break
        fi
    done
}



# This fnction will
# construct a submenu from the supplied arguments, from which
# the user can interactively build a command
#
# Arguments to supply:
# $1 - Title for the submenu
# $2 - base command to start the chain with. It can already contain preset arguments
# $3 - $11 - arguments to be represented as one of the possible 9 menu items.
#
# The arguments can contain more than one options, if supplied in quotes,
# it will be treated as a sibngle menu entry, such as passing e.g.
#
# "-c 5 --whatever_flag -f 8" as $4,
#
# will make
#
# -c 5 --whatever_flag -f 8
#
# the second menu entry. Selecting it will apply all the flags to the built chain

# TODO: Descriptor is pointless here. Instad, move the active command up in that spot
# TODO: Fix resizing this menu correctly. Size should be dynamic and it shoudl always expand to the maximum extent of the menu or the ternminal, whichever comes first
# TODO the visual truncation warning should also appear here on the bottom line
# ToDo: MOVE THE FIXED ITEMS INTO THE RIGHT PANEL!!!!!!!!! OH YEAH!!!

command_builder_function() { 
    menu_entry=()
    set_args=""

    if $submenu; then
        remain_in_submenu=true
        old_submenu_title="$submenu_title"
        old_tab_pos=$tab_pos
        old_main_menu_pos=$main_menu_pos
    else
        remain_in_submenu=false
    fi

    submenu=true
    sub_flags_menu=true
    sub_flags_menutitle="$1"
    submenu_command="$2"
    submenu_call="${@:3}"
    menu_pos=0

    #Have to empty the arguments each time, as set_submenu_function is not an "object", but just a single instance of a function.
    #Best avoid confusion
    clear
    set_command_builder_items "$@"
    # read_rightpanel_items
    draw_menu

    while $sub_flags_menu; do
        set_command_builder_items "$@"
        # read_rightpanel_items
        infinite_menu
        write_menu_items

        if $show_right_panel; then
            write_rightpanel_items
        fi

        
        tput cup $(($header_height + $menu_height + $DESCRIPTOR_HEIGHT)) 2
        
        # ~~TODO~~: Got to make sure this does not go ovber the screen limit. 
        # 7 years leter: No, that's the user's problem, terminal emulators can be resized
        # 1 Week later: Nah, I got it.

        cmd_msg="Active command: $submenu_command $set_args"
        cmd_msg=$(truncate_text "$cmd_msg" $(($terminal_width-2)))
        echo "$cmd_msg"

        pick_menu_item "$@"

    done

}


#Right panel functions
#this is the standard reflow function

reflow_menu() { 
    clear
    set_menu_sizes
    if ! menus_force_hidden; then
        init_menu
    fi
}


display_hotkeys() { 
    display_markdown_help "$RES_DIR/shortkeys.md" "$RES_DIR/shortkeys.txt"
    reflow_menu
}


# Calls the papproropriate help function, either the help submenu
# or the single help file, depending on where the user is
display_help() { 
    if $sub_flags_menu; then
        functhelp_commanbuilder
        reflow_menu
    else
        enter_helpmenu
    fi
}


# Quits Lazy Admin, and restores the cursor, but only if
# not returning from a nested root shell
# (It is possible to run another shell of ladmin form within)
exit_la_menus() { 
    tput cnorm
    clear
    clear
    echo
    echo "$@"
    echo
    exit 0
}


# Misleading function name (TODO:change it)
# It will return to the calling menu, which can be a submenu in case of
# help menu or command builder
back_to_main_menu() { 
    active_panel="left"
    menu_pos=0
    sub_flags_menu=false
    help_submenu=false

    if $remain_in_submenu; then
        submenu=true
        remain_in_submenu=false
        submenu_title="$old_submenu_title"
        tab_pos=$old_tab_pos
        main_menu_pos=$old_main_menu_pos
    else
        submenu=false
    fi

    if [[ $1 == "read" ]]; then
        read_menu_items
        read_descriptor
    fi

    # read_rightpanel_items
    clear_menu

    if [[ $2 == "reflow" ]]; then
        reflow_menu
    fi

    return
}


# (Re)draws items of main menu and includes the picker
main_menu() { 
    
    submenu=false
    sub_flags_menu=false
    if ! $menus_force_hidden; then
        read_tab_items
        read_menu_items
        read_descriptor
        infinite_menu
        infinite_tab
        write_tab_items
        write_menu_items

        if $show_right_panel; then
            write_rightpanel_items
        fi

        #Write basic description
        write_descriptor
    fi
    pick_menu_item
}


# Same as main menu, only this one invokes a submenu.
# decide menu type
submenu() { 
    if ! $menus_force_hidden; then
        if [[ $1 != "help" ]]; then
            submenu=true
        fi
    
        sub_flags_menu=false

        if [[ $1 != "help" ]]; then
            read_tab_items
            read_menu_items $1 $2
        fi
        
        read_descriptor $1 $2
        infinite_menu

        if [[ $1 != "help" ]]; then
            write_menu_items
        else
            write_help_menu_items
        fi

        if $show_right_panel; then

            if [[ $1 == "help" ]]; then
                read_help_rightpanel_items
            fi

            write_rightpanel_items
        fi

        if [[ $1 != "help" ]]; then
            write_descriptor
        else
            write_help_descriptor
        fi
    fi
    pick_menu_item
}




# Initialise a menu, before drawing for the foirst timed
# Will set menu item and title variable
init_menu() {     
    if [[ "$(whoami)" != "root" ]]; then
        root=false
    else
        root=true
    fi

    clear
    if [[ $1 != "help" ]]; then
        find_menu_type
        read_menu_items $1 $2
    fi
    read_descriptor $2 $2
    
    read_rightpanel_items
    
    draw_menu
}



# This will be called whrn a submenu is selected
enter_submenu() { 
    remain_in_submenu=false
    submenu=true
    submenu_title="$3"
    main_menu_pos="$menu_pos"
    menu_pos=0

    init_menu $1 $2

    while $submenu; do
        submenu $1 $2
    done
}


# This will be called when help menu is selected
enter_helpmenu() { 
    help_submenu=true

    if $submenu; then
        remain_in_submenu=true
        old_submenu_title="$submenu_title"
        old_tab_pos=$tab_pos
        old_main_menu_pos=$main_menu_pos
    else
        remain_in_submenu=false
    fi

    submenu=true
    submenu_title="Help"
    main_menu_pos="$menu_pos"
    menu_pos=0

    init_menu "help"

    while $help_submenu; do
        submenu "help"
    done
}


# Right panel functions. These function aliases are core functionality,
# so not really a part of the user aliases. This coudl change later
# so that users can easily alter right panel
function functright0 { 
    reflow_menu
}


function functright1 { 
    display_help
}


function functright2 { 
    display_hotkeys
}


function functright3 { 
    if [[ $sub_flags_menu ]]; then
        sub_flags_menu=false
    fi

    back_to_main_menu "read"
}


function functright4 { 
    if $root; then
        exit_la_menus "Leaving root shell"
    else
        exit_la_menus "Exiting..."
    fi
}


# Initialises and displays the main menu
# This is what the launcher calls, basically
main() { 
    for ((i = 1; i <= $#; i++)); do
        j=$((i + 1))

        # This can be extended with any number of arguments later, possibly to change defaults on the fly
        case "${!i}" in
        "-j" | "--join-lines")
            if [[ "${!j}" == "off" ]]; then
                DISPLAY_LINE_CONNECTORS=false
            elif [[ "${!j}" == "on" ]]; then
                DISPLAY_LINE_CONNECTORS=true
            fi
            ;;
        *)
            #Do nothing
            ;;
        esac
    done

    if ! menus_force_hidden; then
        init_menu
    fi

    while true; do

        main_menu
    done
}

set_up_menus