#!/bin/bash
#
# Copyright Â© 2017-2025, Attila Orosz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# This file fontains the functions providing basic functionality of the menu system
# Non-essential functions are in $INSTALL-DIR/plugins/extra-functions
# Custom "user functions" will be stored in $USER-DIR/user-function.la

# TODO: Editing setup files doies not seem to work in installed version


declare _SAVED_STTY_SETTINGS # Only used if stty is installed and used
declare GOT_STTY=false # Becomes true if stty was found on the system
declare MENUS_FORCE_HIDDEN=false # In case there is not enough room for bassic stuff
declare CMB_FORCE_HIDDEN=false #In case there is nto enoughroom for basic cmb stuff
declare TABS_DONT_FIT=false # In case there are more tabs than width allows
declare -i ALL_TABS_LENTH=0 # Size of the tab bar
declare RIGHT_PANEL_HEIGHT_WARNING=false #
declare RIGHT_PANEL_WIDTH_WARNING=false
declare HEIGHT_WARNING=false
declare -i NORMAL_MENU_HEIGHT=0
declare -i MENU_HEIGHT=0
declare -i TERMINAL_HEIGHT
declare -i TERMINAL_WIDTH

declare CMB_COMMAND=""
declare CMB_ARGS=""

declare SHOW_RIGHT_PANEL=$RIGHT_PANEL # Necessary, because it might get temporarilty disabkled when resizing windows
declare -i MAX_MENU_HEIGHT=0

declare -i HEADER_HEIGHT
declare -i FOOTER_HEIGHT

declare REMAIN_IN_SUBMENU=false
declare IS_SETUP_TAB=false
declare -i MENU_ITEMS_COUNT=0
declare -i MIN_TERMINAL_HEIGHT=$BASE_TERMINAL_HEIGHT

declare -a TAB_ITEM_ROWS
declare -a TAB_ITEM_KEYS
declare -a TAB_ITEM_ENTRIES

declare -a MENU_ITEM_ROWS
declare -a SYSTEM_MENU_ITEM_ROWS

declare -a MENU_ITEM_ENTRIES
declare -a MENU_ITEM_DESCRIPTIONS
declare -a MENU_ITEM_COMMANDS

declare -a RIGHT_PANEL_ITEM_ROWS
declare -a RIGHT_PANEL_ITEM_KEYS
declare -a RIGHT_PANEL_ITEM_ENTRIES
declare -a RIGHT_PANEL_ITEM_DESCRIPTIONS

declare -i NUMBER_OF_TABS
declare -i MENU_LENGTH
declare -i DISPLAYED_TAB_ENTRIES

declare SUBMENU_TITLE=""
declare OLD_SUBMENU_TITLE=""
declare -i OLD_TAB_POS=0
declare -i OLD_MAIN_MENU_POS=0
declare -i MAIN_MENU_POS=0

declare -i CURSOR_POS=0

declare -i MAX_MENU_LENGTH=0
declare -i MENU_WIDTH=0
declare -i LEFT_PANEL_WIDTH=0
declare -i ACTIVE_RIGHT_PANEL_WIDTH=0


declare IS_SUBMENU=false
declare IS_SUB_FLAGS_MENU=false
declare IS_HELP_SUBMENU=false

declare IS_ROOT=false

# Either set things up, or exit if we have no menu file
set_up_menus() {
 
    if [[ -f $MENU_FILE ]]; then
        echo "Setting menus..."
        parse_system_menu_file
        parse_menu_file
        read_tab_items
        set_menu_sizes     
    else
        clear
        echo
        echo "Looked for menus in:"
        echo $MENU_FILE
        echo
        echo "Error: Cannot find menuentries file in default location. Exiting..."
        echo
        exit 65
    fi
}

# Initialise a menu, before drawing for the first time, or after reflowing
# Will set menu item and title variable
init_menu() {     
    if [[ "$(whoami)" != "root" ]]; then
        IS_ROOT=false
    else
        IS_ROOT=true
    fi

    clear
    
    if [[ $1 != "help" ]]; then
        if [[ $1 != "reflow" ]]; then
            if $IS_SUBMENU; then
                read_submenu_items "${TAB_ITEM_KEYS[$TAB_POS]}" $MAIN_MENU_POS
            else
                read_menu_items
            fi
        fi
    fi

    read_rightpanel_items
    draw_menu

    if ! $MENUS_FORCE_HIDDEN; then
        if $IS_SUBMENU; then
            write_submenu_title
        else
            write_tab_items
        fi
        write_menu_items

        if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL; then
            write_rightpanel_items
        fi
    fi
}


#########################################
# Size checks and setting things' sizes #
#########################################

set_menu_sizes() {
    TERMINAL_HEIGHT=$(t_put lines)
    TERMINAL_WIDTH=$(t_put cols)
    MIN_TERMINAL_HEIGHT=$BASE_TERMINAL_HEIGHT
    MIN_TERM_HEIGHT_FOR_R_PANEL=$(($MIN_TERMINAL_HEIGHT+1))
    MENU_WIDTH=$(($(t_put cols) - 1))
   
    if [[ $MIN_TERM_HEIGHT_FOR_R_PANEL < 13 ]]; then
        MIN_TERM_HEIGHT_FOR_R_PANEL=13
    fi

    if $SHOW_HEADER; then
        ((MIN_TERMINAL_HEIGHT+=2))
        ((MIN_TERM_HEIGHT_FOR_R_PANEL+=2))
        HEADER_HEIGHT=5
    else
        HEADER_HEIGHT=3
    fi

    if $SHOW_FOOTER || $IS_SUB_FLAGS_MENU; then

        ((MIN_TERMINAL_HEIGHT+=2))

        if $IS_SUB_FLAGS_MENU; then
            ((MIN_TERM_HEIGHT_FOR_R_PANEL+=1))
        else
            ((MIN_TERM_HEIGHT_FOR_R_PANEL+=2))
        fi
        
        FOOTER_HEIGHT=2
    else
        FOOTER_HEIGHT=1
    fi

    MIN_TERM_H_FOR_R_PANEL_CMB=$(($MIN_TERM_HEIGHT_FOR_R_PANEL+8))

    if [[ $TERMINAL_HEIGHT -lt $MIN_TERMINAL_HEIGHT ]] || [[ $TERMINAL_WIDTH -lt $MIN_TERMINAL_WIDTH ]]; then
        MENUS_FORCE_HIDDEN=true
        show_force_hide_error
    else
        MENUS_FORCE_HIDDEN=false
        CMB_FORCE_HIDDEN=false
        RIGHT_PANEL_HEIGHT_WARNING=false
        RIGHT_PANEL_WIDTH_WARNING=false
        HEIGHT_WARNING=false
        MAX_MENU_HEIGHT=$(($TERMINAL_HEIGHT - 3 - $HEADER_HEIGHT - $FOOTER_HEIGHT))

        if [[ $MAX_MENU_ITEMS > 0 ]]; then
            NORMAL_MENU_HEIGHT=$(( $MAX_MENU_ITEMS + 3 ))
        else
            NORMAL_MENU_HEIGHT=$MAX_MENU_HEIGHT
        fi

        MENU_HEIGHT=0
        SHOW_RIGHT_PANEL=$RIGHT_PANEL

        if [[ $TERMINAL_HEIGHT -lt $MIN_TERM_HEIGHT_FOR_R_PANEL ]]; then
            SHOW_RIGHT_PANEL=false

            if $RIGHT_PANEL; then
                RIGHT_PANEL_HEIGHT_WARNING=true
            fi
        fi

        if [[ $TERMINAL_WIDTH -lt $(($RIGHT_PANEL_WIDTH * 2)) ]]; then
            SHOW_RIGHT_PANEL=false

            if $RIGHT_PANEL; then
                RIGHT_PANEL_WIDTH_WARNING=true
            fi
        fi

        if $RIGHT_PANEL_WIDTH_WARNING || $RIGHT_PANEL_HEIGHT_WARNING; then
            CMB_FORCE_HIDDEN=true
        fi

        if ! $SHOW_RIGHT_PANEL $$ [[ $ACTIVE_PANEL -eq "right" ]]; then
            ACTIVE_PANEL="left"
        fi
  
        # Got to make sure we fit inside whatever size the terminal currently is
        if [[ $NORMAL_MENU_HEIGHT -gt $MAX_MENU_HEIGHT ]]; then
            NORMAL_MENU_HEIGHT=$MAX_MENU_HEIGHT
            HEIGHT_WARNING=true
        else
            HEIGHT_WARNING=false
        fi

        if [[ $NORMAL_MENU_HEIGHT -lt $MIN_MENU_HEIGHT ]]; then
            NORMAL_MENU_HEIGHT=$MIN_MENU_HEIGHT
        fi

        if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL; then
            ACTIVE_RIGHT_PANEL_WIDTH=$RIGHT_PANEL_WIDTH
        else
            ACTIVE_RIGHT_PANEL_WIDTH=0
        fi
        
        LEFT_PANEL_WIDTH=$(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH))
        MENU_HEIGHT=$NORMAL_MENU_HEIGHT
    fi

}

# In case auto-reflow is enabled (default: on), this check will
# be performed periodically (determined by the tick rate)
check_for_size_changes() {
    (:) # try to force updating environmental variables

    local current_height=$(t_put lines)
    local current_width=$(t_put cols)

    if [[ $TERMINAL_HEIGHT -ne $current_height ]] || [[ $TERMINAL_WIDTH -ne $current_width ]]; then
        reflow_menu
        return 1
    fi

    return 0
}


show_force_hide_error() {
    clear
    echo
    echo -n "Cannot display menus on this terminal. If you are in an emulator, you need to resize the window"
   
    if ! $AUTO_REFLOW; then
        echo -n ", and press 'f' to re-draw the menu; "
    else
        echo -n "; "
    fi
    
    echo -n "or press 'q' to quit."
    echo -e '\n'

    if [[ $TERMINAL_HEIGHT -le $MIN_TERMINAL_HEIGHT ]]; then
        echo "Minimum supported height: $MIN_TERMINAL_HEIGHT characters."
        echo -e "Current height: \e[01m\e[091m$TERMINAL_HEIGHT\e[00m characters"
        echo
    fi

    if [[ $TERMINAL_WIDTH -lt $MIN_TERMINAL_WIDTH ]]; then
        echo "Minimum supported width: $MIN_TERMINAL_WIDTH characters."
        echo -e "Current width: \e[01m\e[091m$TERMINAL_WIDTH\e[00m characters"
        echo
    fi
}



###########################################
# Parsing files and reading menu contents #
###########################################

parse_menu_file() {
    local -a menu_file_contents
    local line
        
    OLD_IFS=$IFS
    IFS=
    
    while read -r line; do
        if [[ ! "$line" == "#"* ]] && [[ -n "$line" ]]; then
            menu_file_contents+=("$line")
        fi
    done < "$MENU_FILE"

    IFS=$OLD_IFS

    local tab_items_toggle=false
    local menu_items_toggle=false
      
    for ((n = 0; n <= ${#menu_file_contents[@]}; n++)); do

        if $tab_items_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_tab_order:]" ]]; then
                tab_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                TAB_ITEM_ROWS+=("$tmp")
                unset tmp                
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:tab_order:]" ]]; then
                tab_items_toggle=true
            fi
        fi

        if $menu_items_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_menu_items:]" ]]; then
                menu_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                MENU_ITEM_ROWS+=("$tmp")
                unset tmp
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:menu_items:]" ]]; then
                menu_items_toggle=true
            fi
        fi
    done
}

parse_system_menu_file() {

    local -a menu_file_contents
    local line

    OLD_IFS=$IFS
    IFS=
    
    while read -r line; do
        if [[ ! "$line" == "#"* ]] && [[ -n "$line" ]]; then
            menu_file_contents+=("$line")
        fi
    done < "$SYSTEM_MENU_FILE"

    IFS=$OLD_IFS
  
    local menu_items_toggle=false
    local right_menus_toggle=false
      
    for ((n = 0; n <= ${#menu_file_contents[@]}; n++)); do

        if $menu_items_toggle; then

            if [[ "${menu_file_contents[$n]}" == "[:end_special_menu_items:]" ]]; then
                menu_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                SYSTEM_MENU_ITEM_ROWS+=("$tmp")
                unset tmp
            fi
            
        else
            if [[ "${menu_file_contents[$n]}" == "[:special_menu_items:]" ]]; then
                menu_items_toggle=true
            fi
        fi

        if $right_menus_toggle; then

            if [[ "${menu_file_contents[$n]}" == "[:end_right_panel_items:]" ]]; then
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                RIGHT_PANEL_ITEM_ROWS+=("$tmp")
                unset tmp
            fi

        else
            if [[ "${menu_file_contents[$n]}" == "[:right_panel_items:]" ]]; then
                right_menus_toggle=true
            fi
        fi
    done
}


# Load the items shown in the tab
read_tab_items() {
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"

    TAB_ITEM_KEYS=()
    TAB_ITEM_ENTRIES=()

    for ((n = 0; n < "${#TAB_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${TAB_ITEM_ROWS[$n]}"

        local key="${current_row[0]}"
        key="${key#"${key%%[![:space:]]*}"}"  # Remove leading whitespace
        key="${key%"${key##*[![:space:]]}"}"  # Remove trailing whitespace

        local title="${current_row[1]}"
        title="${title#"${title%%[![:space:]]*}"}"  # Remove leading whitespace
        title="${title%"${title##*[![:space:]]}"}"  # Remove trailing whitespace

        TAB_ITEM_KEYS+=("$key")
        TAB_ITEM_ENTRIES+=("$title")
    done

    IFS="$OLD_IFS"
    NUMBER_OF_TABS=$((${#TAB_ITEM_ENTRIES[@]} - 1))

    # No more than 9 tabs for now, for shortkey reasons (F1 to f9, or t-1 to t-9)
    if [[ $NUMBER_OF_TABS -gt 8 ]]; then

        for ((i = 9; i < $NUMBER_OF_TABS + 1; i++)); do
            unset "TAB_ITEM_KEYS[$i]"
            unset "TAB_ITEM_ENTRIES[$i]"
        done

        NUMBER_OF_TABS=8
    fi

}

read_submenu_items(){

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=1

    MENU_ITEM_ENTRIES=()
    MENU_ITEM_DESCRIPTIONS=()
    MENU_ITEM_COMMANDS=()
    MENU_ITEMS_COUNT=0

    local tab_key="$1"
    local submenu_position=$2
    local submenu_toggle=false

    local -i main_idx=0
    local -i sub_idx=1

    # for ((n = 0; n < "${#MENU_ITEM_ROWS[@]}"; n++)); do
    for item_row in "${MENU_ITEM_ROWS[@]}"; do
        local -a current_row
        read -ra current_row <<< "$item_row" #"${MENU_ITEM_ROWS[$n]}"
 
        local sub_key="${current_row[0]}"
        sub_key="${sub_key#"${sub_key%%[![:space:]]*}"}"  # Remove leading whitespace
        sub_key="${sub_key%"${sub_key##*[![:space:]]}"}"  # Remove trailing whitespace

        if $submenu_toggle; then

            if [[ "$sub_key" == "--" ]]; then
                add_row_to_menu_items $sub_idx "${current_row[@]}"
                
                if [[ $? == 0 ]]; then
                    ((sub_idx++))
                fi
                
            else
                break
            fi

        elif [[ "$sub_key" == "$tab_key" ]]; then

            if [[ $main_idx == $submenu_position ]];then
                submenu_toggle=true
            else
                ((main_idx++))
            fi        

        fi

    done

    IFS="OLD_IFS"
    MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}
 
}


read_menu_items() {
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=1
    local -l system_menu_type=""

    if [[ -n "$1" ]]; then
        system_menu_type="$1"
    fi

    MENU_ITEM_ENTRIES=()
    MENU_ITEM_DESCRIPTIONS=()
    MENU_ITEM_COMMANDS=()
    MENU_ITEMS_COUNT=0

    if [[ -n $system_menu_type ]]; then
        for ((n = 0; n < "${#SYSTEM_MENU_ITEM_ROWS[@]}"; n++)); do
            local -a current_row
            read -ra current_row <<< "${SYSTEM_MENU_ITEM_ROWS[$n]}"

            local -l tab_key="${current_row[0]}"
            tab_key="${tab_key#"${tab_key%%[![:space:]]*}"}"  # Remove leading whitespace
            tab_key="${tab_key%"${tab_key##*[![:space:]]}"}"  # Remove trailing whitespace
            
            if [[ $tab_key == $system_menu_type ]]; then
                add_row_to_menu_items $idx $system_menu_type "${current_row[@]}" 

                if [[ $? == 0 ]]; then
                    ((idx++))
                fi

            fi 
        done
    else
        for ((n = 0; n < "${#MENU_ITEM_ROWS[@]}"; n++)); do
            local -a current_row
            read -ra current_row <<< "${MENU_ITEM_ROWS[$n]}"

            local tab_key="${current_row[0]}"
            tab_key="${tab_key#"${tab_key%%[![:space:]]*}"}"  # Remove leading whitespace
            tab_key="${tab_key%"${tab_key##*[![:space:]]}"}"  # Remove trailing whitespace
            
            if [[ $tab_key == "${TAB_ITEM_KEYS[$TAB_POS]}" ]] || [[ $tab_key == "${TAB_ITEM_ENTRIES[$TAB_POS]}" ]]; then
                add_row_to_menu_items $idx "${current_row[@]}"

                if [[ $? == 0 ]]; then
                    ((idx++))
                fi

            fi 
        done
    fi

    IFS="$OLD_IFS"
    MENU_HEIGHT=$NORMAL_MENU_HEIGHT
    MAX_MENU_LENGTH=$(($NORMAL_MENU_HEIGHT - 3))
    MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}

}


add_row_to_menu_items() {
    local -i idx=$1
    shift
    local system_function=""
    if [[ $1 == "setup" ]] || [[ $1 == "help" ]]; then
        system_function=$1
        shift
    fi

    local -a curent_row="$@"
    local menu_item="${current_row[1]}"

    menu_item="${menu_item#"${menu_item%%[![:space:]]*}"}"
    menu_item="${menu_item%"${menu_item##*[![:space:]]}"}"

    local description="${current_row[2]}"
    description="${description#"${description%%[![:space:]]*}"}"
    description="${description%"${description##*[![:space:]]}"}"

    local command="${current_row[3]}"
    command="${command#"${command%%[![:space:]]*}"}"
    command="${command%"${command##*[![:space:]]}"}"
    
    if [[ -z $menu_item ]]; then
        menu_item=skip
    fi

    if [[ $menu_item == "skip" ]] || [[ $menu_item == "---" ]] || [[ $menu_item == "[inline-label]" ]]; then
       
        MENU_ITEM_ENTRIES+=("$menu_item")

        if [[ $menu_item == "[inline-label]" ]]; then
             MENU_ITEM_DESCRIPTIONS+=("$description")
        else
            MENU_ITEM_DESCRIPTIONS+=("")
        fi

        MENU_ITEM_COMMANDS+=("")
       
        return 1
        
    else
        if [[ -z "$description" ]] && [[ -z "$command" ]]; then
            MENU_ITEM_ENTRIES+=("[inline-label]")
            MENU_ITEM_DESCRIPTIONS+=("$menu_item")
            MENU_ITEM_COMMANDS+=("")

            return 1
        else
            MENU_ITEM_ENTRIES+=("$idx - $menu_item")
            MENU_ITEM_DESCRIPTIONS+=("$description")

            if [[ -n $system_function ]]; then
                MENU_ITEM_COMMANDS+=("funct$system_function$idx")
            else
                MENU_ITEM_COMMANDS+=("$command")
            fi

            ((MENU_ITEMS_COUNT++))

            return 0
        fi
         
    fi    

}


read_rightpanel_items() {    
    local menu_type_key

    if $IS_SUB_FLAGS_MENU; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi    

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"

    RIGHT_PANEL_ITEM_KEYS=()
    RIGHT_PANEL_ITEM_ENTRIES=()
    RIGHT_PANEL_ITEM_DESCRIPTIONS=()
    
    for ((n = 0; n < "${#RIGHT_PANEL_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${RIGHT_PANEL_ITEM_ROWS[$n]}"

        local menu_type="${current_row[0]}"
        menu_type="${menu_type#"${menu_type%%[![:space:]]*}"}"  # Remove leading whitespace
        menu_type="${menu_type%"${menu_type##*[![:space:]]}"}"  # Remove trailing whitespace
       
        local shortkey="${current_row[1]}"
        shortkey="${shortkey#"${shortkey%%[![:space:]]*}"}"
        shortkey="${shortkey%"${shortkey##*[![:space:]]}"}"
       
        local menu_item="${current_row[2]}"
        menu_item="${menu_item#"${menu_item%%[![:space:]]*}"}"
        menu_item="${menu_item%"${menu_item##*[![:space:]]}"}"
       
        local description="${current_row[3]}"
        description="${description#"${description%%[![:space:]]*}"}"
        description="${description%"${description##*[![:space:]]}"}"

        local ignore_item=false

        if [[ -z $shortkey ]]; then
            shortkey="skip"
        fi
    
        if  [[ "$menu_type" == "$menu_type_key" ]]; then  
           
            if [[ "$shortkey" == "o" ]]; then
                if $IS_SUBMENU; then
                    ignore_item=true
                fi
            elif [[ "$shortkey" == "b" ]]; then
                if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU; then
                    ignore_item=true
                fi
            elif [[ "$shortkey" == "h" ]] && $IS_HELP_SUBMENU; then
                shortkey="skip"
            fi

            if ! $ignore_item; then
                RIGHT_PANEL_ITEM_KEYS+=("$shortkey")

                if [[ "$shortkey" != "skip" ]]; then
                    RIGHT_PANEL_ITEM_ENTRIES+=("$shortkey - $menu_item")
                    RIGHT_PANEL_ITEM_DESCRIPTIONS+=("$description")
                else
                    RIGHT_PANEL_ITEM_ENTRIES+=("")
                    RIGHT_PANEL_ITEM_DESCRIPTIONS+=("")
                fi
            fi
        fi
    done

    IFS=$OLD_IFS
}


#####################################
# Writing all sorts of items (text) #
#####################################

#Display the menu tabs
write_tab_items() {  
    TABS_DONT_FIT=false
    local current_tabs_length=0
    DISPLAYED_TAB_ENTRIES=1
    local just_toggled_setup_off=false

    ALL_TABS_LENTH=0
    local -i connector_offset=2
 
    for ((n = 0; n <= $NUMBER_OF_TABS; n++)); do
        ALL_TABS_LENTH=$(($ALL_TABS_LENTH + ${#TAB_ITEM_ENTRIES[$n]} + 3))
    done

    ((ALL_TABS_LENTH++))

    # Make sure tabs will fit
    for ((n = 0; n <= $NUMBER_OF_TABS; n++)); do
        current_tabs_length=$(($current_tabs_length + ${#TAB_ITEM_ENTRIES[$n]} + 3))

        if [[ $current_tabs_length -ge $TERMINAL_WIDTH ]]; then
            TABS_DONT_FIT=true
            ((DISPLAYED_TAB_ENTRIES--))

             if [[ $TAB_POS -ge $DISPLAYED_TAB_ENTRIES ]]; then
                select_tab $DISPLAYED_TAB_ENTRIES
            fi

            break
        fi

        ((DISPLAYED_TAB_ENTRIES++))

    done

    # Not entirely sure why, but we need this only when all tabs are displayed
    # When some ar cut off, it should be zero. Apparntly. This is like black magic 
    # for now, because I'm lazy / too busy to properly look at what's happening, and
    # this seemed like a kwikk fiks
    
    if $TABS_DONT_FIT; then
        connector_offset=0
    fi

    local horizontal_connector_position=0
    # Display joints if on, but not for the last item
    if $DISPLAY_LINE_CONNECTORS; then
      
        # need to clear any lefrtovers inn case of resizing
        draw_line $((HEADER_HEIGHT - 3)) 0
        
        for ((n = 0; n < $(($DISPLAYED_TAB_ENTRIES - $connector_offset)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#TAB_ITEM_ENTRIES[$n]} + 3))
            t_put cup $((HEADER_HEIGHT - 3)) $horizontal_connector_position
            echo -n "â¯"
        done

    fi

    # Then write out the tab items, with separators
    clear_line $((HEADER_HEIGHT - 2)) 1 "right"
    t_put cup $((HEADER_HEIGHT - 2)) 1
    
    for ((n = 0; n < $DISPLAYED_TAB_ENTRIES; n++)); do
       
        if [[ $n -eq $TAB_POS ]]; then
            echo -n -e "\e[00;30;47m ${TAB_ITEM_ENTRIES[$n]} \e[00m"
        else
            echo -n " ${TAB_ITEM_ENTRIES[$n]} "
        fi

        # Do not write separator after last item
        if [[ $n -lt $NUMBER_OF_TABS ]]; then
            echo -n "â"
        fi       
    
    done 

    if $DISPLAY_LINE_CONNECTORS; then
        # Then draw connectors ont he bottom line, but not for the last item
        local rp_connector_drawn=false
        horizontal_connector_position=0

        # Need to clear old ones...
        draw_line $((HEADER_HEIGHT-1)) 0
        
        for ((n = 0; n < $(($DISPLAYED_TAB_ENTRIES - $connector_offset)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#TAB_ITEM_ENTRIES[$n]} + 3))
            t_put cup $((HEADER_HEIGHT-1)) $horizontal_connector_position

            if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL && [[ $horizontal_connector_position == $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH)) ]]; then
                echo -n "â¿"
                rp_connector_drawn=true
            else
                echo -n "â·"
            fi

        done

        if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL && ! $rp_connector_drawn; then
            t_put cup $((HEADER_HEIGHT-1)) $LEFT_PANEL_WIDTH
            echo "â¯"
        fi

    fi

    if $TABS_DONT_FIT; then
        t_put cup $((HEADER_HEIGHT - 3)) $(($TERMINAL_WIDTH-1)) 
        # echo -e "\e[091mmâ\e[0m"
        echo -e "\e[091mâ\e[0m"
        t_put cup $((HEADER_HEIGHT - 2)) $(($TERMINAL_WIDTH-1))
        echo -e "\e[091mâ\e[0m"
        t_put cup $((HEADER_HEIGHT - 1)) $(($TERMINAL_WIDTH-1))
        # echo -e "\e[01m\e[091mâ\e[00m"
        echo -e "\e[091mâ\e[0m"
    fi

    check_for_warnings
}



write_menu_items() { 
    # Write out the menu items one by one
    # If the position is right, it changes the background.
    local max_entry_lenght=$(($LEFT_PANEL_WIDTH - 4))

    if $IS_SUB_FLAGS_MENU; then
        MAX_MENU_LENGTH=$(($NORMAL_MENU_HEIGHT - 2))
    else
        MAX_MENU_LENGTH=$(($NORMAL_MENU_HEIGHT - $FOOTER_HEIGHT))
    fi

    if [[ $MENU_POS -gt $(($MAX_MENU_LENGTH - 1)) ]]; then
        MENU_POS=$(($MAX_MENU_LENGTH-1))

        while [[ $MENU_POS > 0 ]]; do
            if [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; then
                ((MENU_POS--))
            else
                break
            fi   
        done
    else      
        while [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; do
        
            ((MENU_POS++))

            if [[ $MENU_POS == $(($MAX_MENU_LENGTH-1)) ]]; then
                break
            fi

        done          
    fi
    
    for ((n = 0; n < $MAX_MENU_LENGTH; n++)); do

        if [[ "${MENU_ITEM_ENTRIES[$n]}" == "---" ]]; then
            t_put cup $(($n + $HEADER_HEIGHT +1)) 0
            draw_divider_line "left"
            continue
        elif [[ "${MENU_ITEM_ENTRIES[$n]}" == "[inline-label]" ]]; then
            local menu_label_line=$(truncate_text "${MENU_ITEM_DESCRIPTIONS[$n]}" $max_entry_lenght)
            t_put cup $(($n + $HEADER_HEIGHT + 1)) 2 # To center, use: $((LEFT_PANEL_WIDTH / 2 - (${#menu_label_line} / 2)))
            echo -e "\e[01m$menu_label_line\e[00m"
        elif [[ ! "${MENU_ITEM_ENTRIES[$n]}" == "skip" ]]; then
            local menu_item_line=$(truncate_text "${MENU_ITEM_ENTRIES[$n]}" $max_entry_lenght)

            t_put cup $(($n + $HEADER_HEIGHT + 1)) 2

            if [[ $n -eq $MENU_POS ]] && [[ "$ACTIVE_PANEL" == "left" ]]; then
                echo -e "\e[00;30;47m$menu_item_line\e[00m"
            else
                echo "$menu_item_line"
            fi

        fi

    done

    local -i line_offset=2

    if $IS_SUB_FLAGS_MENU; then
        line_offset=2
    fi

    t_put cup $(($MAX_MENU_LENGTH + $HEADER_HEIGHT + $line_offset)) 1

    # If the item list was truncated, display a visual clue at the bottom
    if [[ ${#MENU_ITEM_ENTRIES[@]} -gt $MAX_MENU_LENGTH ]]; then
        MENU_LENGTH=$MAX_MENU_LENGTH

        for ((i = 0; i < $(($LEFT_PANEL_WIDTH-2)); i++)); do
            echo -en "\e[01m\e[091mâ\e[00m"
        done

    else
        MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}

        # Reset normal line, otherwise
        for ((i = 0; i < $(($LEFT_PANEL_WIDTH-2)); i++)); do
            echo -n "â"
        done

    fi

    if $IS_SUB_FLAGS_MENU && [[ "$ACTIVE_PANEL" == "left" ]]; then
        write_active_cmb_command
    elif $SHOW_FOOTER; then
        write_descriptor
    fi
}


# Simply write a one line descriptor, as read from the menu file
write_descriptor() { 
    local descriptor_line
    
    if [[ $ACTIVE_PANEL == "right" ]]; then
        descriptor_line=$(truncate_text "${RIGHT_PANEL_ITEM_DESCRIPTIONS[$MENU_POS]}" $(($TERMINAL_WIDTH-4)))
    else
        descriptor_line=$(truncate_text "${MENU_ITEM_DESCRIPTIONS[$MENU_POS]}" $(($TERMINAL_WIDTH-4)))
    fi

    CURSOR_POS=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    clear_line $CURSOR_POS $MENU_WIDTH "left"
    t_put cup $CURSOR_POS 2
    echo "$descriptor_line"
}


write_rightpanel_items() { 
    local menu_type_key

    if $IS_SUB_FLAGS_MENU; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi  
    
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
     
    for ((n = 0; n < ${#RIGHT_PANEL_ITEM_ENTRIES[@]}; n++)); do

        if  $IS_SUB_FLAGS_MENU; then
            if [[ $TERMINAL_HEIGHT -lt $MIN_TERM_H_FOR_R_PANEL_CMB ]] || ! $SHOW_RIGHT_PANEL; then
                if [[ $n > 4 ]]; then
                    break
                fi
            fi
        fi

        local shortkey="${RIGHT_PANEL_ITEM_KEYS[$n]}"

        if [[ "$shortkey" == "skip" ]]; then
            continue
        elif [[ "$shortkey" == "---" ]]; then
            t_put cup $(($n + $HEADER_HEIGHT +1)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH))
            draw_divider_line "right"
            continue
        else
            t_put cup $(($n + $HEADER_HEIGHT + 1)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH))
            local current_item="${RIGHT_PANEL_ITEM_ENTRIES[$n]}"
            current_item=$(truncate_text "$current_item" $(($ACTIVE_RIGHT_PANEL_WIDTH-4)))

            if [[ $n == $MENU_POS ]] && [[ "$ACTIVE_PANEL" == "right" ]]; then
                echo -e "â  \e[00;30;47m$current_item\e[00m"
            else
                echo -e "â  $current_item"
            fi

        fi
    done

    IFS=$OLD_IFS

    if $SHOW_FOOTER || $IS_SUB_FLAGS_MENU; then
        if [[ "$ACTIVE_PANEL" == "right" ]]; then
            write_descriptor
        fi
    fi
}

 write_right_panel_descriptor() { 
    
    local menu_type_key
    
    if $IS_SUB_FLAGS_MENU; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi    

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=0

    local -a rp_item_descriptions=()
    for item in "${RIGHT_PANEL_ITEM_ROWS[@]}"; do

        local -a current_row
        read -ra current_row <<< "$item"

        local menu_type=${current_row[0]}
        local description=${current_row[6]}

        if [[ "$menu_type" == "$menu_type_key" ]]; then  
            rp_item_descriptions+=("$description")
        fi

    done

    IFS=$OLD_IFS

    descriptor_line=$(truncate_text "${rp_item_descriptions[$MENU_POS]}" $(($TERMINAL_WIDTH-4)))
    CURSOR_POS=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    clear_line $CURSOR_POS $MENU_WIDTH "left"
    t_put cup $CURSOR_POS 2
    echo "$descriptor_line"
}


write_main_title(){
    local title=$MAIN_TITLE

    if $IS_ROOT; then
        title=$title$ROOT_TITLE
    fi

    t_put cup 1 $((MENU_WIDTH / 2 - (${#title} / 2)))

    if ! $IS_ROOT; then
        # Print it in bold
        echo -e "\e[01m$title\e[00m"
    else
        # Print it in bold and red
        echo -e "\e[01m\e[091m$title\e[00m"
    fi
}


write_submenu_title() {
    
    # First get rid of any tabs and line connectors
    # Could chck if connectors are even displayed, but why bother 
    # Just override the lines and be done with it
    draw_line $((HEADER_HEIGHT - 3)) 0
    clear_line $((HEADER_HEIGHT - 2)) 1 "right"
    draw_line $((HEADER_HEIGHT - 1)) 0

    # Put line connector for right panel back in place, if applicable
    if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL && $DISPLAY_LINE_CONNECTORS; then
        t_put cup $((HEADER_HEIGHT - 1)) $LEFT_PANEL_WIDTH
        echo "â¯"
    fi

    t_put cup $((HEADER_HEIGHT - 2)) $((MENU_WIDTH / 2 - (${#SUBMENU_TITLE} / 2)))
    echo "$SUBMENU_TITLE"
    
}


# Displays warning messages below the menu, in case stuff don't fit
check_for_warnings() {

    local warning_position=$(($HEADER_HEIGHT + $MAX_MENU_HEIGHT + $FOOTER_HEIGHT +1))
    local msg=""
    local warning_msg=""
    clear_line $warning_position 0 "right"
    clear_line $(($warning_position + 1)) 0 "right"
    
    if $HEIGHT_WARNING || $TABS_DONT_FIT; then
        local menus_label=""
        local tabs_label=""
        local min_height_msg=""
        local min_width_msg=""

        if $HEIGHT_WARNING; then
            min_height_msg=" Min. H: "$(($MAX_MENU_ITEMS + 13))" ch."
            menus_label="Menus "
        fi

        if $TABS_DONT_FIT; then
            min_width_msg=" Min. W: "$ALL_TABS_LENTH" ch"

            if $HEIGHT_WARNING; then
                tabs_label="and tabs "
            else
                tabs_label="Tabs "
            fi

        fi

        msg="$menus_label$tabs_label""won't fit.$min_height_msg$min_width_msg"
        warning_msg=$(truncate_text "$msg" $(($TERMINAL_WIDTH-4)))
        t_put cup $warning_position 0
        echo -e "\e[01m\e[091m$warning_msg\e[00m"
        ((warning_position++))
        msg=""    
    fi

    if $RIGHT_PANEL_HEIGHT_WARNING; then
        msg="Right-panel and cmd-builder disabled. Min. H: $MIN_TERM_HEIGHT_FOR_R_PANEL ch."
    elif $RIGHT_PANEL_WIDTH_WARNING; then
        msg="Right-panel disabled. Min. W: "$(($RIGHT_PANEL_WIDTH * 2))" ch."
    fi

    if [[ -n "$msg" ]]; then
        warning_msg=$(truncate_text "$msg" $(($TERMINAL_WIDTH-4)))
        t_put cup $warning_position 0
        echo -ne "\e[01m\e[091m$warning_msg\e[00m"
    fi
}


# Helper function to make sure text fits on the available space
truncate_text(){
    local text=$1
    local max_lenght=$2

    if [[ ${#text} -gt $max_lenght ]]; then
        text="${text:0:$(($max_lenght - 3))}..."
    fi

    echo "$text"
}


#####################
# Drawign functions #         
#####################

# Draws a line
# Usage: 
# draw_line         # Will draw a line from the current cursor position to the length of the menu  (might overdraw if not staratng from col 1)
# draw_line $length # Will draw a line of the specified length frm the current cursor positon
# draw_line $row $column # Will draw a line from the specified row and column, the length of the menu (might overdraw if not staratng from col 1)
# draw_line $row $column $length # Will draw a line from the specified row and column, and the specified length
draw_line() { 

    local -i line_lenght=$MENU_WIDTH

    if [[ -n $1 ]]; then
        if [[ -n $2 ]]; then
            t_put cup $1 $2
        elif [[ $1 -gt 1 ]]; then
            line_lenght=$1
        fi
    fi

    if [[ -n $3 ]] && [[ $3 -gt 0 ]]; then
        line_lenght=$3
    fi
   
    for ((i = 0; i < $line_lenght; i++)); do
        echo -n "â"
    done
}


draw_divider_line() {
    local -i line_lenght

    if [[ "$1" == "right" ]]; then
        line_lenght=$(($ACTIVE_RIGHT_PANEL_WIDTH-1))
    else
        if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL; then
            line_lenght=$(($LEFT_PANEL_WIDTH))
        else
            line_lenght=$MENU_WIDTH
        fi
    fi

    if [[ "$1" == "right" ]]; then
        if $DISPLAY_LINE_CONNECTORS; then
            echo -n "â"
        else
            echo -n "â"
        fi
    fi

    for ((i = 0; i < $line_lenght; i++)); do
        echo -n "â¶"
    done

}

#clear menu area
clear_menu() { 
    for ((n = 1; n < $MENU_HEIGHT; n++)); do
        clear_line $((n + $HEADER_HEIGHT)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH - 1)) "left"
    done
}


clear_right_panel() {
    for ((n = 0; n < (($MENU_HEIGHT-2)); n++)); do
        clear_line $((n + $HEADER_HEIGHT +1)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH + 1)) "right"
    done
}

# Usage clear_line $line_number $from_column "left|right"
clear_line() {

    if [[ $# -lt 3 ]]; then
        return 65
    fi

    local line_number=$1
    local from_column=$2
    local direction=$3

    t_put cup $line_number $from_column

    if [[ $direction == "left" ]]; then
        echo -ne "\e[1K"
    else
        echo -ne "\e[K"
    fi 
}



#Draws the outline of the menu, with spaces left out for inclusion of items
draw_menu() {

    if $MENUS_FORCE_HIDDEN; then
        show_force_hide_error
        return 1
    fi
    
    t_put civis
    MENU_HEIGHT=$NORMAL_MENU_HEIGHT
  
    #clear menu area. Should be done each time tabs or submenus are changed
    clear_menu
    CURSOR_POS=0
    draw_line $CURSOR_POS 0

    if $SHOW_HEADER; then
        write_main_title
        ((CURSOR_POS+=2))        
    fi

    ((CURSOR_POS+=2))
    draw_line $CURSOR_POS 0
   
    # If rigth panel is on, draw its separator
    if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL; then
        ((CURSOR_POS++))

        for ((i = 0; i <= MENU_HEIGHT; i++)); do
            t_put cup $CURSOR_POS $LEFT_PANEL_WIDTH
            echo "â"
            ((CURSOR_POS++))
        done

    fi

    CURSOR_POS=$(($HEADER_HEIGHT + $FOOTER_HEIGHT + $MENU_HEIGHT))
    draw_line $CURSOR_POS 0
    
    if $SHOW_FOOTER || $IS_SUB_FLAGS_MENU; then
        ((CURSOR_POS -= $FOOTER_HEIGHT))
        draw_line $CURSOR_POS 0
    fi

    if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL && $DISPLAY_LINE_CONNECTORS; then
        t_put cup $CURSOR_POS $LEFT_PANEL_WIDTH
        echo "â·"
    fi

    check_for_warnings
    
}



###################################
# Movement and menu item handling #
###################################

move_up() {
    #Double jump if run on skip
    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        while [[ "${MENU_ITEM_ENTRIES[$MENU_POS - 1]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS - 1]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS - 1]}" == "[inline-label]" ]]; do
            ((MENU_POS--))
        done
    fi

    # Alo in right panel
    if [[ "$ACTIVE_PANEL" == "right" ]]; then 
        while [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS - 1]}" == "skip" ]] || [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS - 1]}" == "---" ]]; do
           ((MENU_POS--))
        done
    fi

    ((MENU_POS--))
    infinite_menu

    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        write_menu_items
    else
        write_rightpanel_items
    fi
}


move_down() {
    #Double jump if running on skip
    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        while [[ "${MENU_ITEM_ENTRIES[$MENU_POS + 1]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS + 1]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS + 1]}" == "[inline-label]" ]]; do           
            ((MENU_POS++))
        done
    fi

    #Chexck for right panel too
    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        while [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS + 1]}" == "skip" ]] || [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS + 1]}" == "---" ]]; do
           ((MENU_POS++))
        done
    fi

    ((MENU_POS++))
    infinite_menu

    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        write_menu_items
    else
        write_rightpanel_items
    fi
}



tab_left() {
    if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU && ! $IS_HELP_SUBMENU; then
        clear_menu
        MENU_POS=0
        ((TAB_POS--))
        infinite_tab
        write_tab_items
        read_menu_items
        write_menu_items
    fi
}


tab_right() { 
    if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU && ! $IS_HELP_SUBMENU; then
        clear_menu
        MENU_POS=0
        ((TAB_POS++))
        infinite_tab
        write_tab_items
        read_menu_items
        write_menu_items
    fi
}

# Jump to a specific tab 
select_tab() {
    local -i target_tab=$(($1 - 1))
    
    if [[ $target_tab -lt $DISPLAYED_TAB_ENTRIES ]]; then
        if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU && ! $IS_HELP_SUBMENU; then
            if [[ $target_tab -eq 0 || $NUMBER_OF_TABS -ge $target_tab ]]; then
                clear_menu
                MENU_POS=0
                TAB_POS=$target_tab
                read_menu_items
                write_tab_items
                write_menu_items
            fi
        fi
    fi
}

#Choose which tab to jumop to by number
select_tab_by_number() {
    local tabkey=""
    read -sN1 -t 1 tabkey

    if [[ -n $tabkey ]]; then 
        if [[ $tabkey -ge 1 ]] && [[ $tabkey -le 9 ]]; then
            select_tab $tabkey
        fi
    fi
}


# Wrap around it reaching either end
infinite_tab() {     
   local  limit=$(($DISPLAYED_TAB_ENTRIES - 1))

    if [[ $limit -lt $NUMBER_OF_TABS ]]; then
       ((limit++))
    fi

    if [[ $TAB_POS -eq $limit ]]; then
        TAB_POS=0
    fi

    if [[ $TAB_POS -lt 0 ]]; then
        TAB_POS=$(($limit - 1))
    fi

}

# Wrap around it reaching either end
infinite_menu() { 
    local -i limit=0

    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        limit=${#RIGHT_PANEL_ITEM_KEYS[@]}
    else
        limit=$MENU_LENGTH
    fi

    if [[ $MENU_POS -ge $limit ]]; then
        MENU_POS=0

        if [[ $ACTIVE_PANEL == "left" ]]; then
            while [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; do
                ((MENU_POS++))
            done
        fi
    fi

    if [[ $MENU_POS -lt 0 ]]; then
        MENU_POS=$(($limit - 1))
        
        if [[ $ACTIVE_PANEL == "left" ]]; then
            while [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; do
                ((MENU_POS--))
            done
        fi
    fi
}


# "left", "right" or "swap"
change_panel() {
    if $IS_SUB_FLAGS_MENU || $SHOW_RIGHT_PANEL; then
        case $1 in
        "right")
            if [[ "$ACTIVE_PANEL" == "left" ]]; then
                ACTIVE_PANEL="right"
                MENU_POS=0
            fi
            ;;
        "left")
            if  [[ "$ACTIVE_PANEL" == "right" ]]; then
                ACTIVE_PANEL="left"
                MENU_POS=0
            fi
            ;;
        *)  
            if [[ "$ACTIVE_PANEL" == "right" ]]; then
                ACTIVE_PANEL="left"
                MENU_POS=0
            else
                ACTIVE_PANEL="right"
                MENU_POS=0
            fi
            ;;
            
        esac

        write_menu_items
        write_rightpanel_items
    fi
}


# Does what it says. It will attempt to read max 2 digits, if it makes sense
select_menu_item_by_number() {

    local key=$1
    local key2=""

    # Only read second digit if it makes sense, otherwise avoid the delay
    local read_second_digit=false

    if [[ $MENU_ITEMS_COUNT -gt 9 ]] && [[ $key -le $(($MENU_ITEMS_COUNT/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi

    local is_valid=1
    ((key--))

    local -i idx=0
    local -i item_idx=0

    for item in "${MENU_ITEM_COMMANDS[@]}"; do

        if [[ $item_idx == $key ]]; then
            # This is necessary, in case item is skipped, or the user left the command intentionally blank
            if [[ ${MENU_ITEM_ENTRIES[$idx]} != "skip" ]]  && [[ ${MENU_ITEM_ENTRIES[$idx]} != "---" ]] && [[ ${MENU_ITEM_ENTRIES[$idx]} != "[inline-label]" ]]; then     
                MENU_POS=$idx
                
                if [[ -n $item ]]; then    
                    check_and_run "$item"
                    is_valid=$?
                else
                    # Select the new position but do nothing else
                    write_menu_items
                fi

                break
            fi
        else
            # This is necessary, in case item is skipped, or the user left the command intentionally blank
            if [[ ${MENU_ITEM_ENTRIES[$idx]} != "skip" ]] && [[ ${MENU_ITEM_ENTRIES[$idx]} != "---" ]] && [[ ${MENU_ITEM_ENTRIES[$idx]} != "[inline-label]" ]]; then 
                ((item_idx++))
            fi 
        fi
        ((idx++))
    done

    if [[ $is_valid == 0 ]]; then
        reflow_menu
    fi

}


# TODO: Get rid of the "functright" thing and select by the command"
# When selecting with enter
select_highlighted_menu_item() {
    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        functright$MENU_POS
    else

        local is_valid=1

        if [[ -n "${MENU_ITEM_COMMANDS[(($MENU_POS))]}" ]]; then
            check_and_run "${MENU_ITEM_COMMANDS[(($MENU_POS))]}"
            is_valid=$?
        fi
        
    fi

    if [[ $is_valid == 0 ]]; then
        reflow_menu
    fi

}



# Credit for the previous picking solution (first 5 lines) goes for eMPee584's 
# answer on the thread below:
# http://stackoverflow.com/questions/10679188/casing-arrow-keys-in-bash
#
# It allowed to read both arrow keys and single characters from a keyboard just 
# fine, but has since been replaced.
#
# Credit now goes to:
# https://stackoverflow.com/a/66500309/6078214
#
# This is the simplest way I have found yet to read all sorts of special keys
pick_menu_item() { 
    local key=""
    local keytap=""

    # Attempt to flush tinput caches
    while read -t 0.01; do :; done

    while true; do
        
        if $AUTO_REFLOW; then
            # Could probably just use trap to biind it to the SIGWINCH signal
            # but I would have to rethink the whole architecture, and this seems to work just fine
            check_for_size_changes
            local size_changed=$?
            
            if [[ $size_changed -gt 0 ]]; then
                if $IS_SUB_FLAGS_MENU && $CMB_FORCE_HIDDEN; then
                    show_cmb_disabled_error
                fi

                break
            fi

            read -rsN1 -t $AUTO_REFLOW_TICK keytap
        else
            read -rsN1 keytap
        fi
      
        # loop while read can read any additional character and join all of them ## Original comment, left unchanged
        
        while [ -n "$keytap" ]; 
        do  
            key="${key}${keytap}"
            read -sN1 -t 0.0001 keytap
        done

        if [[ -n $key ]]; then 

            # if $GOT_STTY; then
            #     restore_terminal
            # fi
            # TODO: Update User guide and key binding guide with F1-9 and t-# keys for tabs access and TAB key for changing panels
            case $key in
            $'\e[A' | $'\e0A')
                move_up
                ;;
            $'\e[B' | $'\e0B')
                move_down
                ;;
            $'\e[D' | $'\e0D')
                tab_left
                ;;
            $'\e[C' | $'\e0C')
                tab_right
                ;;
            $'\e[11~' | $'\eOP') 
                # F1 - Tab 1
                select_tab 1
                ;;
            $'\e[12~' | $'\eOQ')
                # F2 - Tab 2
                select_tab 2
                ;;
            $'\e[13~' | $'\eOR')
                # F3 - Tab 3
                select_tab 3
                ;;
            $'\e[14~' | $'\eOS') 
                # F4 - Tab 4
                select_tab 4
                ;;
            $'\e[15~')
                # F5 - Tab 5
                select_tab 5
                ;;
            $'\e[17~')
                # F6 - Tab 6
                select_tab 6
                ;;
            $'\e[18~')
                # F7 - Tab 7
                select_tab 7
                ;;
            $'\e[19~') 
                # F8 - Tab 8
                select_tab 8
                ;;
            $'\e[20~')
                # F9 - Tab 9
                select_tab 9
                ;; 
            $'\e[1;5C' | $'\e01;5C')
                change_panel "right"
                ;;
            $'\e[1;5D' | $'\e01;5D')
                change_panel "left"
                ;;
            $'\x09')
                change_panel "swap"
                ;;
            [a-zA-Z])
                shortkey_command "$key"
                ;;
            [1-9])
                if $IS_SUB_FLAGS_MENU; then
                    cmb_set_arg_by_number $key
                else
                    select_menu_item_by_number $key
                fi
                ;;
            $'\x0a' | '')
                # If enter is pressed
                if [[ $ACTIVE_PANEL == "right" ]]; then
                    shortkey_command ${RIGHT_PANEL_ITEM_KEYS[$MENU_POS]}
                else
                    if $IS_SUB_FLAGS_MENU; then
                        set_highlighted_cmb_arg "$@"
                    else
                        select_highlighted_menu_item
                    fi
                fi
                ;;

            esac
            
            break

        elif ! $AUTO_REFLOW; then
            break
        fi
    done
}

shortkey_command(){
    case $1 in
        "r")
            change_panel "right"
            ;;
        "l")
            change_panel "left"
            ;;
        "w")
            move_up
            ;;
       "s")
            move_down
            ;;
       "a")
            tab_left
            ;;
       "d")
            tab_right
            ;;
        "t")
            select_tab_by_number
            ;;
        "R")
            toggle_right_panel
            ;;
        "L")
            toggle_line_connectors
            ;;
        "H")
            toggle_header
            ;;
        "F")
            toggle_footer
            ;;
        "o")
            if ! $IS_SUBMENU; then
                enter_setupmenu
            fi
            ;;
        "f") 
            reflow_menu
            ;;
        "h")
            if ! $IS_HELP_SUBMENU; then
                display_help
            fi
            ;;
        "k")
            display_hotkeys
            ;;
        "q") 
            #this handles exit function
            exit_lazy_admin
            ;;
        "b")
            if $IS_SUBMENU; then
                back_to_main_menu
            fi
            return
            ;;
        "m")
            if $IS_SUB_FLAGS_MENU; then
                cmb_set_manual_args
            fi
            ;;
        "p")
            if $IS_SUB_FLAGS_MENU; then
                cmb_set_manual_args "nospace"
            fi
            ;;
        "c")
            if $IS_SUB_FLAGS_MENU; then
                cmb_commit_with_args
            fi
            ;;
        "x")
            if $IS_SUB_FLAGS_MENU; then
                cmb_clear_args
            fi
            ;;
    esac

}



# This will be called when a submenu is selected
enter_submenu() {
    MAIN_MENU_POS="$MENU_POS"
    MENU_POS=0

    if [[ -z "$1" ]]; then
        SUBMENU_TITLE="${MENU_ITEM_ENTRIES[$MAIN_MENU_POS]}"
        SUBMENU_TITLE="Submenu: ${SUBMENU_TITLE#* - }"
    else
        SUBMENU_TITLE="$1"
    fi

    IS_SUBMENU=true
    REMAIN_IN_SUBMENU=false
    read_submenu_items "${TAB_ITEM_KEYS[$TAB_POS]}" $MAIN_MENU_POS
    clear_menu
    write_menu_items
    
    if $SHOW_RIGHT_PANEL; then
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items
    fi   

    write_submenu_title

}


# This will be called when help menu is selected
enter_helpmenu() { 
    IS_HELP_SUBMENU=true

    if $IS_SUBMENU; then
        REMAIN_IN_SUBMENU=true
        OLD_SUBMENU_TITLE="$SUBMENU_TITLE"
        OLD_TAB_POS=$TAB_POS
        OLD_MAIN_MENU_POS=$MAIN_MENU_POS
    else
        REMAIN_IN_SUBMENU=false
    fi

    IS_SUBMENU=true

    SUBMENU_TITLE="Help"
    MAIN_MENU_POS="$MENU_POS"
    MENU_POS=0
    read_menu_items "Help"
    clear_menu
    write_menu_items
    
    if $SHOW_RIGHT_PANEL; then
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items
    fi   

    write_submenu_title
}


# This will be called when setup menu is selected
enter_setupmenu() { 

    REMAIN_IN_SUBMENU=false
    IS_SUBMENU=true
    SUBMENU_TITLE="Setup Options"
    MAIN_MENU_POS="$MENU_POS"
    MENU_POS=0
    read_menu_items "Setup"
    clear_menu
    write_menu_items
    
    if $SHOW_RIGHT_PANEL; then
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items
    fi   

    write_submenu_title
}




###################################
# Command builder specific stuffs #
###################################


# This function will
# construct a submenu from the supplied arguments, from which
# the user can interactively build a command
#
# Arguments to supply:
# $1 - Title for the submenu
# $2 - base command to start the chain with. It can already contain preset arguments
# $3 - $99 - arguments to be represented as one of the possible 99 menu items.
#
# The arguments can contain more than one options, if supplied in quotes,
# it will be treated as a sibngle menu entry, such as passing e.g.
#
# cmb "My title" my_command --option_1 option_two option_three "--whatever_flag 8" 
#
# will create a menu witht ht title "My title", that will run the command my_comand
# and selectable arguments:
#
# 1 - option_1 
# 2 - option_two 
# 3 - option_three 
# 4 - --whatever_flag 8
#
# Selecting an argument will append them at the end of the command

# Shortcut to use in menus
cmb() {
    
    if [[ $# -ge 3 ]]; then
        command_builder "$@"

    elif [[ $(function_exists "$1") == 0 ]]; then
        $1
    fi
}

# This is the real thing, but don't use it directly
command_builder(){
    CMB_ARGS=""

    if $IS_SUBMENU; then
        REMAIN_IN_SUBMENU=true
        OLD_SUBMENU_TITLE="$SUBMENU_TITLE"
        OLD_TAB_POS=$TAB_POS
        OLD_MAIN_MENU_POS=$MAIN_MENU_POS
    else
        REMAIN_IN_SUBMENU=false
    fi
    
    IS_SUBMENU=true
    IS_SUB_FLAGS_MENU=true

    # First arg is always the menu title
    SUBMENU_TITLE="$1"
    shift

    #Next one is the main command itself
    CMB_COMMAND="$1"
    shift
    MENU_POS=0

    # Everything else goes to processing
    set_command_builder_items "$@"

    if ! $SHOW_FOOTER || ! $SHOW_RIGHT_PANEL; then
        reflow_menu
    else
        clear_menu
    fi

    if ! $CMB_FORCE_HIDDEN; then
        write_menu_items
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items

        # We do this instead of item descriptora here
        # It displayes the current command
        if [[ "$ACTIVE_PANEL" == "left" ]]; then
            write_active_cmb_command
        fi

        write_submenu_title
    else
        show_cmb_disabled_error
    fi

}


set_command_builder_items() {     

    local array_counter=0
    MENU_ITEM_ENTRIES=()
    MENU_ITEM_COMMANDS=()
    MENU_ITEM_DESCRIPTIONS=()

    for arg in "$@"; do

        local entry=$(($array_counter+1))" - Set arg. ${arg}"
        MENU_ITEM_ENTRIES+=("$entry")
        MENU_ITEM_COMMANDS+=("$arg")
        
        ((array_counter++))

    done
    
    MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}

}


write_active_cmb_command(){
    # ~~TODO: Got to make sure this does not go ovber the screen limit.~~
    # 7 years leter: No, that's the user's problem, terminal emulators can be resized
    # 1 Week later: Nah, I got it.
    local cmd_msg="Active command: $CMB_COMMAND$CMB_ARGS"
    cmd_msg=$(truncate_text "$cmd_msg" $(($TERMINAL_WIDTH-2)))
    CURSOR_POS=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    clear_line $CURSOR_POS $MENU_WIDTH "left"
    t_put cup $CURSOR_POS 2
    echo "$cmd_msg"  
}


show_cmb_disabled_error() {
    clear
    echo "Cannot display Command Builder. Press any key to return to the calling menu, then resize the widnwo to try again."
    echo

    if $RIGHT_PANEL_HEIGHT_WARNING; then
        echo "Minimum supported height: $MIN_TERM_HEIGHT_FOR_R_PANEL characters."
        echo -e "Current height: \e[01m\e[091m$TERMINAL_HEIGHT\e[00m characters"
        echo
    fi

    if $RIGHT_PANEL_WIDTH_WARNING; then
        echo "Minimum supported width: $(($RIGHT_PANEL_WIDTH * 2)) characters."
        echo -e "Current width: \e[01m\e[091m$TERMINAL_WIDTH\e[00m characters"
        echo
    fi

    read -n 1 -s key_press
    back_to_main_menu "force-reflow"
}


set_highlighted_cmb_arg() {
    # If enter is pressed
    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        functright$MENU_POS
    else
        CMB_ARGS="$CMB_ARGS ${MENU_ITEM_COMMANDS[$MENU_POS]}"
        write_active_cmb_command
    fi
}


cmb_set_manual_args() {

    # Manual argument might or might not start with space, depending
    # This is for convenience. You might want to append an options with no space
    # or the next argument, without having to worry about prepending a space
    local space=" "

    if [[ "$1" == "nospace" ]]; then
        space=""
    fi

    # Put it back into printing mode
    restore_terminal
    local -i input_position=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    clear_line $input_position 2 "right"
    read -p "Your args> " line_args
    CMB_ARGS="$CMB_ARGS$space$line_args"
   
    # Clear the line right after user pressed enter
    clear_line $input_position 0 "right"
    
    # Again, malke it not print artifacts
    set_up_terminal

    if [[ $ACTIVE_PANEL != "left " ]]; then
        change_panel "left"
    else
        write_active_cmb_command
    fi
}


cmb_commit_with_args() {
    clear
    echo
    echo "Executing:"
    echo "$CMB_COMMAND$CMB_ARGS"
    echo
    $CMB_COMMAND$CMB_ARGS
    echo
    echo "Now press a key to get back to the menu"
    read -n 1 -s key_press
    back_to_main_menu 
}


cmb_clear_args() {
    CMB_ARGS=''
    write_active_cmb_command
}


cmb_set_arg_by_number() {

    local -i key=$1
    local read_second_digit=false

    if [[ ${#MENU_ITEM_COMMANDS[@]} -gt 9 ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi
    
    if [[ $key -le ${#MENU_ITEM_COMMANDS[@]} ]]; then
        CMB_ARGS="$CMB_ARGS ${MENU_ITEM_COMMANDS[$key-1]}"
        MENU_POS=$(($key-1))
        write_menu_items
        write_active_cmb_command
    fi

}



#######################
# Temporary overrides #
#######################

# Temporarily override showing/hiding right panel
toggle_right_panel() {

    if $RIGHT_PANEL; then
        RIGHT_PANEL=false
    else
        RIGHT_PANEL=true
    fi

    SHOW_RIGHT_PANEL=$RIGHT_PANEL
    reflow_menu
}


# Temp. overide showing/hiding line conectors
toggle_line_connectors(){

    if $DISPLAY_LINE_CONNECTORS; then
        DISPLAY_LINE_CONNECTORS=false
    else
        DISPLAY_LINE_CONNECTORS=true
    fi

    reflow_menu
}


# Temp override showing/hiding the title bar
toggle_header(){
    if $SHOW_HEADER; then
        SHOW_HEADER=false
    else
        SHOW_HEADER=true
    fi

    reflow_menu
}


# Temp override showing/hiding the title description bar 
toggle_footer(){
    if $SHOW_FOOTER; then
        SHOW_FOOTER=false
    else
        SHOW_FOOTER=true
    fi

    if ! $IS_SUB_FLAGS_MENU; then
        reflow_menu
    fi
}



####################
# Rightpanel stuff #
####################

#this is the standard reflow function

reflow_menu() { 
    clear
    set_menu_sizes
    if ! MENUS_FORCE_HIDDEN; then
        init_menu "reflow"
    fi
}

# Navigation help
display_hotkeys() { 
    display_markdown_help "$RES_DIR/shortkeys.md" "$RES_DIR/shortkeys.txt"
    reflow_menu
}


# Calls the papproropriate help function, either the help submenu
# or the single help file, depending on where the user is
display_help() { 
    if $IS_SUB_FLAGS_MENU; then
        functhelp_commanbuilder
        reflow_menu
    else
        enter_helpmenu
    fi
}


# Quits Lazy Admin, and restores the cursor, but only if
# not returning from a nested root shell
# (It is possible to run another shell of ladmin form within)
exit_lazy_admin() { 
    t_put cnorm
    clear
    clear
    echo
    echo "$@"
    echo
    exit 0
}


# Misleading function name (TODO:change it)
# It will return to the calling menu, which can be a submenu in case of
# help menu or command builder
back_to_main_menu() { 

    ACTIVE_PANEL="left"
    MENU_POS=$MAIN_MENU_POS
    local should_reflow=false
    
    if $IS_SUB_FLAGS_MENU; then
        should_reflow=true
    fi
    
    IS_SUB_FLAGS_MENU=false
    
    if [[ "$1" == "force-reflow" ]]; then
        should_reflow=true
        REMAIN_IN_SUBMENU=false
    fi
   
    IS_HELP_SUBMENU=false

    if $REMAIN_IN_SUBMENU; then
        IS_SUBMENU=true
        REMAIN_IN_SUBMENU=false  
        TAB_POS=$OLD_TAB_POS
        MENU_POS=$OLD_MAIN_MENU_POS
        enter_submenu "$OLD_SUBMENU_TITLE"
    else
        IS_SUBMENU=false
        write_tab_items

        if $SHOW_HEADER; then
            write_main_title
        fi

        read_menu_items
        read_rightpanel_items
        clear_menu
        clear_right_panel
        write_menu_items

        if $SHOW_RIGHT_PANEL; then
            write_rightpanel_items
        fi
    fi

    if $should_reflow; then
        reflow_menu
    fi
   
    return
}


####################
# Helper functions #
####################

# Returns 0 if function name is valid, other nuber if not
function_exists() {
    declare -f -F $1 > /dev/null
    echo $?
}

# Returns 0 if package exists on system, other number if not

package_exists() {
    if hash "$1" 2>/dev/null; then
        echo 0
    else
        echo 1
    fi
}

# Performs the above two in succession (if not a function checks if it' a package)
validate_item() { 
    if [[ $(function_exists "$1") == 0 ]]; then
        echo 0
    elif [[ $(package_exists "$1") == 0 ]]; then
        echo 0
    else
        echo 65
    fi
}

# Will evaulate if the given command is a valid funcvitn name first.
# If not found, it will try to find an installed package
# Run if found either, otherwise display an error msg
# Originally written for the preset menus, in case some stuff is not 
# present on th tyarget system, but it can be useful in other scenarios too
check_and_run(){
    local is_valid=false
    local is_navigation=false
    local delayed_return=false
    local validate_first=false
    local clear_before_running=false
    local command_item="$1"
    local command_function=""
    local command_args=""

    while true; do
        if [[ "$command_item" =~ " " ]]; then
            command_function="${command_item%% *}"

            if [[ "$command_function" == "/c" ]]; then
                clear_before_running=true
                command_item="${command_item:3}"
                continue
            elif [[ "$command_function" == "/d" ]]; then
                delayed_return=true
                command_item="${command_item:3}"
                continue
            elif [[ "$command_function" == "/v" ]]; then        
                validate_first=true
                command_item="${command_item:3}"
                continue
            else
                command_args="${command_item#* }"
                break
            fi
        else
            command_function="$command_item"
            command_args=""
            break
        fi
    done
    
    is_valid=true
    
    case "$command_function" in
        "enter_submenu")
            is_navigation=true
            ;;
        "back_to_main_menu")
            is_navigation=true
            ;;
        "cmb")
            is_navigation=true
            ;;
    esac

    if $validate_first && ! $is_navigation; then
        is_valid=false
        
        if [[ $(validate_item $command_function) == 0 ]]; then
            is_valid=true
        else
            clear
            echo 
            echo "The specified command: '$command_function' is not a valid function or package name"
            echo
            return_to_menu
        fi
    fi

    if $is_valid; then
        if ! $is_navigation; then
            restore_terminal
        fi

        if $clear_before_running; then
            clear
        fi

        if [[ -n "$command_args" ]]; then
            eval "$command_function $command_args"
        else
            "$command_function"
        fi      

        if $delayed_return; then
            is_valid=false

            if ! $is_navigation; then
                set_up_terminal
            fi

            return_to_menu
        fi

    fi

    if ! $is_navigation; then
        set_up_terminal
    fi

    if $is_navigation || ! $is_valid; then
        return 65
    else
        return 0
    fi
    
}


# Helper functon to wait for user input after command finishes running /d switch in menyus
return_to_menu() { 
    echo
    echo "Press any key to return to menu"
    read -n 1 -s key_press
    clear
    init_menu
}


# Try to avoid printing all sorts of artifacts when navigating the menus
# And hide the cursor
set_up_terminal(){
    t_put civis

    if $USE_STTY && hash stty 2>/dev/null; then
        GOT_STTY=true
        _SAVED_STTY_SETTINGS=$(stty -g)
        stty -icanon -echo
    fi  
}


# Put things back how they were or should be
restore_terminal() {
    if $GOT_STTY; then
        if [[ -n "$_SAVED_STTY_SETTINGS" ]] then
            stty "$_SAVED_STTY_SETTINGS"
        else
            stty sane
        fi
    fi

    t_put cnorm 
}


# Just in case tput might not be available for ANY reason
# This way it will stillbe used if present, but alternatives will be sought if not
# so technically tput is no longer a dependency
t_put() {
    if [[ $1 == "cols" ]]; then
        echo $(tput_cols) 
    elif [[ $1 == "lines" ]]; then
        echo $(tput_lines) 
    elif [[ $(package_exists "tput") == 0 ]]; then
        eval tput $@
    else
        case $1 in
            "cup")
                local row=$(($2+1))
                local col=$(($3+1))
                echo -ne "\e[${row};${col}H"
                ;;
            "civis")
                echo -e "\e[?25l"
                ;;
            "cnorm")
                echo -e "\e[?25h"
                ;;
        esac
    fi
    
}

# The below two functions are to check terminal size in various ways
tput_cols(){
    local columns=0
    if $USE_STTY && $GOT_STTY; then
        local terminal_size=$(stty size)
        columns=${terminal_size##* }  # Everything after the last space
    elif [[ $(package_exists "tput") == 0 ]]; then
        columns=$(tput cols)
    else  
        # Ensure checkwinsize is enabled for non-interactive shells to update these variables
        shopt -s checkwinsize

        # For non-interactive scripts, a subshell is needed to trigger the update
        # The `(:)` is a no-op command that creates a subshell.
        # This ensures $LINES and $COLUMNS are updated before you read them.
        (:)
        columns=$COLUMNS

    fi

    echo "$columns"

}


tput_lines(){
    local rows=0
    if $USE_STTY && $GOT_STTY; then
        local terminal_size=$(stty size)
        rows=${terminal_size%% *}  # Everything before the first space
    elif [[ $(package_exists "tput") == 0 ]]; then
        rows=$(tput lines)

    else  
        # Ensure checkwinsize is enabled for non-interactive shells to update these variables
        shopt -s checkwinsize

        # For non-interactive scripts, a subshell is needed to trigger the update
        # The `(:)` is a no-op command that creates a subshell.
        # This ensures $LINES and $COLUMNS are updated before you read them.
        (:)
        rows=$LINES

    fi

    echo "$rows"

}


############################
# And, last, but not least #
############################

# Initialises and displays the main menu
# This is what the launcher calls, basically
main() { 

    # Ensure everything is restored on script exit
    set_up_terminal

    # Everything should be restired tomnormal if interrupted
    trap restore_terminal EXIT HUP INT QUIT TERM

    set_up_menus

    for ((i = 1; i <= $#; i++)); do
        j=$((i + 1))

        # This can be extended with any number of arguments later, possibly to change defaults on the fly
        case "${!i}" in
        "-j" | "--join-lines")
            if [[ "${!j}" == "off" ]]; then
                DISPLAY_LINE_CONNECTORS=false
            elif [[ "${!j}" == "on" ]]; then
                DISPLAY_LINE_CONNECTORS=true
            fi
            ;;
        *)
            #Do nothing
            ;;
        esac
    done

    if ! MENUS_FORCE_HIDDEN; then
        init_menu
    fi

    # The main loop
    while true; do
        pick_menu_item
    done
}


