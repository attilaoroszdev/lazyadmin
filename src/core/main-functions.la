#!/bin/bash
#
# Copyright © 2017-2025, Attila Orosz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#This file fontains the functions providing basic functionality of the menu system
#Cusom "user functions" will be stored in $USER-DIR/user-function.la


# normal_menu_height=$(( $MAX_MENU_ITEMS + 3 ))
# submenu_height=$(( $MAX_SUBMENU_ITEMS + 3 )) 
# menu_height=0

set_menu_sizes() {
    terminal_height=$(tput lines)
    terminal_width=$(tput cols)

    # echo "Terminal height: $terminal_height"
    # sleep 1

    if [[ $terminal_height -lt $MIN_TERMINAL_HEIGHT ]]; then
        clear
        echo
        echo "Terminals shorter than $MIN_TERMINAL_HEIGHT characters are not currently supported."
        echo "(This one seems to be only $terminal_height characters tall"
        echo
        echo "Exiting..."
        echo
        tput cnorm
        exit 65
    fi

    right_panel_warning=false
    size_warning=false
    normal_menu_height=$(( $MAX_MENU_ITEMS + 3 ))
    submenu_height=$(( $MAX_SUBMENU_ITEMS + 3 )) 
    menu_height=0

    show_right_panel=$RIGHT_PANEL

    if [[ $terminal_height -lt $MIN_TERM_HEIGHT_FOR_R_PANEL ]]; then
        show_right_panel=false
        if $RIGHT_PANEL; then
            right_panel_warning=true
        fi
    fi

    max_menu_height=$(($terminal_height - 10))

    # Got to make sure we fit inside whatever size the terminal currently is
    if [[ $normal_menu_height -gt $max_menu_height ]]; then
        normal_menu_height=$max_menu_height
        size_warning=true
    else
        size_warning=false
    fi

    if [[ $submenu_height -gt $(($max_menu_height + 2)) ]]; then
        submenu_height=$(($max_menu_height + 2))
    fi

    if $show_right_panel; then
        
        if [[ $normal_menu_height -lt $MIN_MENU_HEIGHT ]]; then
            normal_menu_height=$MIN_MENU_HEIGHT
        fi

        if [[ $submenu_height -lt $MIN_MENU_HEIGHT ]]; then
            submenu_height=$MIN_MENU_HEIGHT
        fi

    else
        
        if [[ $normal_menu_height -lt $MIN_MENU_HEIGHT_SINGLE_PANEL ]]; then
            normal_menu_height=$MIN_MENU_HEIGHT_SINGLE_PANEL
        fi

        if [[ $submenu_height -lt $MIN_MENU_HEIGHT_SINGLE_PANEL ]]; then
            submenu_height=$MIN_MENU_HEIGHT_SINGLE_PANEL
        fi

    fi
    
    $menu_height=$normal_menu_height

}

check_for_size_changes(){
    if [[ $terminal_height -ne $(tput lines) ]] || [[ $terminal_width -ne $(tput cols) ]]; then
        reflow_menu
        return 1
    fi

    return 0
}

set_up_menus() {
    tick=$AUTO_REFLOW_TICK


    # Safe value for $tick, we don't want the system to freeze...    
    if [[ ! $tick -ge 1 ]] || [[ $tick -lt 1 ]]; then
        tick=0.5
    fi

    if [[ -f $menu_file ]]; then
        echo "Setting menus..."
        set_menu_sizes     
    else
        clear
        echo
        echo "Looked for menus in:"
        echo $menu_file
        echo
        echo "Error: Cannot find menuentries file in default location. Exiting..."
        echo
        exit 65
    fi
}

find_menu_type() {     
    OLDIFS="$IFS"
    IFS=$'\n'
    menu_type=($(cat $menu_file | sed -n '/'_menutype'/{:a;n;/'_endmenutype'/q;p;ba}'))
    IFS="$OLDIFS"
}


#This function will read the menu entries from the menu entries file as set in defaults
read_menu_items() { 
    menu_item=$tab_pos
    sub_parent=$1
    sub_item=$2

    if [[ $menu_type == "simple" ]]; then
        ((menu_item++))
        ((sub_parent++))
        ((sub_item++))
    fi

    menu_entry=""

    if $submenu; then
        OLDIFS="$IFS"
        IFS=$'\n'
        menu_entry=($(cat $menu_file | sed -n '/'_submenu$sub_parent$sub_item'/{:a;n;/'_endsubmenu$sub_parent$sub_item'/q;p;ba}'))

        if $help_submenu; then
            menu_height=$HELP_SUB_MENU_HEIGHT
            max_menu_length=$((HELP_SUB_MENU_HEIGHT - 2))
        else
            menu_height=$submenu_height
        fi

        max_menu_length=$(($submenu_height - 3))
        IFS="$OLDIFS"
    else
        OLDIFS="$IFS"
        IFS=$'\n'
        menu_entry=($(cat $menu_file | sed -n '/'_menu$menu_item'/{:a;n;/'_endmenu$menu_item'/q;p;ba}'))
        menu_height=$normal_menu_height
        max_menu_length=$(($normal_menu_height - 3))
        IFS="$OLDIFS"
    fi
    
    menu_length=${#menu_entry[@]}

    if [[ $menu_length -gt $max_menu_length ]]; then
        for ((i = $max_menu_length; i < $menu_length; i++)); do
            unset "menu_entry[$i]"
        done
    fi

    menu_length=${#menu_entry[@]}
}


set_command_builder_items() {     
    #Parse the argument list into the array, starting form the 3rd argument
    array_offset=2
    array_counter=1

    for i in "$@"; do
 
        if [[ $array_counter -gt $array_offset ]] && [[ $array_counter -le $(($max_menu_height -5)) ]]; then
            let current_flag_item=$array_counter-2
            menu_entry[current_flag_item - 1]="$current_flag_item - Set arg. $i"
        else
            break
        fi

        ((array_counter++))

    done

    #Check if entries have already been written, by checking last element
    last_entry=${menu_entry[${#menu_entry[@]} - 1]}
   
    if [[ "$last_entry" != "x - Delete set flags" ]]; then
        menu_entry+=("m - Manually enter flags ")
        menu_entry+=("c - Commit with flags")
        menu_entry+=("x - Delete set flags")
    fi

    menu_length=${#menu_entry[@]}
}


write_flags_descriptor() { 
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2
    case ${menu_entry[$menu_pos]} in
    "m - Manually enter flags ")
        echo "Manually enter flags for the command specified"
        ;;
    "c - Commit with flags")
        echo "Finished entering flags, proceed with command"
        ;;
    "x - Delete set flags")
        echo "Clear list of set flags to start over again"
        ;;
    *)
        echo "Set the specified flag"
        ;;
    esac
}


# read descriptor lines for menu items
# years later: I have no idea how sed works any more, so this all looks like magic
read_descriptor() { 
    if [[ -z $menu_type || $menu_type == "old" ]]; then
        
        if $submenu; then
            OLDIFS="$IFS"
            IFS=$'\n'

            if [[ "$active_panel" == "right" ]]; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_subrightpaneldesc'/{:a;n;/'_endsubrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_descsubmenu$1$2'/{:a;n;/'_enddescsubmenu$1$2'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        else
            OLDIFS="$IFS"
            IFS=$'\n'

            if [[ "$active_panel" == "right" ]]; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_rightpaneldesc'/{:a;n;/'_endrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_descmenu$tab_pos'/{:a;n;/'_enddescmenu$tab_pos'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        fi

    else

        if [[ "$active_panel" == "right" ]]; then
            for ((n = 0; n < $menu_length; n++)); do
                eval $(echo ${menu_entry[n]} | sed 's:^:V1=":; /\:\:/ s::";V2=": ;s:$:":')
                menu_entry[n]="$(echo $V1)"
            done

            OLDIFS="$IFS"
            IFS=$'\n'

            if $submenu; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_subrightpaneldesc'/{:a;n;/'_endsubrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_rightpaneldesc'/{:a;n;/'_endrightpaneldesc'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        else
            for ((n = 0; n < $menu_length; n++)); do
                eval $(echo ${menu_entry[n]} | sed 's:^:V1=":; /\:\:/ s::";V2=": ;s:$:":')
                menu_entry[n]="$(echo $V1)"
                menu_desc_entry[n]="$(echo $V2)"
            done
        fi
    fi
}


# Load the items shown in the tab
read_tab_items() {     
    OLDIFS="$IFS"
    IFS=$'\n'

    if $alt_menu; then
        tab_entry=($(cat $menu_file | sed -n '/'_submenutab$tab_pos$menu_pos'/{:a;n;/'_endsubmenutab$tab_pos$menu_pos'/q;p;ba}'))
    else
        tab_entry=($(cat $menu_file | sed -n '/'_menutab'/{:a;n;/'_endmenutab'/q;p;ba}'))
    fi

    IFS="$OLDIFS"
    tab_length=$((${#tab_entry[@]} - 1))

    if [[ $tab_length -gt 9 ]]; then
        for ((i = 10; i < $tab_length + 1; i++)); do
            unset "tab_entry[$i]"
        done

        tab_length=9
    fi
}


read_rightpanel_items() {     
    OLDIFS="$IFS"
    IFS=$'\n'

    if $submenu; then
        right_panel_entry=($(cat $menu_file | sed -n '/'_subrightpanel'/{:a;n;/'_endsubrightpanel'/q;p;ba}'))
    else
        right_panel_entry=($(cat $menu_file | sed -n '/'_rightpanel'/{:a;n;/'_endrightpanel'/q;p;ba}'))
    fi

    IFS="$OLDIFS"
    right_panel_length=${#right_panel_entry[@]}
}


read_help_rightpanel_items() {     
    OLDIFS="$IFS"
    IFS=$'\n'
    right_panel_entry=($(cat $menu_file | sed -n '/'_helprightpanel'/{:a;n;/'_endhelprightpanel'/q;p;ba}'))
    IFS="$OLDIFS"
    right_panel_length=${#right_panel_entry[@]}
}


#Display the menu tabs
write_tab_items() {  
    # Modify top line first, draw connectors
    if $DISPLAY_LINE_CONNECTORS; then
        horizontal_connector_position=0
        tput cup $((header_height - 2)) $horizontal_connector_position

        for ((n = 0; n < $tab_length; n++)); do

            if [[ n -eq $tab_pos ]]; then
                horizontal_connector_position=$(($horizontal_connector_position + ${#tab_entry[$tab_pos]} + 3))
                tput cup $((header_height - 2)) $horizontal_connector_position
                echo -n "┯"
            else
                horizontal_connector_position=$(($horizontal_connector_position + ${#tab_entry[n]} + 3))
                tput cup $((header_height - 2)) $horizontal_connector_position
                echo -n "┯"
            fi

        done
    fi

    # Then write out the tab items, with separators
    tput cup $((header_height - 1)) 1
    for ((n = 0; n <= $tab_length; n++)); do
       
        if [[ n -eq $tab_pos ]]; then
            echo -n -e "\e[00;30;47m ${tab_entry[$tab_pos]} \e[00m"
            
            # Do not write separator after last item
            if [[ n -lt $tab_length ]]; then
                echo -n "│"
            fi

        else
            echo -n " ${tab_entry[n]} "

            # Do not write separator after last item
            if [[ n -lt $tab_length ]]; then
                echo -n "│"
            fi       
        fi
    done

    if $DISPLAY_LINE_CONNECTORS; then
        # Then draw connectors ont he bottom line
        horizontal_connector_position=0
        tput cup $((header_height)) $horizontal_connector_position

        for ((n = 0; n < $tab_length; n++)); do

            if [[ n -eq $tab_pos ]]; then
                horizontal_connector_position=$(($horizontal_connector_position + ${#tab_entry[$tab_pos]} + 3))
                tput cup $((header_height)) $horizontal_connector_position

                if $show_right_panel && [[ $horizontal_connector_position == $(($menu_width - $active_right_panel_width)) ]]; then
                    echo -n "┿"
                else
                    echo -n "┷"
                fi

            else
                horizontal_connector_position=$(($horizontal_connector_position + ${#tab_entry[n]} + 3))
                tput cup $((header_height)) $horizontal_connector_position

                if $show_right_panel && [[ $horizontal_connector_position == $(($menu_width - $active_right_panel_width)) ]]; then
                    echo -n "┿"
                else
                    echo -n "┷"
                fi
            fi
        done
    fi
}


# Populate the drawn menu template with the menu items
write_menu_items() { 
    # Draw the menu items
    # If the position is right, it changes the background.
    # As the variable does not get modified, this needs no resetting
    for ((n = 0; n < $menu_length; n++)); do

        if [[ "${menu_entry[n]}" == "skip" ]]; then
            ((n++))
        fi

        if [[ n -eq $menu_pos ]] && [[ "$active_panel" == "left" ]]; then
            tput cup $((n + $header_height + 2)) 2
            echo -e "\e[00;30;47m${menu_entry[$menu_pos]}\e[00m"
        else
            tput cup $((n + $header_height + 2)) 2
            echo "${menu_entry[n]}"
        fi

    done

    cursor_pos=$(tput lines)
    tput cup $cursor_pos 0
}


# This is hardcoded for now.
# Might gonna get its own resource file in a future release
write_help_menu_items() { 
    menu_length=3
    help_menu_entry[0]="1 - Lazy Admin usage guide"
    help_menu_entry[1]="2 - Configuration and scripting guide"
    help_menu_entry[2]="3 - Command builder usage guide"

    for ((n = 0; n < $menu_length; n++)); do
        
        if [[ "${help_menu_entry[n]}" == "skip" ]]; then
            ((n++))
        fi

        if [[ n -eq $menu_pos ]] && [[ "$active_panel" == "left" ]]; then
            tput cup $((n + $header_height + 2)) 2
            echo -e "\e[00;30;47m${help_menu_entry[$menu_pos]}\e[00m"
        else
            tput cup $((n + $header_height + 2)) 2
            echo "${help_menu_entry[n]}"
        fi

    done
}


# Draw show_right_panel items
write_rightpanel_items() { 
    for ((n = 0; n < $right_panel_length; n++)); do
       
        if [[ "${right_panel_entry[n]}" == "skip" ]]; then
            ((n++))
        fi

        if [[ n -eq $menu_pos ]] && [[ "$active_panel" == "right" ]]; then
            tput cup $((n + $header_height + 2)) $(($menu_width - $active_right_panel_width + 3))
            echo -e "\e[00;30;47m${right_panel_entry[$menu_pos]}\e[00m"
        else
            tput cup $((n + $header_height + 2)) $(($menu_width - $active_right_panel_width + 3))
            echo "${right_panel_entry[n]}"
        fi

    done

    cursor_pos=$(tput lines)
    tput cup $cursor_pos 0
}


#Draws a line
draw_line() { 
    #draw line with the length of the screen/window width
    for ((i = 0; i < $menu_width; i++)); do
        echo -n "━"
    done
    #cursor goes to next row
}


#clear menu area
clear_menu() { 
    for ((n = 1; n < $menu_height; n++)); do
        tput cup $((n + $header_height)) $(($menu_width - $active_right_panel_width - 1))
        echo -e "\033[1K"
    done
}


#Draws the outline of the menu, with spaces left out for inclusion of items
draw_menu() { 
    tput civis

    if $sub_flags_menu; then
        menu_height=$submenu_height
        header_height=$SUB_HEADER_HEIGHT
        title=$sub_flags_menutitle
    else
        if $submenu; then

            if $help_submenu; then
                menu_height=$HELP_SUB_MENU_HEIGHT
            else
                menu_height=$submenu_height
            fi

            header_height=$SUB_HEADER_HEIGHT
            title=$submenu_title
        else
            menu_height=$normal_menu_height
            header_height=$MAIN_HEADER_HEIGHT
            title=$MAIN_TITLE
        fi

    fi

    if $root; then
        title=$title$ROOT_TITLE
    fi

    ## Set width of screen and panels
    menu_width=($(tput cols) - 1)

    if ! $show_right_panel; then
        active_right_panel_width=0
    else
        active_right_panel_width=$RIGHT_PANEL_WIDTH
    fi

    left_panel_width=$(($menu_width - $active_right_panel_width))
    #clear menu area. Should be done each time tabs or submenus are changed
    clear_menu
    #draw title
    cursor_pos=0
    tput cup $cursor_pos 0
    draw_line
    ((cursor_pos++))
    tput cup $cursor_pos 0
    #echo "│       "
    tput cup $cursor_pos $((menu_width / 2 - (${#title} / 2)))

    #title must be set by function for submenus...
    if [[ "$root" != "true" ]]; then
        echo -e "\e[01m$title\e[00m"
    else
        echo -e "\e[01m\e[01;31m$title\e[00m"
    fi

    #tput cup $cursor_pos $menu_width
    #echo "│"
    ((cursor_pos++))
    draw_line

    #Draw top and bottom border of menu tabs
    #Skip this for submenus
    if ! $submenu; then
        ((cursor_pos++))
        tput cup $cursor_pos 0
        #echo -n "│"
        tput cup $cursor_pos $menu_width
        #echo "│"
        ((cursor_pos++))
        tput cup $cursor_pos 0
        draw_line
    fi

    # If rigth panel is on, draw its separator
    if $show_right_panel; then
        cursor_pos=$header_height
        
        if $show_right_panel && $DISPLAY_LINE_CONNECTORS; then
            tput cup $cursor_pos $left_panel_width
            echo "┯"
        fi

        ((cursor_pos++))

        for ((i = 0; i < menu_height; i++)); do
            tput cup $cursor_pos $left_panel_width
            echo "│"
            ((cursor_pos++))
        done
    fi

    cursor_pos=$(($header_height + $menu_height))
    tput cup $cursor_pos 0
    draw_line

    if $show_right_panel && $DISPLAY_LINE_CONNECTORS; then
        tput cup $cursor_pos $left_panel_width
        echo "┷"
    fi

    ((cursor_pos += $(($DESCRIPTOR_HEIGHT + 1))))
    tput cup $cursor_pos 0
    draw_line
    check_for_warnings
    
}

check_for_warnings() {
    if $size_warning; then
        echo -e "\e[01m\e[01;31mSome items migh be trunceted. (Need min.: "$(($MAX_MENU_ITEMS + 13))" chars.)\e[00m"
    fi
    if $right_panel_warning; then
        echo -e "\e[01m\e[01;31mShort terminal: Right-panel and cmd-builder disabled\e[00m"
    fi
}


# Simply write a one line descriptor, as read from the menu file
write_descriptor() { 
    # if [[ $menu_height -lt 8 ]]; then
    #     menu_height=8
    # fi

    # if [[ $menu_height -gt 12 ]]; then
    #     menu_height=12
    # fi

    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2
    echo "${menu_desc_entry[$menu_pos]}"
}

#Simply write a one line descriptor, as read from the menu file
write_help_descriptor() { 
    help_menu_desc_entry[0]="Basic setup and usage guide to Lazy Admin"
    help_menu_desc_entry[1]="In-depth configuration guide"
    help_menu_desc_entry[2]="How to use the command-builder submenu"
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2

    if [[ "$active_panel" == "right" ]]; then
        echo "${menu_desc_entry[$menu_pos]}"
    else
        echo "${help_menu_desc_entry[$menu_pos]}"
    fi
}


# Causes the selector to jump to the "other end" of the menu, if reaching either the top or the bottom
infinite_menu() { 
    if [[ "$active_panel" == "right" ]]; then
        limit=$right_panel_length
    else
        limit=$menu_length
    fi

    if [[ $menu_pos -ge $limit ]]; then
        menu_pos=0
    fi

    if [[ $menu_pos -lt 0 ]]; then
        menu_pos=$(($limit - 1))
    fi
}


infinite_tab() {     
    limit=$(($tab_length + 1))

    if [[ $tab_pos -eq $limit ]]; then
        tab_pos=0
        read_menu_items
        read_descriptor
    fi

    if [[ $tab_pos -lt 0 ]]; then
        tab_pos=$(($limit - 1))
        read_menu_items
        read_descriptor
    fi

}


function_exists() {
    declare -f -F $1 > /dev/null
    return $?
}

###################################
# Movement and menu item handling #
###################################

move_up() {
    #Double jump if run on skip
    if [[ "$active_panel" == "left" ]] && [[ "${menu_entry[$menu_pos - 1]}" == "skip" ]]; then
        ((menu_pos--))
    fi

    #Check for right panel too
    if [[ "$active_panel" == "right" ]] && [[ "${right_panel_entry[$menu_pos - 1]}" == "skip" ]]; then
        ((menu_pos--))
    fi

    ((menu_pos--))
}


move_down() {
    #Double jump if running on skip
    if [[ "$active_panel" == "left" ]] && [[ "${menu_entry[$menu_pos + 1]}" == "skip" ]]; then
        ((menu_pos++))
    fi

    #Chexck for right panel too
    if [[ "$active_panel" == "right" ]] && [[ "${right_panel_entry[$menu_pos + 1]}" == "skip" ]]; then
        ((menu_pos++))
    fi

    ((menu_pos++))
}


tab_left() {
    if ! $submenu && ! $sub_flags_menu && ! $help_submenu; then
        clear_menu
        menu_pos=0
        ((tab_pos--))
    fi
}


tab_right() {
    if ! $submenu && ! $sub_flags_menu && ! $help_submenu; then
        clear_menu
        menu_pos=0
        ((tab_pos++))
    fi
}


select_tab() {
    target_tab=$(($1 - 1))

    if ! $submenu && ! $sub_flags_menu && ! $help_submenu; then
        if [[ $target_tab -eq 0 || $tab_length -ge $target_tab ]]; then
            clear_menu
            menu_pos=0
            tab_pos=$target_tab
        fi
    fi
}

# TODO: Add this to help files too
select_tab_by_number(){
    tabkey=""
    read -sN1 -t 1 tabkey

    if [[ -n $tabkey ]]; then 
        if [[ $tabkey -ge 1 ]] && [[ $tabkey -le 9 ]]; then
            select_tab $tabkey
        fi
    fi
}


# "left", "right" or "swap"
change_panel() {
    case $1 in
    "right")
        if $show_right_panel && [[ "$active_panel" == "left" ]]; then
            active_panel="right"
            menu_pos=0
        fi
        ;;
    "left")
        if $show_right_panel && [[ "$active_panel" == "right" ]]; then
            active_panel="left"
            menu_pos=0
        fi
        ;;
    *)
        if $show_right_panel; then
            if [[ "$active_panel" == "right" ]]; then
                active_panel="left"
                menu_pos=0
            else
                active_panel="right"
                menu_pos=0
            fi
        fi
    esac
}


select_menu_item_by_number() {

    key=$1

    # Only read second digit if it makes sense, otherwise avoid the delay
    read_second_digit=false

    if $submenu && [[ $MAX_SUBMENU_ITEMS -gt 9 ]] && [[ $key -le $(($MAX_SUBMENU_ITEMS / 10)) ]]; then
        if ! $help_submenu; then
            read_second_digit=true
        fi
    elif [[ $MAX_MENU_ITEMS -gt 9 ]] && [[ $key -le $(($MAX_MENU_ITEMS/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi
    is_valid=1
    if [[ $key -le $menu_length ]] && [[ $key -ge 1 ]]; then
        ((key--))
       

        if [[ -z $function_style || $function_style == "old" ]]; then

            if $submenu; then
                subfunct$tab_pos$main_menu_pos$key $tab_pos $menu_pos
            else
                funct$tab_pos$key $tab_pos $menu_pos
            fi

        elif [[ $function_style == "simple" ]]; then

            if $submenu; then
                function_exists tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($key + 1))
                is_valid=$?
                if [[ $is_valid == 0 ]]; then
                    menu_pos=$key
                    tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($key + 1)) $tab_pos $menu_pos
                fi
                
            else
                function_exists tab$(($tab_pos + 1))item$(($key + 1)) && init_menu
                is_valid=$?
                if [[ $is_valid == 0 ]]; then
                    menu_pos=$key
                    tab$(($tab_pos + 1))item$(($key + 1)) $tab_pos $menu_pos
                fi
                
            fi
        fi
    fi
    
    if [[ $is_valid == 0 ]]; then
        q
        init_menu
    fi

}


select_help_menu_item_by_number() {
    key=$1

    if [[ $key -le 3 ]] && [[ $key -ge 0 ]]; then
        ((key--))
        menu_pos=$key
        functhelp$key
    fi
}


select_highlighted_menu_item() {
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else

        if [[ -z $function_style || $function_style == "old" ]]; then

            if $submenu; then
                subfunct$tab_pos$main_menu_pos$menu_pos $tab_pos $menu_pos
            else
                funct$tab_pos$menu_pos $tab_pos $menu_pos
            fi

        elif [[ $function_style == "simple" ]]; then

            if $submenu; then
                tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($menu_pos + 1)) $tab_pos $menu_pos
            else
                tab$(($tab_pos + 1))item$(($menu_pos + 1)) $tab_pos $menu_pos
            fi
        fi
    fi

    init_menu
}


select_highlighted_help_item() {
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else
        functhelp$menu_pos
    fi
    init_menu
}

#########################################
# Command builder specific menu options #
#########################################

set_highlighted_cmb_arg() {
    # If enter is pressed
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else
        max_length_offset=0
        max_cmb_height=$(($MAX_COMMAND_BUILDER_ARGS + 2))
        if [[ $# -gt $max_cmb_height ]]; then
            let lenght_diff=$#-$max_cmb_height
            let max_length_offset=$max_length_offset+$lenght_diff
        fi

        let args_to_set=$#-3-$max_length_offset
        
        if [[ $menu_pos -le "$args_to_set" ]] && [[ $menu_pos -ge 0 ]]; then
            #reference parameters by number according to menu_position
            let add_arg=$menu_pos+3
            set_args=$set_args' '${@:$add_arg:1}
        else
            let manual_flags=$args_to_set+1
            let commit_flags=$args_to_set+2
            let delete_flags=$args_to_set+3

            case $menu_pos in
            $manual_flags)
                cmb_set_manual_args
                ;;
            $commit_flags)
                cmb_commit_with_args
                ;;
            $delete_flags)
                cmb_clear_args
                ;;
            esac
        fi
    fi
}


cmb_set_manual_args() {
    echo
    tput cnorm
    echo "Type your arguments here, and press enter "
    echo
    read -p "> " line_args
    set_args=$set_args$line_args
    tput civis
    clear
    draw_menu

}


cmb_commit_with_args() {
    clear
    echo
    echo "Executing:"
    echo "$submenu_command $set_args"
    echo
    $submenu_command $set_args
    echo
    echo "Now press a key to get back to the menu"
    read -n 1 -s key_press
    sub_flags_menu=false
    back_to_main_menu
}

cmb_clear_args() {
    set_args=''
    clear
    draw_menu
}

cmb_set_arg_by_number() {
    # echo "All arts passed are: $@"
    key=${!#}

    # echo "Key set to: $key"
    # set -- "${@:1:$#-1}"
    read_second_digit=false
    if [[ $MAX_COMMAND_BUILDER_ARGS -gt 9 ]] && [[ $key -le $(($MAX_COMMAND_BUILDER_ARGS/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi
    
    let args_to_set=$#-4
    if [[ $key -le $(($args_to_set + 1)) ]] && [[ $key -ge 0 ]]; then
        ((key += 2))
        set_args=$set_args' '${!key}
    fi
}

# Credit for the previous picking solution (first 5 lines) goes for eMPee584's 
# answer on the thread below:
# http://stackoverflow.com/questions/10679188/casing-arrow-keys-in-bash
#
# It allowed to read both arrow keys and single characters from a keyboard just 
# fine, but has since been replaced.
#
# Credit now goes to:
# https://stackoverflow.com/a/66500309/6078214
#
# This is the simplest way I have fund yet to read all sorts of special keys

pick_menu_item() { 
    
    while true; do
        
        key=""
        keytap=""
        if $AUTO_REFLOW; then
            check_for_size_changes
            size_changed=$?
            if [[ $size_changed -gt 0 ]]; then
                break
            fi

            read -rsN1 -t $tick keytap
        else
            read -rsN1 keytap
        fi
        
        # loop while read can read any additional character and join all of them ## Original comment, left unchanged
        while [ -n "$keytap" ]; 
        do
            key="${key}${keytap}"
            read -sN1 -t 0.0001 keytap
        done

        if [[ -n $key ]]; then 
            # TODO: Update User guide and key binding guide with F1-9 and t-# keys for tabs access and TAB key for changing panels
            case $key in
            $'\e[A' | $'\e0A' | "w" | "W")
                move_up
                ;;
            $'\e[B' | $'\e0B' | "s" | "S")
                move_down
                ;;
            $'\e[D' | $'\e0D' | "a" | "A")
                tab_left
                ;;
            $'\e[C' | $'\e0C' | "d" | "D")
                tab_right
                ;;
            $'\e[11~' | $'\eOP') 
                # F1 - Tab 1
                select_tab 1
                ;;
            $'\e[12~' | $'\eOQ')
                # F2 - Tab 2
                select_tab 2
                ;;
            $'\e[13~' | $'\eOR')
                # F3 - Tab 3
                select_tab 3
                ;;
            $'\e[14~' | $'\eOS') 
                # F4 - Tab 4
                select_tab 4
                ;;
            $'\e[15~')
                # F5 - Tab 5
                select_tab 5
                ;;
            $'\e[17~')
                # F6 - Tab 6
                select_tab 6
                ;;
            $'\e[18~')
                # F7 - Tab 7
                select_tab 7
                ;;
            $'\e[19~') 
                # F8 - Tab 8
                select_tab 8
                ;;
            $'\e[20~')
                # F9 - Tab 9
                select_tab 9
                ;;
            "t" | "T")
                select_tab_by_number
                ;;
            $'\e[1;5C' | $'\e01;5C' | "r" | "R")
                change_panel "right"
                ;;
            $'\e[1;5D' | $'\e01;5D' | "l" | "L")
                change_panel "left"
                ;;
            $'\x09')
                change_panel "swap"
                ;;
            [1-9])
                if $sub_flags_menu; then
                    cmb_set_arg_by_number "$@" $key
                elif $help_submenu; then
                    select_help_menu_item_by_number $key
                else
                    select_menu_item_by_number $key
                fi
                ;;
            $'\x0a' | '')
                # If enter is pressed
                if $sub_flags_menu; then
                    set_highlighted_cmb_arg "$@"
                elif $help_submenu; then
                    select_highlighted_help_item
                else
                    select_highlighted_menu_item
                fi
                ;;
            "f" | "F") 
                reflow_menu
                ;;
            "h" | "H")
                if ! $help_submenu; then
                    display_help
                fi
                ;;
            "k" | "K")
                display_hotkeys
                ;;
            "q" | "Q") #this handles exit function
                functright4
                ;;
            "b" | "B")
                if $help_submenu; then
                    back_to_main_menu "read" "reflow"
                elif $submenu || $sub_flags_menu; then
                    back_to_main_menu
                fi

                return
                ;;
            "e" | "E")
                if ! $submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup0
                    init_menu
                fi
                ;;
            "u" | "U")
                if ! $submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup1
                    init_menu
                fi
                ;;
            "v" | "V")
                if ! $submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup3
                    init_menu
                fi
                ;;
            "m" | "M")
                if $sub_flags_menu; then
                    cmb_set_manual_args
                elif ! $submenu && ! $help_submenu && [[ $tab_pos == $tab_length ]]; then
                    functsetup2
                    init_menu
                fi
                ;;
            "c" | "C")
                if $sub_flags_menu; then
                    cmb_commit_with_args
                fi
                ;;
            "x" | "X")
                if $sub_flags_menu; then
                    cmb_clear_args
                fi
                ;;
        
            esac
            
            break

        elif ! $AUTO_REFLOW; then
            break
        fi
    done
}



# This fnction will
# construct a submenu from the supplied arguments, from which
# the user can interactively build a command
#
# Arguments to supply:
# $1 - Title for the submenu
# $2 - base command to start the chain with. It can already contain preset arguments
# $3 - $11 - arguments to be represented as one of the possible 9 menu items.
#
# The arguments can contain more than one options, if supplied in quotes,
# it will be treated as a sibngle menu entry, such as passing e.g.
#
# "-c 5 --whatever_flag -f 8" as $4,
#
# will make
#
# -c 5 --whatever_flag -f 8
#
# the second menu entry. Selecting it will apply all the flags to the built chain
command_builder_function() { 
    menu_entry=()
    set_args=""

    if $submenu; then
        remain_in_submenu=true
        old_submenu_title="$submenu_title"
        old_tab_pos=$tab_pos
        old_main_menu_pos=$main_menu_pos
    else
        remain_in_submenu=false
    fi

    submenu=true
    sub_flags_menu=true
    sub_flags_menutitle="$1"
    submenu_command="$2"
    submenu_call="${@:3}"
    menu_pos=0

    #Have to empty the arguments each time, as set_submenu_function is not an "object", but just a single instance of a function.
    #Best avoid confusion
    clear
    set_command_builder_items "$@"
    read_rightpanel_items
    draw_menu

    while $sub_flags_menu; do
        set_command_builder_items "$@"
        read_rightpanel_items
        infinite_menu
        write_menu_items

        if $show_right_panel; then
            write_rightpanel_items
        fi

        write_flags_descriptor
        echo
        echo

        # ~~TODO~~: Got to make sure this does not go ovber the screen limit. 
        # 7 years leter: No, that's the user's problem, terminal emulators can be resized
        echo "Active command: "$submenu_command $set_args

        pick_menu_item "$@"

    done

}


#Right panel functions
#this is the standard reflow function

reflow_menu() { 
    clear
    set_menu_sizes
    init_menu
}


display_hotkeys() { 
    display_markdown_help "$RES_DIR/shortkeys.md" "$RES_DIR/shortkeys.txt"
    reflow_menu
}


# Calls the papproropriate help function, either the help submenu
# or the single help file, depending on where the user is
display_help() { 
    if $sub_flags_menu; then
        functhelp_commanbuilder
        reflow_menu
    else
        enter_helpmenu
    fi
}


# Quits Lazy Admin, and restores the cursor, but only if
# not returning from a nested root shell
# (It is possible to run another shell of ladmin form within)
exit_la_menus() { 
    tput cnorm
    clear
    clear
    echo
    echo "$@"
    echo
    exit 0
}


# Misleading function name (TODO:change it)
# It will return to the calling menu, which can be a submenu in case of
# help menu or command builder
back_to_main_menu() { 
    active_panel="left"
    menu_pos=0
    sub_flags_menu=false
    help_submenu=false

    if $remain_in_submenu; then
        submenu=true
        remain_in_submenu=false
        submenu_title="$old_submenu_title"
        tab_pos=$old_tab_pos
        main_menu_pos=$old_main_menu_pos
    else
        submenu=false
    fi

    if [[ $1 == "read" ]]; then
        read_menu_items
        read_descriptor
    fi

    read_rightpanel_items
    clear_menu

    if [[ $2 == "reflow" ]]; then
        reflow_menu
    fi

    return
}


# (Re)draws items of main menu and includes the picker
main_menu() { 
    
    submenu=false
    sub_flags_menu=false

    read_tab_items
    read_menu_items
    read_descriptor
    infinite_menu
    infinite_tab
    write_tab_items
    write_menu_items

    if $show_right_panel; then
        write_rightpanel_items
    fi

    #Write basic description
    write_descriptor
    pick_menu_item
}


# Same as main menu, only this one invokes a submenu.
# decide menu type
submenu() { 

    if [[ $1 != "help" ]]; then
        submenu=true
    fi
   
    sub_flags_menu=false

    if [[ $1 != "help" ]]; then
        read_tab_items
        read_menu_items $1 $2
    fi
    
    read_descriptor $1 $2
    infinite_menu

    if [[ $1 != "help" ]]; then
        write_menu_items
    else
        write_help_menu_items
    fi

    if $show_right_panel; then

        if [[ $1 == "help" ]]; then
            read_help_rightpanel_items
        fi

        write_rightpanel_items
    fi

    if [[ $1 != "help" ]]; then
        write_descriptor
    else
        write_help_descriptor
    fi

    pick_menu_item
}




# Initialise a menu, before drawing for the foirst timed
# Will set menu item and title variable
init_menu() {     
    if [[ "$(whoami)" != "root" ]]; then
        root=false
    else
        root=true
    fi

    clear
    if [[ $1 != "help" ]]; then
        find_menu_type
        read_menu_items $1 $2
    fi
    read_descriptor $2 $2
    
    read_rightpanel_items
    
    draw_menu
}



# This will be called whrn a submenu is selected
enter_submenu() { 
    remain_in_submenu=false
    submenu=true
    submenu_title="$3"
    main_menu_pos="$menu_pos"
    menu_pos=0

    init_menu $1 $2

    while $submenu; do
        submenu $1 $2
    done
}


# This will be called when help menu is selected
enter_helpmenu() { 
    help_submenu=true

    if $submenu; then
        remain_in_submenu=true
        old_submenu_title="$submenu_title"
        old_tab_pos=$tab_pos
        old_main_menu_pos=$main_menu_pos
    else
        remain_in_submenu=false
    fi

    submenu=true
    submenu_title="Help"
    main_menu_pos="$menu_pos"
    menu_pos=0

    init_menu "help"

    while $help_submenu; do
        submenu "help"
    done
}


# Right panel functions. These function aliases are core functionality,
# so not really a part of the user aliases. This coudl change later
# so that users can easily alter right panel
function functright0 { 
    reflow_menu
}


function functright1 { 
    display_help
}


function functright2 { 
    display_hotkeys
}


function functright3 { 
    if [[ $sub_flags_menu ]]; then
        sub_flags_menu=false
    fi

    back_to_main_menu "read"
}


function functright4 { 
    if $root; then
        exit_la_menus "Leaving root shell"
    else
        exit_la_menus "Exiting..."
    fi
}


# Initialises and displays the main menu
# This is what the launcher calls, basically
main() { 
    for ((i = 1; i <= $#; i++)); do
        j=$((i + 1))

        # This can be extended with any number of arguments later, possibly to change defaults on the fly
        case "${!i}" in
        "-j" | "--join-lines")
            if [[ "${!j}" == "off" ]]; then
                DISPLAY_LINE_CONNECTORS=false
            elif [[ "${!j}" == "on" ]]; then
                DISPLAY_LINE_CONNECTORS=true
            fi
            ;;
        *)
            #Do nothing
            ;;
        esac
    done

    init_menu

    while true; do
        main_menu
    done
}

set_up_menus