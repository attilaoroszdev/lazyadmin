#!/bin/bash
#
# Copyright Â© 2017-2025, Attila Orosz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#This file fontains the functions providing basic functionality of the menu system
#Cusom "user functions" will be stored in $USER-DIR/user-function.la


# normal_menu_height=$(( $MAX_MENU_ITEMS + 3 ))
# submenu_height=$(( $MAX_SUBMENU_ITEMS + 3 )) 
# menu_height=0
menus_force_hidden=false
tabs_dont_fit=false
all_tabs_length=0
right_panel_height_warning=false
right_panel_width_warning=false
height_warning=false
normal_menu_height=0
menu_height=0
show_right_panel=$right_panel
max_menu_height=0

declare -a TAB_ITEM_ROWS
declare -a TAB_ITEM_KEYS
declare -a TAB_ITEM_ENTRIES

declare -a MENU_ITEM_ROWS
declare -a MENU_ITEM_ENTRIES
declare -a MENU_ITEM_DESCRIPTIONS
declare -a MENU_ITEM_COMMANDS

declare -a RIGHT_PANEL_ITEM_ROWS
declare -a RIGHT_PANEL_ITEM_KEYS
declare -a RIGHT_PANEL_ITEM_ENTRIES
declare -a RIGHT_PANEL_ITEM_DESCRIPTIONS

declare -i NUMBER_OF_TABS

declare SUBMENU_TITLE=""

# TODO find and declare all global variables here, use `declare`, see https://unix.stackexchange.com/questions/510220/what-is-declare-in-bash
# TODO, all global variables should be UPPER_CASE, 
# TODO Make constants `readonly`
# TODO make local variables really local with the `local` keyword
# TODO remove all the tput things, replace them with locally declared function that uses echo and ANSI escape codes (see notes)
# TODO: When returning to submenu from external function (lkike ncdu), the app title is not printer on the top row
# TODO: Displaying the title shoudl beoptional (able to turn off from user functions, gain two extra rows on very small terminals)
set_menu_sizes() {
    terminal_height=$(tput lines)
    terminal_width=$(tput cols)

    if [[ $terminal_height -lt $MIN_TERMINAL_HEIGHT ]] || [[ $terminal_width -lt $MIN_TERMINAL_WIDTH ]]; then
        menus_force_hidden=true
        show_force_hide_error
    else
        menus_force_hidden=false
        right_panel_height_warning=false
        right_panel_width_warning=false
        height_warning=false
        normal_menu_height=$(( $MAX_MENU_ITEMS + 3 ))

        menu_height=0

        show_right_panel=$right_panel

        if [[ $terminal_height -lt $MIN_TERM_HEIGHT_FOR_R_PANEL ]]; then
            show_right_panel=false
            if $right_panel; then
                right_panel_height_warning=true
            fi
        fi

        if [[ $terminal_width -lt $(($RIGHT_PANEL_WIDTH * 2)) ]]; then
            show_right_panel=false
            if $right_panel; then
                right_panel_width_warning=true
            fi
        fi

        if ! $show_right_panel $$ [[ $active_panel -eq "right" ]]; then
            active_panel="left"
        fi

        max_menu_height=$(($terminal_height - 10))

        # Got to make sure we fit inside whatever size the terminal currently is
        if [[ $normal_menu_height -gt $max_menu_height ]]; then
            normal_menu_height=$max_menu_height
            height_warning=true
        else
            height_warning=false
        fi

       

        if $show_right_panel; then
            
            if [[ $normal_menu_height -lt $MIN_MENU_HEIGHT ]]; then
                normal_menu_height=$MIN_MENU_HEIGHT
            fi

        else
            
            if [[ $normal_menu_height -lt $MIN_MENU_HEIGHT_SINGLE_PANEL ]]; then
                normal_menu_height=$MIN_MENU_HEIGHT_SINGLE_PANEL
            fi

        fi
        
        menu_height=$normal_menu_height
    fi

}

show_force_hide_error() {
    clear
    echo
    echo -n "Cannot display menus on this terminal. If you are in an emulator, you need to resize the window"
    if ! $AUTO_REFLOW; then
        echo -n ", and press 'f' to re-draw the menu; "
    else
        echo -n "; "
    fi
    
    echo -n "or press 'q' to quit."
    echo -e '\n'

    if [[ $terminal_height -lt $MIN_TERMINAL_HEIGHT ]]; then
        echo "Minimum supported height: $MIN_TERMINAL_HEIGHT characters."
        echo -e "Current height: \e[01m\e[091m$terminal_height\e[00m characters"
        echo
    fi
    if [[ $terminal_width -lt $MIN_TERMINAL_WIDTH ]]; then
        echo "Minimum supported width: $MIN_TERMINAL_WIDTH characters."
        echo -e "Current width: \e[01m\e[091m$terminal_width\e[00m characters"
        echo
    fi
}


check_for_size_changes() {
    if [[ $terminal_height -ne $(tput lines) ]] || [[ $terminal_width -ne $(tput cols) ]]; then
        reflow_menu
        return 1
    fi

    return 0
}

set_up_menus() {
    tick=$AUTO_REFLOW_TICK
 
    if [[ -f $menu_file ]]; then
        echo "Setting menus..."
        parse_menu_file
        read_tab_items
        set_menu_sizes     
    else
        clear
        echo
        echo "Looked for menus in:"
        echo $menu_file
        echo
        echo "Error: Cannot find menuentries file in default location. Exiting..."
        echo
        exit 65
    fi
}





set_command_builder_items() {     
    #Parse the argument list into the array, starting form the 3rd argument
    array_offset=2
    array_counter=1

    for i in "$@"; do
 
        if [[ $array_counter -gt $array_offset ]]; then
            if [[ $array_counter -ge $(($max_menu_height - 5)) ]]; then
                break
            fi

            local current_flag_item=$(($array_counter-2))
            menu_entry[$current_flag_item - 1]="$current_flag_item - Set arg. $i"
        
        fi

        ((array_counter++))

    done
    
    local last_entry=""
    
    if [[ -n $menu_entry ]]; then
        last_entry=${menu_entry[${#menu_entry[@]} - 1]}
    fi

    # #Check if entries have already been written, by checking last element
    # if [[ "$last_entry" != "x - Delete set flags" ]]; then
    #     menu_entry+=("m - Enter arguments manually")
    #     menu_entry+=("o - Enter flag-options (no space)")
    #     menu_entry+=("c - Commit with flags")
    #     menu_entry+=("x - Delete set flags")
    # fi

    menu_length=${#menu_entry[@]}
}


write_flags_descriptor() { 
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2
    case ${menu_entry[$menu_pos]} in
    "m - Manually enter flags ")
        echo "Manually enter flags for the command specified"
        ;;
    "c - Commit with flags")
        echo "Finished entering flags, proceed with command"
        ;;
    "x - Delete set flags")
        echo "Clear list of set flags to start over again"
        ;;
    *)
        echo "Set the specified flag"
        ;;
    esac
}


# read descriptor lines for menu items
# years later: I have no idea how sed works any more, so this all looks like magic
read_descriptor() { 
    if [[ -z $menu_type || $menu_type == "old" ]]; then
        
        if $is_submenu; then
            OLDIFS="$IFS"
            IFS=$'\n'

            if [[ "$active_panel" == "right" ]]; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_subrightpaneldesc'/{:a;n;/'_endsubrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_descsubmenu$1$2'/{:a;n;/'_enddescsubmenu$1$2'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        else
            OLDIFS="$IFS"
            IFS=$'\n'

            if [[ "$active_panel" == "right" ]]; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_rightpaneldesc'/{:a;n;/'_endrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_descmenu$tab_pos'/{:a;n;/'_enddescmenu$tab_pos'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        fi

    else

        if [[ "$active_panel" == "right" ]]; then
            for ((n = 0; n < $menu_length; n++)); do
                eval $(echo ${menu_entry[$n]} | sed 's:^:V1=":; /\:\:/ s::";V2=": ;s:$:":')
                menu_entry[$n]="$(echo $V1)"
            done

            OLDIFS="$IFS"
            IFS=$'\n'

            if $is_submenu; then
                menu_desc_entry=($(cat $menu_file | sed -n '/'_subrightpaneldesc'/{:a;n;/'_endsubrightpaneldesc'/q;p;ba}'))
            else
                menu_desc_entry=($(cat $menu_file | sed -n '/'_rightpaneldesc'/{:a;n;/'_endrightpaneldesc'/q;p;ba}'))
            fi

            IFS="$OLDIFS"
        else
            for ((n = 0; n < $menu_length; n++)); do
                eval $(echo ${menu_entry[$n]} | sed 's:^:V1=":; /\:\:/ s::";V2=": ;s:$:":')
                menu_entry[$n]="$(echo $V1)"
                menu_desc_entry[$n]="$(echo $V2)"
            done
        fi
    fi
}


parse_menu_file() {

    local -a menu_file_contents
        
    OLD_IFS=$IFS
    IFS=
    
    while read -r line; do
        if [[ ! "$line" == "#"* ]] && [[ -n "$line" ]]; then
            menu_file_contents+=("$line")
        fi
    done < "$menu_file"

    IFS=$OLD_IFS

    local tab_items_toggle=false
    local menu_items_toggle=false
    local right_menus_toggle=false
      
    for ((n = 0; n <= ${#menu_file_contents[@]}; n++)); do

        if $tab_items_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_tab_order:]" ]]; then
                tab_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                TAB_ITEM_ROWS+=("$tmp")
                unset tmp
                # TAB_ITEM_ROWS+=("${menu_file_contents[$n]}")
                
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:tab_order:]" ]]; then
                tab_items_toggle=true
            fi
        fi

        if $menu_items_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_menu_items:]" ]]; then
                menu_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                MENU_ITEM_ROWS+=("$tmp")
                # MENU_ITEM_ROWS+=("${menu_file_contents[$n]}")
                unset tmp
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:menu_items:]" ]]; then
                menu_items_toggle=true
            fi
        fi

        if $right_menus_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_right_panel_items:]" ]]; then
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                # RIGHT_PANEL_ITEM_ROWS+=("${menu_file_contents[$n]}")
                RIGHT_PANEL_ITEM_ROWS+=("$tmp")
                unset tmp
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:right_panel_items:]" ]]; then
                right_menus_toggle=true
            fi
        fi
    done


}




read_menu_items_OLD() { 
    menu_item=$tab_pos
    sub_parent=$1
    sub_item=$2

    if [[ $menu_type == "simple" ]]; then
        ((menu_item++))
        ((sub_parent++))
        ((sub_item++))
    fi

    menu_entry=""

    if $is_submenu; then
        OLDIFS="$IFS"
        IFS=$'\n'
        menu_entry=($(cat $menu_file | sed -n '/'_submenu$sub_parent$sub_item'/{:a;n;/'_endsubmenu$sub_parent$sub_item'/q;p;ba}'))

        
        if $sub_flags_menu; then
            menu_height=$($submenu_height+1)
            max_menu_length=$(($submenu_height - 2))
        elif $help_submenu; then
            menu_height=$HELP_SUB_MENU_HEIGHT
            max_menu_length=$((HELP_SUB_MENU_HEIGHT - 2))
        else
            menu_height=$submenu_height
            max_menu_length=$(($submenu_height - 3))
        fi

        IFS="$OLDIFS"
    else
        OLDIFS="$IFS"
        IFS=$'\n'
        menu_entry=($(cat $menu_file | sed -n '/'_menu$menu_item'/{:a;n;/'_endmenu$menu_item'/q;p;ba}'))
        menu_height=$normal_menu_height
        max_menu_length=$(($normal_menu_height - 3))
        IFS="$OLDIFS"
    fi
    
    menu_length=${#menu_entry[@]}

}

# Load the items shown in the tab
read_tab_items() {
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    TAB_ITEM_KEYS=()
    TAB_ITEM_ENTRIES=()

    for ((n = 0; n < "${#TAB_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${TAB_ITEM_ROWS[$n]}"

        local key="${current_row[0]}"
        key="${key#"${key%%[![:space:]]*}"}"  # Remove leading whitespace
        key="${key%"${key##*[![:space:]]}"}"  # Remove trailing whitespace

        local title="${current_row[1]}"
        title="${title#"${title%%[![:space:]]*}"}"  # Remove leading whitespace
        title="${title%"${title##*[![:space:]]}"}"  # Remove trailing whitespace

        TAB_ITEM_KEYS+=("$key")
        TAB_ITEM_ENTRIES+=("$title")
    done

    IFS="$OLD_IFS"
    NUMBER_OF_TABS=$((${#TAB_ITEM_ENTRIES[@]} - 1))

    # No more than 9 tabs for now. Don't ask why, I cannot remember
    if [[ $NUMBER_OF_TABS -gt 9 ]]; then
        for ((i = 10; i < $NUMBER_OF_TABS + 1; i++)); do
            unset "TAB_ITEM_KEYS[$i]"
            unset "TAB_ITEM_ENTRIES[$i]"
        done

        NUMBER_OF_TABS=9
    fi

}



read_submenu_items(){
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=1

    MENU_ITEM_ENTRIES=()
    MENU_ITEM_DESCRIPTIONS=()
    MENU_ITEM_COMMANDS=()

    local tab_key="$1"
    local submenu_position=$2
    local submenu_toggle=false

    local -i idx=1

    for ((n = 0; n < "${#MENU_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${MENU_ITEM_ROWS[$n]}"
        
        if $submenu_toggle; then
            local sub_key="${current_row[0]}"
            sub_key="${sub_key#"${sub_key%%[![:space:]]*}"}"  # Remove leading whitespace
            sub_key="${sub_key%"${sub_key##*[![:space:]]}"}"  # Remove trailing whitespace
        
            if [[ "$sub_key" == "--" ]]; then
                add_row_to_menu_items $idx "${current_row[@]}"
                ((idx++))
            else
                break
            fi

        elif [[ $tab_key == "${TAB_ITEM_KEYS[$tab_pos]}" ]] || [[ $tab_key == "${TAB_ITEM_ENTRIES[$tab_pos]}" ]]; then
            submenu_toggle=true
            ((n+=$submenu_position-1))
            continue
        fi

    done

    IFS="OLD_IFS"

     menu_length=${#MENU_ITEM_ENTRIES[@]}

    
}

read_menu_items() {
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=1

    MENU_ITEM_ENTRIES=()
    MENU_ITEM_DESCRIPTIONS=()
    MENU_ITEM_COMMANDS=()

    for ((n = 0; n < "${#MENU_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${MENU_ITEM_ROWS[$n]}"

        local tab_key="${current_row[0]}"
        tab_key="${tab_key#"${tab_key%%[![:space:]]*}"}"  # Remove leading whitespace
        tab_key="${tab_key%"${tab_key##*[![:space:]]}"}"  # Remove trailing whitespace

        if [[ $tab_key == "${TAB_ITEM_KEYS[$tab_pos]}" ]] || [[ $tab_key == "${TAB_ITEM_ENTRIES[$tab_pos]}" ]]; then
            add_row_to_menu_items $idx "${current_row[@]}"
            ((idx++))
        fi 
    done

    IFS="$OLD_IFS"

    menu_height=$normal_menu_height
    max_menu_length=$(($normal_menu_height - 3))
    menu_length=${#MENU_ITEM_ENTRIES[@]}

}

add_row_to_menu_items() {
    local -i idx=$1
    shift
    local -a curent_row="$@"

    local menu_item="${current_row[1]}"
    menu_item="${menu_item#"${menu_item%%[![:space:]]*}"}"
    menu_item="${menu_item%"${menu_item##*[![:space:]]}"}"

    local description="${current_row[2]}"
    description="${description#"${description%%[![:space:]]*}"}"
    description="${description%"${description##*[![:space:]]}"}"

    local command="${current_row[3]}"
    command="${command#"${command%%[![:space:]]*}"}"
    command="${command%"${command##*[![:space:]]}"}"
    
    if [[ $menu_item == "skip" ]]; then
        MENU_ITEM_ENTRIES+=("skip")
        MENU_ITEM_DESCRIPTIONS+=("")
        MENU_ITEM_COMMANDS+=("")
    else
        MENU_ITEM_ENTRIES+=("$idx - $menu_item")
        MENU_ITEM_DESCRIPTIONS+=("$description")
        MENU_ITEM_COMMANDS+=("$command")


    fi

}

read_rightpanel_items() {    
    local menu_type_key

    if $sub_flags_menu; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi    

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"

    RIGHT_PANEL_ITEM_KEYS=()
    RIGHT_PANEL_ITEM_ENTRIES=()
    RIGHT_PANEL_ITEM_DESCRIPTIONS=()
    
    for ((n = 0; n < "${#RIGHT_PANEL_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${RIGHT_PANEL_ITEM_ROWS[$n]}"

        local menu_type="${current_row[0]}"
        menu_type="${menu_type#"${menu_type%%[![:space:]]*}"}"  # Remove leading whitespace
        menu_type="${menu_type%"${menu_type##*[![:space:]]}"}"  # Remove trailing whitespace
       
        local shortkey="${current_row[1]}"
        shortkey="${shortkey#"${shortkey%%[![:space:]]*}"}"
        shortkey="${shortkey%"${shortkey##*[![:space:]]}"}"
       
        local menu_item="${current_row[2]}"
        menu_item="${menu_item#"${menu_item%%[![:space:]]*}"}"
        menu_item="${menu_item%"${menu_item##*[![:space:]]}"}"
       
        local description="${current_row[3]}"
        description="${description#"${description%%[![:space:]]*}"}"
        description="${description%"${description##*[![:space:]]}"}"

        local should_skip=false
    
        if  [[ "$menu_type" == "$menu_type_key" ]]; then  
           
            if [[ "$shortkey" == "skip" ]]; then
                should_skip=true
            elif [[ "$shortkey" == "b" ]] && ! $is_submenu; then
                should_skip=true
            elif [[ "$shortkey" == "h" ]] && $help_submenu; then
                should_skip=true
            fi

            if $should_skip; then
                RIGHT_PANEL_ITEM_KEYS+=("skip")
                RIGHT_PANEL_ITEM_ENTRIES+=("")
                RIGHT_PANEL_ITEM_DESCRIPTIONS+=("")
            else
                RIGHT_PANEL_ITEM_KEYS+=("$shortkey")
                RIGHT_PANEL_ITEM_ENTRIES+=("$shortkey - $menu_item")
                RIGHT_PANEL_ITEM_DESCRIPTIONS+=("$description")
            fi
        fi
    done

    IFS=$OLD_IFS
}


read_help_rightpanel_items() {     
    OLDIFS="$IFS"
    IFS=$'\n'
    right_panel_entry=($(cat $menu_file | sed -n '/'_helprightpanel'/{:a;n;/'_endhelprightpanel'/q;p;ba}'))
    IFS="$OLDIFS"
    right_panel_length=${#right_panel_entry[@]}
}


#Display the menu tabs
write_tab_items() {  
    tabs_dont_fit=false
    local current_tabs_length=0
    displayed_tab_entries=1

    all_tabs_length=0 #TODO:Global

    for ((n = 0; n <= $NUMBER_OF_TABS; n++)); do
        all_tabs_length=$(($all_tabs_length + ${#TAB_ITEM_ENTRIES[$n]} + 3))
    done

    ((all_tabs_length++))

    # Make sure tabs will fit
    for ((n = 0; n <= $NUMBER_OF_TABS; n++)); do
        current_tabs_length=$(($current_tabs_length + ${#TAB_ITEM_ENTRIES[$n]} + 3))
        if [[ $current_tabs_length -ge $terminal_width ]]; then
            tabs_dont_fit=true
            ((displayed_tab_entries--))
             if [[ $tab_pos -ge $displayed_tab_entries ]]; then
                select_tab $displayed_tab_entries
                reflow_menu
            fi
            break
        fi
        ((displayed_tab_entries++))
    done

    # Display joints if on, but not for the last item
    if $DISPLAY_LINE_CONNECTORS; then
        horizontal_connector_position=0

        tput cup $((header_height - 2)) $horizontal_connector_position

        for ((n = 0; n < $(($displayed_tab_entries - 2)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#TAB_ITEM_ENTRIES[$n]} + 3))
            tput cup $((header_height - 2)) $horizontal_connector_position
            echo -n "â¯"
        done
    fi

    # Then write out the tab items, with separators
    clear_line $((header_height - 1)) 1 "right"
    tput cup $((header_height - 1)) 1
    
    for ((n = 0; n < $displayed_tab_entries; n++)); do
       
        if [[ $n -eq $tab_pos ]]; then
            echo -n -e "\e[00;30;47m ${TAB_ITEM_ENTRIES[$n]} \e[00m"
        else
            echo -n " ${TAB_ITEM_ENTRIES[$n]} "
        fi

        # Do not write separator after last item
        if [[ $n -lt $NUMBER_OF_TABS ]]; then
            echo -n "â"
        fi       
    
    done

    if $DISPLAY_LINE_CONNECTORS; then
        # Then draw connectors ont he bottom line, but not for the last item
        horizontal_connector_position=0
        tput cup $((header_height)) $horizontal_connector_position

        for ((n = 0; n < $(($displayed_tab_entries - 2)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#TAB_ITEM_ENTRIES[$n]} + 3))
            tput cup $((header_height)) $horizontal_connector_position

            if $show_right_panel && [[ $horizontal_connector_position == $(($menu_width - $active_right_panel_width)) ]]; then
                echo -n "â¿"
            else
                echo -n "â·"
            fi
        done
    fi

    if $tabs_dont_fit; then
        tput cup $((header_height - 2)) $(($terminal_width-1)) 
        # echo -e "\e[091mmâ\e[0m"
        echo -e "\e[091mâ\e[0m"
        tput cup $((header_height - 1)) $(($terminal_width-1))
        echo -e "\e[091mâ\e[0m"
        tput cup $((header_height)) $(($terminal_width-1))
        # echo -e "\e[01m\e[091mâ\e[00m"
        echo -e "\e[091mâ\e[0m"
    fi

    check_for_warnings
}


write_menu_items() { 
    # Write out the menu items one by one
    # If the position is right, it changes the background.
    max_entry_lenght=$(($left_panel_width - 4))
    max_menu_length=$(($normal_menu_height - 3))

    for ((n = 0; n < $max_menu_length; n++)); do

        if [[ ! "${MENU_ITEM_ENTRIES[$n]}" == "skip" ]]; then
         
            local menu_item_line=$(truncate_text "${MENU_ITEM_ENTRIES[$n]}" $max_entry_lenght)

            tput cup $(($n + $header_height + 2)) 2

            if [[ $n -eq $menu_pos ]] && [[ "$active_panel" == "left" ]]; then
                echo -e "\e[00;30;47m$menu_item_line\e[00m"
            else
                echo "$menu_item_line"
            fi
        fi

    done

    local -i line_offset=3

    if $sub_flags_menu; then
        line_offset=4
    fi

    tput cup $(($max_menu_length + $header_height + $line_offset)) 1

    # If the item list was truncated, display a visual clue at the bottom
    if [[ $menu_length -gt $max_menu_length ]]; then
        for ((i = 0; i < $(($left_panel_width-2)); i++)); do
            echo -en "\e[01m\e[091mâ\e[00m"
        done
    else
        # Reset normal line, otherwise
        for ((i = 0; i < $(($left_panel_width-2)); i++)); do
            echo -n "â"
        done
    fi

    write_descriptor
}


# Simply write a one line descriptor, as read from the menu file
write_descriptor() { 
    local descriptor_line
    
    if [[ $active_panel == "right" ]]; then
        descriptor_line=$(truncate_text "${RIGHT_PANEL_ITEM_DESCRIPTIONS[$menu_pos]}" $(($terminal_width-4)))
    else
        descriptor_line=$(truncate_text "${MENU_ITEM_DESCRIPTIONS[$menu_pos]}" $(($terminal_width-4)))
    fi

    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2
    echo "$descriptor_line"
}

# Populate the drawn menu template with the menu items
write_menu_items_OLD() { 
    
    # As the variable does not get modified, this needs no resetting

    max_entry_lenght=$(($left_panel_width - 4))

    for ((n = 0; n < $max_menu_length; n++)); do

        if [[ ! "${menu_entry[$n]}" == "skip" ]]; then
         
            menu_item_line=$(truncate_text "${menu_entry[$n]}" $max_entry_lenght)

            tput cup $(($n + $header_height + 2)) 2

            if [[ $n -eq $menu_pos ]] && [[ "$active_panel" == "left" ]]; then
                echo -e "\e[00;30;47m$menu_item_line\e[00m"
            else
                echo "$menu_item_line"
            fi
        fi

    done

    local -i line_offset=3

    if $sub_flags_menu; then
        line_offset=4
    fi

    tput cup $(($max_menu_length + $header_height + $line_offset)) 1

    # If the item list was truncated, display a visual clue at the bottom
    if [[ $menu_length -gt $max_menu_length ]]; then
        for ((i = 0; i < $(($left_panel_width-2)); i++)); do
            echo -en "\e[01m\e[091mâ\e[00m"
        done
    else
        # Reset normal line, otherwise
        for ((i = 0; i < $(($left_panel_width-2)); i++)); do
            echo -n "â"
        done
    fi

    cursor_pos=$(tput lines)
    tput cup $cursor_pos 0
}


# This is hardcoded for now.
# Might gonna get its own resource file in a future release
# TODO Move these into a help-entries file, or something
write_help_menu_items() { 
    menu_length=3
    help_menu_entry[0]="1 - Lazy Admin usage guide"
    help_menu_entry[1]="2 - Configuration and scripting guide"
    help_menu_entry[2]="3 - Command builder usage guide"

    max_entry_lenght=$(($left_panel_width - 4))

    for ((n = 0; n < $menu_length; n++)); do
                
        if [[ "${help_menu_entry[$n]}" == "skip" ]]; then
            ((n++))
        fi

        help_item_line=$(truncate_text "${help_menu_entry[$n]}" $max_entry_lenght)
        tput cup $((n + $header_height + 2)) 2

        if [[ $n -eq $menu_pos ]] && [[ "$active_panel" == "left" ]]; then
            echo -e "\e[00;30;47m$help_item_line\e[00m"
        else
            echo "$help_item_line"
        fi

    done
}


write_rightpanel_items() { 
    local menu_type_key
    # clear_right_panel

    if $sub_flags_menu; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi  
    
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
     
    for ((n = 0; n < ${#RIGHT_PANEL_ITEM_ENTRIES[@]}; n++)); do
        local shortkey="${RIGHT_PANEL_ITEM_KEYS[$n]}"

        if [[ "$shortkey" == "skip" ]]; then
            continue
        elif [[ "$shortkey" == "---" ]]; then
            tput cup $(($n + $header_height +2)) $(($menu_width - $active_right_panel_width))
            draw_divider_line $active_right_panel_width "right"
            continue
        else
            tput cup $(($n + $header_height + 2)) $(($menu_width - $active_right_panel_width + 3))
            local current_item="${RIGHT_PANEL_ITEM_ENTRIES[$n]}"
            current_item=$(truncate_text "$current_item" $(($active_right_panel_width-4)))

            if [[ $n == $menu_pos ]] && [[ "$active_panel" == "right" ]]; then
                echo -e "\e[00;30;47m$current_item\e[00m"
            else
                echo -e "$current_item"
            fi
        fi
    done

    IFS=$OLD_IFS
    
    write_descriptor
}

 write_right_panel_descriptor() { 
    
    local menu_type_key
    
    if $sub_flags_menu; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi    

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=0

    local -a rp_item_descriptions=()
    for item in "${RIGHT_PANEL_ITEM_ROWS[@]}"; do

        local -a current_row
        read -ra current_row <<< "$item"

        local menu_type=${current_row[0]}
        local description=${current_row[6]}

        if [[ "$menu_type" == "$menu_type_key" ]]; then  
            rp_item_descriptions+=("$description")
        fi
    done

    IFS=$OLD_IFS

    descriptor_line=$(truncate_text "${rp_item_descriptions[$menu_pos]}" $(($terminal_width-4)))
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2
    echo "$descriptor_line"
}
                      


#Draws a line
draw_line() { 
    local -i line_lenght=$menu_width

    if [[ -n $1 ]] && [[ $1 -gt 0 ]] then
        line_lenght=$1
    fi

    for ((i = 0; i < $line_lenght; i++)); do
        echo -n "â"
    done
}

draw_divider_line() {
    local -i line_lenght

    if [[ $2 -eq "right" ]]; then
        line_lenght=$(($active_right_panel_width-1))
    else
        if $show_right_panel; then
            line_lenght==$(($left_panel_width-1))
        else
            line_lenght==$menu_width
        fi
    fi

    if [[ $2 -eq "right" ]]; then
        echo -n "â"
    fi

    for ((i = 0; i < $(($line_lenght-1)); i++)); do
        echo -n "â¶"
    done
    echo "â¶"

    # if [[ $2 -eq "left" ]] && $show_right_panel; then
    #     echo -n "â¤"
    # fi


}


#clear menu area
clear_menu() { 
    # echo "Clear menu called"
    for ((n = 1; n < $menu_height; n++)); do
        clear_line $((n + $header_height)) $(($menu_width - $active_right_panel_width - 1)) "left"
    done

    # echo "Menu cleared"
    # sleep 5
}

clear_right_panel() {
    for ((n = 0; n < (($menu_height-2)); n++)); do
        clear_line $((n + $header_height +2)) $(($menu_width - $active_right_panel_width + 1)) "right"
    done
}

# Usage clear_line $line_number $from_column "left|right"
clear_line() {

    if [[ $# -lt 3 ]]; then
        return 65
    fi

    line_number=$1
    from_column=$2
    direction=$3

    tput cup $line_number $from_column
    if [[ $direction == "left" ]]; then
        echo -e "\e[1K"
    else
        echo -e "\e[K"
    fi 
}

#Draws the outline of the menu, with spaces left out for inclusion of items
draw_menu() {

    if $menus_force_hidden; then
        show_force_hide_error
        return 1
    fi
    
    tput civis

    menu_height=$normal_menu_height
    header_height=$MAIN_HEADER_HEIGHT

    if $sub_flags_menu; then
        title=$sub_flags_menutitle
    else
        if $is_submenu; then
            title=$submenu_title
        else
            title=$MAIN_TITLE
        fi
    fi

    if $root; then
        title=$title$ROOT_TITLE
    fi

    ## Set width of screen and panels
    menu_width=($(tput cols) - 1)

    if ! $show_right_panel; then
        active_right_panel_width=0
    else
        active_right_panel_width=$RIGHT_PANEL_WIDTH
    fi

    left_panel_width=$(($menu_width - $active_right_panel_width))
    
    #clear menu area. Should be done each time tabs or submenus are changed
    clear_menu
    cursor_pos=0
    tput cup $cursor_pos 0
    draw_line
    ((cursor_pos++))
    tput cup $cursor_pos $((menu_width / 2 - (${#title} / 2)))

    
    if [[ "$root" != "true" ]]; then
        # Print it in bold
        echo -e "\e[01m$title\e[00m"
    else
        # Print it in bold and red
        echo -e "\e[01m\e[091m$title\e[00m"
    fi

    ((cursor_pos++))
    draw_line

    #Draw top and bottom border of menu tabs
    #Skip this for submenus
    # if ! $is_submenu; then
    ((cursor_pos+=2))
    tput cup $cursor_pos 0
    draw_line
    # fi

    # If rigth panel is on, draw its separator
    if $show_right_panel; then
        cursor_pos=$header_height
        
        if $show_right_panel && $DISPLAY_LINE_CONNECTORS; then
            tput cup $cursor_pos $left_panel_width
            echo "â¯"
        fi

        ((cursor_pos++))

        for ((i = 0; i < menu_height; i++)); do
            tput cup $cursor_pos $left_panel_width
            echo "â"
            ((cursor_pos++))
        done
    fi

    cursor_pos=$(($header_height + $menu_height))
    tput cup $cursor_pos 0
    draw_line

    if $show_right_panel && $DISPLAY_LINE_CONNECTORS; then
        tput cup $cursor_pos $left_panel_width
        echo "â·"
    fi

    ((cursor_pos += $(($DESCRIPTOR_HEIGHT + 1))))
    tput cup $cursor_pos 0
    draw_line
    check_for_warnings
    
}

check_for_warnings() {
    warning_position=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT + 2))
    clear_line $warning_position 0 "right"
    clear_line $(($warning_position + 1)) 0 "right"
    msg=""
    if $height_warning || $tabs_dont_fit; then
        menus_label=""
        tabs_label=""
        min_height_msg=""
        min_width_msg=""

        if $height_warning; then
            min_height_msg=" Min. H: "$(($MAX_MENU_ITEMS + 13))" ch."
            menus_label="Menus "
        fi

        if $tabs_dont_fit; then
            min_width_msg=" Min. W: "$all_tabs_length" ch"
            if $height_warning; then
                tabs_label="and tabs "
            else
                tabs_label="Tabs "
            fi
        fi

        msg="$menus_label$tabs_label""won't fit.$min_height_msg$min_width_msg"
        warning_msg=$(truncate_text "$msg" $(($terminal_width-4)))
        tput cup $warning_position 0
        echo -e "\e[01m\e[091m$warning_msg\e[00m"
        ((warning_position++))
        msg=""    
    fi

    if $right_panel_height_warning; then
        msg="Right-panel and cmd-builder disabled. Min. H: $MIN_TERM_HEIGHT_FOR_R_PANEL ch."
    elif $right_panel_width_warning; then
        msg="Right-panel disabled. Min. W: "$(($RIGHT_PANEL_WIDTH * 2))" ch."
    fi

    if [[ -n "$msg" ]]; then
        warning_msg=$(truncate_text "$msg" $(($terminal_width-4)))
        tput cup $warning_position 0
        echo -e "\e[01m\e[091m$warning_msg\e[00m"
    fi

}

truncate_text(){
    text=$1
    max_lenght=$2

    if [[ ${#text} -gt $max_lenght ]]; then
        text="${text:0:$(($max_lenght - 3))}..."
    fi

    echo "$text"
}


#Simply write a one line descriptor, as read from the menu file
write_help_descriptor() { 
    help_menu_desc_entry[0]="Basic setup and usage guide to Lazy Admin"
    help_menu_desc_entry[1]="In-depth configuration guide"
    help_menu_desc_entry[2]="How to use the command-builder submenu"
    
    cursor_pos=$(($header_height + $menu_height + $DESCRIPTOR_HEIGHT))
    help_descriptor_line=$(truncate_text "${help_menu_desc_entry[$menu_pos]}" $(($terminal_width-4)))

    tput cup $cursor_pos $menu_width
    echo -e "\033[1K"
    tput cup $cursor_pos 2

    if [[ "$active_panel" == "right" ]]; then
        echo "${menu_desc_entry[$menu_pos]}"
    else
        echo "$help_descriptor_line"
    fi
}





infinite_tab() {     
    limit=$(($displayed_tab_entries - 1))

    if [[ $limit -lt $NUMBER_OF_TABS ]]; then
       ((limit++))
    fi

    if [[ $tab_pos -eq $limit ]]; then
        tab_pos=0
        # read_menu_items
        read_descriptor
    fi

    if [[ $tab_pos -lt 0 ]]; then
        tab_pos=$(($limit - 1))
        # read_menu_items
        read_descriptor
    fi

}



###################################
# Movement and menu item handling #
###################################

move_up() {
    #Double jump if run on skip
    if [[ "$active_panel" == "left" ]] && [[ "${MENU_ITEM_ENTRIES[$menu_pos - 1]}" == "skip" ]]; then
        ((menu_pos--))
    fi

    # Alo in right panel
    if [[ "$active_panel" == "right" ]]; then 
        while [[ "${RIGHT_PANEL_ITEM_KEYS[$menu_pos - 1]}" == "skip" ]] || [[ "${RIGHT_PANEL_ITEM_KEYS[$menu_pos - 1]}" == "---" ]]; do
           ((menu_pos--))
        done
    fi

    ((menu_pos--))
    infinite_menu
    if [[ "$active_panel" == "left" ]]; then
        write_menu_items
    else
        write_rightpanel_items
    fi
}


move_down() {
    #Double jump if running on skip
    if [[ "$active_panel" == "left" ]] && [[ "${MENU_ITEM_ENTRIES[$menu_pos + 1]}" == "skip" ]]; then
        ((menu_pos++))
    fi

    #Chexck for right panel too
    if [[ "$active_panel" == "right" ]]; then 
        while [[ "${RIGHT_PANEL_ITEM_KEYS[$menu_pos + 1]}" == "skip" ]] || [[ "${RIGHT_PANEL_ITEM_KEYS[$menu_pos + 1]}" == "---" ]]; do
           ((menu_pos++))
        done
    fi
    
    ((menu_pos++))
    infinite_menu
    if [[ "$active_panel" == "left" ]]; then
        write_menu_items
    else
        write_rightpanel_items
    fi
}

# Causes the selector to jump to the "other end" of the menu, if reaching either the top or the bottom
infinite_menu() { 
    if [[ "$active_panel" == "right" ]]; then
        limit=${#RIGHT_PANEL_ITEM_KEYS[@]}
    else
        limit=$menu_length
    fi

    if [[ $menu_pos -ge $limit ]]; then
        menu_pos=0
    fi

    if [[ $menu_pos -lt 0 ]]; then
        menu_pos=$(($limit - 1))
    fi
}

tab_left() {
    if ! $is_submenu && ! $sub_flags_menu && ! $help_submenu; then
        clear_menu
        menu_pos=0
        ((tab_pos--))
        infinite_tab
        write_tab_items
        read_menu_items
        write_menu_items
    fi
}


tab_right() {
   
    if ! $is_submenu && ! $sub_flags_menu && ! $help_submenu; then
        clear_menu
        menu_pos=0
        ((tab_pos++))

        infinite_tab
        write_tab_items
        read_menu_items
        write_menu_items
    fi
    

}


select_tab() {
    target_tab=$(($1 - 1))
    if [[ $target_tab -lt $displayed_tab_entries ]]; then
        if ! $is_submenu && ! $sub_flags_menu && ! $help_submenu; then
            if [[ $target_tab -eq 0 || $NUMBER_OF_TABS -ge $target_tab ]]; then
                clear_menu
                menu_pos=0
                tab_pos=$target_tab
                read_menu_items
                write_menu_items

            fi
        fi
    fi
}

# TODO: Add this to help files too
select_tab_by_number() {
    tabkey=""
    read -sN1 -t 1 tabkey

    if [[ -n $tabkey ]]; then 
        if [[ $tabkey -ge 1 ]] && [[ $tabkey -le 9 ]]; then
            select_tab $tabkey
        fi
    fi
}


# "left", "right" or "swap"
change_panel() {
    case $1 in
    "right")
        if $show_right_panel && [[ "$active_panel" == "left" ]]; then
            active_panel="right"
            menu_pos=0
        fi
        ;;
    "left")
        if $show_right_panel && [[ "$active_panel" == "right" ]]; then
            active_panel="left"
            menu_pos=0
        fi
        ;;
    *)
        if $show_right_panel; then
            if [[ "$active_panel" == "right" ]]; then
                active_panel="left"
                menu_pos=0
            else
                active_panel="right"
                menu_pos=0
            fi
        fi
    esac

    write_menu_items
    write_rightpanel_items
}

toggle_right_panel() {
    if $right_panel; then
        right_panel=false

    else
        right_panel=true
    fi
    show_right_panel=$right_panel
    reflow_menu
}


check_and_run(){
        local is_valid=false
        local is_navigation=false
        local delayed_return=false
        local validate_first=false
        local clear_before_running=false

        local command_item="$1"
        local command_function=""
        local command_args=""

        while true; do
            if [[ "$command_item" =~ " " ]]; then
                command_function="${command_item%% *}"

                if [[ "$command_function" == "/c" ]]; then
                    clear_before_running=true
                    command_item="${command_item:3}"
                    continue
                elif [[ "$command_function" == "/d" ]]; then
                    delayed_return=true
                    command_item="${command_item:3}"
                    continue
                elif [[ "$command_function" == "/v" ]]; then
                    
                    validate_first=true
                    command_item="${command_item:3}"
                    continue
                else
                    command_args="${command_item#* }"
                    break
                fi

            else
                command_function="$command_item"
                command_args=""
                break
            fi
        done
        
        is_valid=true
      
        case "$command_function" in
            "enter_submenu")
                is_navigation=true
                ;;
            "back_to_main_menu")
                is_navigation=true
                ;;
            "command_builder_function")
                is_navigation=true
                ;;
        esac

        if $validate_first && ! $is_navigation; then
            is_valid=false
            if [[ $(validate_item $command_function) == 0 ]]; then
                is_valid=true
            else
                clear
                echo 
                echo "The specified command: '$command_function' is not a valid function or package name"
                echo
                return_to_menu
            fi
        fi

        if $is_valid; then

            if $clear_before_running; then
                clear
            fi

            if [[ -n "$command_args" ]]; then
                eval "$command_function $command_args"
            else
                "$command_function"
            fi      

            if $delayed_return; then
                is_valid=false
                return_to_menu
            fi

        fi

        if $is_navigation || ! $is_valid; then
            return 65
        else
            return 0
        fi
    
}


select_menu_item_by_number() {

    local key=$1

    # Only read second digit if it makes sense, otherwise avoid the delay
    read_second_digit=false

    if [[ $MAX_MENU_ITEMS -gt 9 ]] && [[ $key -le $(($MAX_MENU_ITEMS/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi

    local is_valid=1
    ((key--))

    if [[ -n "${MENU_ITEM_COMMANDS[$key]}" ]]; then
        menu_pos=$key

        check_and_run "${MENU_ITEM_COMMANDS[$key]}"
        is_valid=$?

    elif [[ $key -le $menu_length ]] && [[ $key -ge 1 ]]; then
       
        if $is_submenu; then
            is_valid=$(function_exists tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($key + 1)))

            if [[ $is_valid == 0 ]]; then
                menu_pos=$key
                tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($key + 1)) $tab_pos $menu_pos
            fi
        else
            is_valid=$(function_exists tab$(($tab_pos + 1))item$(($key + 1)))

            if [[ $is_valid == 0 ]]; then
                menu_pos=$key
                tab$(($tab_pos + 1))item$(($key + 1)) $tab_pos $menu_pos
            fi
        fi
    fi
    

    if [[ $is_valid == 0 ]]; then
        reflow_menu
    fi

}


select_help_menu_item_by_number() {
    key=$1

    if [[ $key -le 3 ]] && [[ $key -ge 0 ]]; then
        ((key--))
        menu_pos=$key
        functhelp$key
    fi
}


select_highlighted_menu_item() {
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else

        local is_valid=1

        if [[ -n "${MENU_ITEM_COMMANDS[(($menu_pos))]}" ]]; then
            check_and_run "${MENU_ITEM_COMMANDS[(($menu_pos))]}"
            is_valid=$?
        else
            if $is_submenu; then
                
                is_valid=$(function_exists tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($menu_pos + 1)))
                if [[ $is_valid == 0 ]]; then
                    tab$(($tab_pos + 1))item$(($main_menu_pos + 1))sub$(($menu_pos + 1)) $tab_pos $menu_pos
                fi
            else
             
                is_valid=$(function_exists tab$(($tab_pos + 1))item$(($menu_pos + 1)))
                if [[ $is_valid == 0 ]]; then
                    tab$(($tab_pos + 1))item$(($menu_pos + 1)) $tab_pos $menu_pos
                fi
            fi
        fi
        
    fi

    if [[ $is_valid == 0 ]]; then
        init_menu
    fi

}


select_highlighted_help_item() {
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else
        functhelp$menu_pos
    fi
    init_menu
}

#########################################
# Command builder specific menu options #
#########################################

set_highlighted_cmb_arg() {
    # If enter is pressed
    if [[ "$active_panel" == "right" ]]; then
        functright$menu_pos
    else
        max_length_offset=0
        max_cmb_height=$MAX_MENU_ITEMS
        if [[ $# -gt $max_cmb_height ]]; then
            let lenght_diff=$#-$max_cmb_height
            let max_length_offset=$max_length_offset+$lenght_diff
        fi

        let args_to_set=$#-3-$max_length_offset
        
        if [[ $menu_pos -le "$args_to_set" ]] && [[ $menu_pos -ge 0 ]]; then
            #reference parameters by number according to menu_position
            let add_arg=$menu_pos+3
            set_args=$set_args' '${@:$add_arg:1}
        else
            let manual_flags=$args_to_set+1
            let option_flags=$args_to_set+2
            let commit_flags=$args_to_set+3
            let delete_flags=$args_to_set+4

            case $menu_pos in
            $manual_flags)
                cmb_set_manual_args
                ;;
            $option_flags)
                cmb_set_manual_args "nospace"
                ;;
            $commit_flags)
                cmb_commit_with_args
                ;;
            $delete_flags)
                cmb_clear_args
                ;;
            esac
        fi
    fi
}


cmb_set_manual_args() {

    local space=" "
    if [[ "$1" -eq "nospace" ]]; then
        space=""
    fi
    echo
    tput cnorm
    echo "Type your parameters here, and press <Enter>"
    read -p "> " line_args
    set_args=$set_args$space$line_args
    tput civis
    clear
    draw_menu

}


cmb_commit_with_args() {
    clear
    echo
    echo "Executing:"
    echo "$submenu_command $set_args"
    echo
    $submenu_command $set_args
    echo
    echo "Now press a key to get back to the menu"
    read -n 1 -s key_press
    sub_flags_menu=false
    back_to_main_menu
}

cmb_clear_args() {
    set_args=''
    clear
    draw_menu
}

cmb_set_arg_by_number() {

    key=${!#}

    read_second_digit=false
    if [[ $MAX_COMMAND_BUILDER_ARGS -gt 9 ]] && [[ $key -le $(($MAX_COMMAND_BUILDER_ARGS/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi
    
    let args_to_set=$#-4
    if [[ $key -le $(($args_to_set + 1)) ]] && [[ $key -ge 0 ]]; then
        ((key += 2))
        set_args=$set_args' '${!key}
    fi
}

# Credit for the previous picking solution (first 5 lines) goes for eMPee584's 
# answer on the thread below:
# http://stackoverflow.com/questions/10679188/casing-arrow-keys-in-bash
#
# It allowed to read both arrow keys and single characters from a keyboard just 
# fine, but has since been replaced.
#
# Credit now goes to:
# https://stackoverflow.com/a/66500309/6078214
#
# This is the simplest way I have fund yet to read all sorts of special keys

pick_menu_item() { 
    
    while true; do
        
        key=""
        keytap=""
        if $AUTO_REFLOW; then
            check_for_size_changes
            size_changed=$?
            if [[ $size_changed -gt 0 ]]; then
                break
            fi

            read -rsN1 -t $tick keytap
        else
            read -rsN1 keytap
        fi
        
        # loop while read can read any additional character and join all of them ## Original comment, left unchanged
        while [ -n "$keytap" ]; 
        do
            key="${key}${keytap}"
            read -sN1 -t 0.0001 keytap
        done

        if [[ -n $key ]]; then 
            # TODO: Update User guide and key binding guide with F1-9 and t-# keys for tabs access and TAB key for changing panels
            case $key in
            $'\e[A' | $'\e0A')
                move_up
                ;;
            $'\e[B' | $'\e0B')
                move_down
                ;;
            $'\e[D' | $'\e0D')
                tab_left
                ;;
            $'\e[C' | $'\e0C')
                tab_right
                ;;
            $'\e[11~' | $'\eOP') 
                # F1 - Tab 1
                select_tab 1
                ;;
            $'\e[12~' | $'\eOQ')
                # F2 - Tab 2
                select_tab 2
                ;;
            $'\e[13~' | $'\eOR')
                # F3 - Tab 3
                select_tab 3
                ;;
            $'\e[14~' | $'\eOS') 
                # F4 - Tab 4
                select_tab 4
                ;;
            $'\e[15~')
                # F5 - Tab 5
                select_tab 5
                ;;
            $'\e[17~')
                # F6 - Tab 6
                select_tab 6
                ;;
            $'\e[18~')
                # F7 - Tab 7
                select_tab 7
                ;;
            $'\e[19~') 
                # F8 - Tab 8
                select_tab 8
                ;;
            $'\e[20~')
                # F9 - Tab 9
                select_tab 9
                ;; 
            $'\e[1;5C' | $'\e01;5C')
                change_panel "right"
                ;;
            $'\e[1;5D' | $'\e01;5D')
                change_panel "left"
                ;;
            $'\x09')
                change_panel "swap"
                ;;
            [a-zA-Z])
                shortkey_command "$key"
                ;;
            [1-9])
                if $sub_flags_menu; then
                    cmb_set_arg_by_number "$@" $key
                elif $help_submenu; then
                    select_help_menu_item_by_number $key
                else
                    select_menu_item_by_number $key
                fi
                ;;
            $'\x0a' | '')
                # If enter is pressed
                if [[ $active_panel == "right" ]]; then
                    shortkey_command ${RIGHT_PANEL_ITEM_KEYS[$menu_pos]}
                else
                    if $sub_flags_menu; then
                        set_highlighted_cmb_arg "$@"
                    elif $help_submenu; then
                        select_highlighted_help_item
                    else
                        select_highlighted_menu_item
                    fi
                fi
                ;;

            esac
            
            break

        elif ! $AUTO_REFLOW; then
            break
        fi
    done
}

shortkey_command(){
    case $1 in
        "r")
            change_panel "right"
            ;;
        "l")
            change_panel "left"
            ;;
        "w")
            move_up
            ;;
       "s")
            move_down
            ;;
       "a")
            tab_left
            ;;
       "d")
            tab_right
            ;;
        "t")
            select_tab_by_number
            ;;
        "R")
            toggle_right_panel
            ;;
        "f") 
            reflow_menu
            ;;
        "h")
            if ! $help_submenu; then
                display_help
            fi
            ;;
        "k")
            display_hotkeys
            ;;
        "q") #this handles exit function
            functright4
            ;;
        "b")
            if $help_submenu; then
                back_to_main_menu "read" "reflow"
            elif $is_submenu || $sub_flags_menu; then
                back_to_main_menu
            fi

            return
            ;;
        "e")
            if ! $is_submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $NUMBER_OF_TABS ]]; then
                functsetup0
                init_menu
            fi
            ;;
        "u")
            if ! $is_submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $NUMBER_OF_TABS ]]; then
                functsetup1
                init_menu
            fi
            ;;
        "v")
            if ! $is_submenu && ! $sub_flags_menu && ! $help_submenu && [[ $tab_pos == $NUMBER_OF_TABS ]]; then
                functsetup3
                init_menu
            fi
            ;;
        "m")
            if $sub_flags_menu; then
                cmb_set_manual_args
            elif ! $is_submenu && ! $help_submenu && [[ $tab_pos == $NUMBER_OF_TABS ]]; then
                functsetup2
                init_menu
            fi
            ;;
        "o")
            if $sub_flags_menu; then
                cmb_set_manual_args "nospace"
            fi
            ;;
        "c")
            if $sub_flags_menu; then
                cmb_commit_with_args
            fi
            ;;
        "x")
            if $sub_flags_menu; then
                cmb_clear_args
            fi
            ;;
    esac

}

# This fnction will
# construct a submenu from the supplied arguments, from which
# the user can interactively build a command
#
# Arguments to supply:
# $1 - Title for the submenu
# $2 - base command to start the chain with. It can already contain preset arguments
# $3 - $11 - arguments to be represented as one of the possible 9 menu items.
#
# The arguments can contain more than one options, if supplied in quotes,
# it will be treated as a sibngle menu entry, such as passing e.g.
#
# "-c 5 --whatever_flag -f 8" as $4,
#
# will make
#
# -c 5 --whatever_flag -f 8
#
# the second menu entry. Selecting it will apply all the flags to the built chain

# TODO: Descriptor is pointless here. Instad, move the active command up in that spot
# TODO: When on right panel, active command should not be displaying, so that right panel descriptors can take over
# TODO: Fix resizing this menu correctly. Size should be dynamic and it shoudl always expand to the maximum extent of the menu or the ternminal, whichever comes first
# TODO the visual truncation warning should also appear here on the bottom line
# ToDo: MOVE THE FIXED ITEMS INTO THE RIGHT PANEL!!!!!!!!! OH YEAH!!!

command_builder_function() { 
    menu_entry=()
    set_args=""

    if $is_submenu; then
        remain_in_submenu=true
        old_submenu_title="$submenu_title"
        old_tab_pos=$tab_pos
        old_main_menu_pos=$main_menu_pos
    else
        remain_in_submenu=false
    fi

    is_submenu=true
    sub_flags_menu=true
    sub_flags_menutitle="$1"
    submenu_command="$2"
    submenu_call="${@:3}"
    menu_pos=0

    #Have to empty the arguments each time, as set_submenu_function is not an "object", but just a single instance of a function.
    #Best avoid confusion
    clear
    set_command_builder_items "$@"
    # read_rightpanel_items
    draw_menu

    read_rightpanel_items

    

    while $sub_flags_menu; do

        if $show_right_panel; then
            write_rightpanel_items
        fi
        set_command_builder_items "$@"
        # read_rightpanel_items
        # infinite_menu
        write_menu_items
        
        tput cup $(($header_height + $menu_height + $DESCRIPTOR_HEIGHT)) 2
        
        # ~~TODO~~: Got to make sure this does not go ovber the screen limit. 
        # 7 years leter: No, that's the user's problem, terminal emulators can be resized
        # 1 Week later: Nah, I got it.

        cmd_msg="Active command: $submenu_command $set_args"
        cmd_msg=$(truncate_text "$cmd_msg" $(($terminal_width-2)))
        echo "$cmd_msg"

        pick_menu_item "$@"

    done

}


#Right panel functions
#this is the standard reflow function

reflow_menu() { 
    clear
    set_menu_sizes
    if ! menus_force_hidden; then
        init_menu "reflow"
    fi
}


display_hotkeys() { 
    display_markdown_help "$RES_DIR/shortkeys.md" "$RES_DIR/shortkeys.txt"
    reflow_menu
}


# Calls the papproropriate help function, either the help submenu
# or the single help file, depending on where the user is
display_help() { 
    if $sub_flags_menu; then
        functhelp_commanbuilder
        reflow_menu
    else
        enter_helpmenu
    fi
}


# Quits Lazy Admin, and restores the cursor, but only if
# not returning from a nested root shell
# (It is possible to run another shell of ladmin form within)
exit_la_menus() { 
    tput cnorm
    clear
    clear
    echo
    echo "$@"
    echo
    exit 0
}


# Misleading function name (TODO:change it)
# It will return to the calling menu, which can be a submenu in case of
# help menu or command builder
back_to_main_menu() { 
    active_panel="left"
    menu_pos=$main_menu_pos
    sub_flags_menu=false
    help_submenu=false

    if $remain_in_submenu; then
        is_submenu=true
        remain_in_submenu=false
        submenu_title="$old_submenu_title"
        tab_pos=$old_tab_pos
        main_menu_pos=$old_main_menu_pos
    else
        is_submenu=false
        write_tab_items
    fi

    read_menu_items
    read_rightpanel_items

    clear_menu
    clear_right_panel
    write_menu_items
    write_rightpanel_items

    if [[ $2 == "reflow" ]]; then
        reflow_menu
    fi

    return
}


# # (Re)draws items of main menu and includes the picker
# main_menu() { 
#     pick_menu_item
# }


# Same as main menu, only this one invokes a submenu.
# decide menu type
submenu() { 
    if ! $menus_force_hidden; then
        if [[ $1 != "help" ]]; then
            is_submenu=true
        fi
    
        sub_flags_menu=false

        if [[ $1 != "help" ]]; then
            read_menu_items $1 $2
        fi
        
        read_descriptor $1 $2
        # infinite_menu

        if [[ $1 != "help" ]]; then
            write_menu_items
        else
            write_help_menu_items
        fi

        if $show_right_panel; then
            write_rightpanel_items
        fi

    fi
    pick_menu_item
}




# Initialise a menu, before drawing for the foirst timed
# Will set menu item and title variable
init_menu() {     
    if [[ "$(whoami)" != "root" ]]; then
        root=false
    else
        root=true
    fi

    clear
    
    if [[ $1 != "help" ]]; then
        if [[ $1 != "reflow" ]]; then
            if $is_submenu; then
                local submenu_pos=($main_menu_pos+1)
                read_submenu_items "${TAB_ITEM_KEYS[$tab_pos]}" "$submenu_pos"
            else
                read_menu_items
            fi
        fi
    fi

    if $is_submenu; then
        write_submenu_title
    fi

    read_rightpanel_items
    draw_menu

    write_tab_items
    write_menu_items
    if $show_right_panel; then
        write_rightpanel_items
    fi
}


write_submenu_title() {
    
    tput cup $((header_height - 2))
    draw_line
    clear_line $((header_height - 1)) 1 "right"
    tput cup $header_height
    draw_line
    tput cup $((header_height - 1)) $((menu_width / 2 - (${#SUBMENU_TITLE} / 2)))
    echo "$SUBMENU_TITLE"
    
}

# This will be called whrn a submenu is selected
enter_submenu() {
    main_menu_pos="$menu_pos"
    menu_pos=0

    if [[ -z "$2" ]]; then
        SUBMENU_TITLE=${MENU_ITEM_ENTRIES[(($1-1))]}
        SUBMENU_TITLE="${SUBMENU_TITLE#* - }"
    else
        SUBMENU_TITLE="$2"
    fi

    is_submenu=true
    remain_in_submenu=false


    read_submenu_items "${TAB_ITEM_KEYS[$tab_pos]}" "$1"
    clear_menu
    clear_right_panel
    write_menu_items
    read_rightpanel_items
    write_rightpanel_items
    write_submenu_title

}


# This will be called when help menu is selected
# TODO: Help menus still need to bne implemented
enter_helpmenu() { 
    help_submenu=true

    if $is_submenu; then
        remain_in_submenu=true
        old_submenu_title="$submenu_title"
        old_tab_pos=$tab_pos
        old_main_menu_pos=$main_menu_pos
    else
        remain_in_submenu=false
    fi

    is_submenu=true
    submenu_title="Help"
    main_menu_pos="$menu_pos"
    menu_pos=0

    init_menu "help"

    if $show_right_panel; then
        write_rightpanel_items
    fi

    while $help_submenu; do
        submenu "help"
    done
}


# Right panel functions. These function aliases are core functionality,
# so not really a part of the user aliases. This coudl change later
# so that users can easily alter right panel
function functright0 { 
    reflow_menu
}


function functright1 { 
    display_help
}


function functright2 { 
    display_hotkeys
}


function functright3 { 
    if [[ $sub_flags_menu ]]; then
        sub_flags_menu=false
    fi

    back_to_main_menu "read"
}


function functright4 { 
    if $root; then
        exit_la_menus "Leaving root shell"
    else
        exit_la_menus "Exiting..."
    fi
}


function_exists() {
    declare -f -F $1 > /dev/null
    echo $?
}

package_exists() {
    if hash "$1" 2>/dev/null; then
        echo 0
    else
        echo 1
    fi

}

validate_item() { 
    if [[ $(function_exists "$1") == 0 ]]; then
        echo 0
    elif [[ $(package_exists "$1") == 0 ]]; then
        echo 0
    else
        echo 65
    fi
}

return_to_menu() { 
    echo
    echo "Press any key to return to menu"
    read -n 1 -s key_press
    clear
    init_menu
}



# Initialises and displays the main menu
# This is what the launcher calls, basically
main() { 
    set_up_menus

    for ((i = 1; i <= $#; i++)); do
        j=$((i + 1))

        # This can be extended with any number of arguments later, possibly to change defaults on the fly
        case "${!i}" in
        "-j" | "--join-lines")
            if [[ "${!j}" == "off" ]]; then
                DISPLAY_LINE_CONNECTORS=false
            elif [[ "${!j}" == "on" ]]; then
                DISPLAY_LINE_CONNECTORS=true
            fi
            ;;
        *)
            #Do nothing
            ;;
        esac
    done

    if ! menus_force_hidden; then
        init_menu
    fi

    while true; do
        pick_menu_item
    done
}


