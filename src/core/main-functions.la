#!/bin/bash
#
# Copyright Â© 2017-2025, Attila Orosz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# This file fontains the functions providing basic functionality of the menu system
# Non-essential functions are in $INSTALL-DIR/plugins/extra-functions
# Custom "user functions" will be stored in $USER-DIR/user-function.la

declare _SAVED_STTY_SETTINGS # Only used if stty is installed
declare GOT_STTY=false
declare MENUS_FORCE_HIDDEN=false
declare TABS_DONT_FIT=false
declare -i ALL_TABS_LENTH=0
declare RIGHT_PANEL_HEIGHT_WARNING=false
declare RIGHT_PANEL_WIDTH_WARNING=false
declare HEIGHT_WARNING=false
declare -i NORMAL_MENU_HEIGHT=0
declare -i MENU_HEIGHT=0
declare -i TERMINAL_HEIGHT
declare -i TERMINAL_WIDTH

declare CMB_COMMAND=""
declare CMB_ARGS=""

declare SHOW_RIGHT_PANEL=$RIGHT_PANEL # Necessary, because it might get temporarilty disabkled when resizing windows
declare -i MAX_MENU_HEIGHT=0

declare -i HEADER_HEIGHT
declare -i FOOTER_HEIGHT

declare REMAIN_IN_SUBMENU=false
declare IS_SETUP_TAB=false
declare -i MENU_ITEMS_COUNT=0
declare -i MIN_TERMINAL_HEIGHT=$BASE_TERMINAL_HEIGHT

declare -a TAB_ITEM_ROWS
declare -a TAB_ITEM_KEYS
declare -a TAB_ITEM_ENTRIES

declare -a MENU_ITEM_ROWS
declare -a SYSTEM_MENU_ITEM_ROWS

declare -a MENU_ITEM_ENTRIES
declare -a MENU_ITEM_DESCRIPTIONS
declare -a MENU_ITEM_COMMANDS

declare -a RIGHT_PANEL_ITEM_ROWS
declare -a RIGHT_PANEL_ITEM_KEYS
declare -a RIGHT_PANEL_ITEM_ENTRIES
declare -a RIGHT_PANEL_ITEM_DESCRIPTIONS

declare -i NUMBER_OF_TABS
declare -i MENU_LENGTH
declare -i DISPLAYED_TAB_ENTRIES

declare SUBMENU_TITLE=""
declare OLD_SUBMENU_TITLE=""
declare -i OLD_TAB_POS=0
declare -i OLD_MAIN_MENU_POS=0
declare -i MAIN_MENU_POS=0



declare -i CURSOR_POS=0



declare -i MAX_MENU_LENGTH=0
declare -i MENU_WIDTH=0
declare -i LEFT_PANEL_WIDTH=0
declare -i ACTIVE_RIGHT_PANEL_WIDTH=0


declare IS_SUBMENU=false
declare IS_SUB_FLAGS_MENU=false
declare IS_HELP_SUBMENU=false

declare IS_ROOT=false


# TODO: If right panel is turned off, the minimal RP with commands should still show in cmb, but only that.
# TODO: If it right panel won't fit, cmb shoudl only give an error

# TODO: Cmb: Allow running cmb predefined function or cmb argument list. First check if predefined function exists, and if it does, get args from it,

# TODO: No line connectors should also affect right menu separator


set_menu_sizes() {
    TERMINAL_HEIGHT=$(t_put lines)
    TERMINAL_WIDTH=$(t_put cols)
    
    MIN_TERMINAL_HEIGHT=$BASE_TERMINAL_HEIGHT

    MIN_TERM_HEIGHT_FOR_R_PANEL=$(($MIN_TERMINAL_HEIGHT+1))
    MENU_WIDTH=$(($(t_put cols) - 1))
    if [[ $MIN_TERM_HEIGHT_FOR_R_PANEL < 13 ]]; then
        MIN_TERM_HEIGHT_FOR_R_PANEL=13
    fi


    if $SHOW_HEADER; then
        ((MIN_TERMINAL_HEIGHT+=2))
        ((MIN_TERM_HEIGHT_FOR_R_PANEL+=2))
        
        HEADER_HEIGHT=5
    else
        HEADER_HEIGHT=3
    fi

    if $SHOW_FOOTER || $IS_SUB_FLAGS_MENU; then

        ((MIN_TERMINAL_HEIGHT+=2))

        if $IS_SUB_FLAGS_MENU; then
            ((MIN_TERM_HEIGHT_FOR_R_PANEL+=1))
        else
            ((MIN_TERM_HEIGHT_FOR_R_PANEL+=2))
        fi
        
        FOOTER_HEIGHT=2
    else
        FOOTER_HEIGHT=1
    fi

    MIN_TERM_H_FOR_R_PANEL_CMB=$(($MIN_TERM_HEIGHT_FOR_R_PANEL+8))

    if [[ $TERMINAL_HEIGHT -lt $MIN_TERMINAL_HEIGHT ]] || [[ $TERMINAL_WIDTH -lt $MIN_TERMINAL_WIDTH ]]; then
        MENUS_FORCE_HIDDEN=true
        show_force_hide_error
    else
        MENUS_FORCE_HIDDEN=false
        RIGHT_PANEL_HEIGHT_WARNING=false
        RIGHT_PANEL_WIDTH_WARNING=false
        HEIGHT_WARNING=false

        MAX_MENU_HEIGHT=$(($TERMINAL_HEIGHT - 3 - $HEADER_HEIGHT - $FOOTER_HEIGHT))

        if [[ $MAX_MENU_ITEMS > 0 ]]; then
            NORMAL_MENU_HEIGHT=$(( $MAX_MENU_ITEMS + 3 ))
        else
            NORMAL_MENU_HEIGHT=$MAX_MENU_HEIGHT
        fi

        MENU_HEIGHT=0
        SHOW_RIGHT_PANEL=$RIGHT_PANEL

        if [[ $TERMINAL_HEIGHT -lt $MIN_TERM_HEIGHT_FOR_R_PANEL ]]; then
            SHOW_RIGHT_PANEL=false
            if $RIGHT_PANEL; then
                RIGHT_PANEL_HEIGHT_WARNING=true
            fi
        fi

        if [[ $TERMINAL_WIDTH -lt $(($RIGHT_PANEL_WIDTH * 2)) ]]; then
            SHOW_RIGHT_PANEL=false
            if $RIGHT_PANEL; then
                RIGHT_PANEL_WIDTH_WARNING=true
            fi
        fi

        if ! $SHOW_RIGHT_PANEL $$ [[ $ACTIVE_PANEL -eq "right" ]]; then
            ACTIVE_PANEL="left"
        fi
  
        # Got to make sure we fit inside whatever size the terminal currently is
        if [[ $NORMAL_MENU_HEIGHT -gt $MAX_MENU_HEIGHT ]]; then
            NORMAL_MENU_HEIGHT=$MAX_MENU_HEIGHT
            HEIGHT_WARNING=true
        else
            HEIGHT_WARNING=false
        fi

        if [[ $NORMAL_MENU_HEIGHT -lt $MIN_MENU_HEIGHT ]]; then
                NORMAL_MENU_HEIGHT=$MIN_MENU_HEIGHT
        fi

        if ! $SHOW_RIGHT_PANEL; then
            ACTIVE_RIGHT_PANEL_WIDTH=0
        else
            ACTIVE_RIGHT_PANEL_WIDTH=$RIGHT_PANEL_WIDTH
        fi

        LEFT_PANEL_WIDTH=$(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH))
        MENU_HEIGHT=$NORMAL_MENU_HEIGHT
    fi

}

show_force_hide_error() {
    clear
    echo
    echo -n "Cannot display menus on this terminal. If you are in an emulator, you need to resize the window"
    if ! $AUTO_REFLOW; then
        echo -n ", and press 'f' to re-draw the menu; "
    else
        echo -n "; "
    fi
    
    echo -n "or press 'q' to quit."
    echo -e '\n'

    if [[ $TERMINAL_HEIGHT -le $MIN_TERMINAL_HEIGHT ]]; then
        echo "Minimum supported height: $MIN_TERMINAL_HEIGHT characters."
        echo -e "Current height: \e[01m\e[091m$TERMINAL_HEIGHT\e[00m characters"
        echo
    fi
    if [[ $TERMINAL_WIDTH -lt $MIN_TERMINAL_WIDTH ]]; then
        echo "Minimum supported width: $MIN_TERMINAL_WIDTH characters."
        echo -e "Current width: \e[01m\e[091m$TERMINAL_WIDTH\e[00m characters"
        echo
    fi
}


check_for_size_changes() {
    (:)
    local current_height=$(t_put lines)
    local current_width=$(t_put cols)

    if [[ $TERMINAL_HEIGHT -ne $current_height ]] || [[ $TERMINAL_WIDTH -ne $current_width ]]; then
        reflow_menu
        return 1
    fi

    return 0
}

set_up_menus() {
 
    if [[ -f $MENU_FILE ]]; then
        echo "Setting menus..."
        parse_system_menu_file
        parse_menu_file
        read_tab_items
        set_menu_sizes     
    else
        clear
        echo
        echo "Looked for menus in:"
        echo $MENU_FILE
        echo
        echo "Error: Cannot find menuentries file in default location. Exiting..."
        echo
        exit 65
    fi
}





set_command_builder_items() {     

    local array_counter=0
    MENU_ITEM_ENTRIES=()
    MENU_ITEM_COMMANDS=()
    MENU_ITEM_DESCRIPTIONS=()

    for arg in "$@"; do

        local entry=$(($array_counter+1))" - Set arg. ${arg}"
        MENU_ITEM_ENTRIES+=("$entry")
        MENU_ITEM_COMMANDS+=("$arg")
        
        ((array_counter++))

    done
    
    MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}


}


parse_menu_file() {

    local -a menu_file_contents
    local line
        
    OLD_IFS=$IFS
    IFS=
    
    while read -r line; do
        if [[ ! "$line" == "#"* ]] && [[ -n "$line" ]]; then
            menu_file_contents+=("$line")
        fi
    done < "$MENU_FILE"

    IFS=$OLD_IFS

    local tab_items_toggle=false
    local menu_items_toggle=false
      
    for ((n = 0; n <= ${#menu_file_contents[@]}; n++)); do

        if $tab_items_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_tab_order:]" ]]; then
                tab_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                TAB_ITEM_ROWS+=("$tmp")
                unset tmp                
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:tab_order:]" ]]; then
                tab_items_toggle=true
            fi
        fi

        if $menu_items_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_menu_items:]" ]]; then
                menu_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                MENU_ITEM_ROWS+=("$tmp")
                unset tmp
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:menu_items:]" ]]; then
                menu_items_toggle=true
            fi
        fi

   
    done


}

parse_system_menu_file() {

    local -a menu_file_contents
    local line

    OLD_IFS=$IFS
    IFS=
    
    while read -r line; do
        if [[ ! "$line" == "#"* ]] && [[ -n "$line" ]]; then
            menu_file_contents+=("$line")
        fi
    done < "$SYSTEM_MENU_FILE"

    IFS=$OLD_IFS
  
    local menu_items_toggle=false
    local right_menus_toggle=false
      
    for ((n = 0; n <= ${#menu_file_contents[@]}; n++)); do

        if $menu_items_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_special_menu_items:]" ]]; then
                menu_items_toggle=false
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                SYSTEM_MENU_ITEM_ROWS+=("$tmp")
                unset tmp
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:special_menu_items:]" ]]; then
                menu_items_toggle=true
            fi
        fi

        if $right_menus_toggle; then
            if [[ "${menu_file_contents[$n]}" == "[:end_right_panel_items:]" ]]; then
                continue
            else
                local tmp="${menu_file_contents[$n]}"
                tmp="${tmp//"$MENU_DELIMITER"/"$SAFE_DELIMITER"}"
                RIGHT_PANEL_ITEM_ROWS+=("$tmp")
                unset tmp
            fi
        else
            if [[ "${menu_file_contents[$n]}" == "[:right_panel_items:]" ]]; then
                right_menus_toggle=true
            fi
        fi
    done


}


# Load the items shown in the tab
read_tab_items() {
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"

    TAB_ITEM_KEYS=()
    TAB_ITEM_ENTRIES=()

    for ((n = 0; n < "${#TAB_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${TAB_ITEM_ROWS[$n]}"

        local key="${current_row[0]}"
        key="${key#"${key%%[![:space:]]*}"}"  # Remove leading whitespace
        key="${key%"${key##*[![:space:]]}"}"  # Remove trailing whitespace

        local title="${current_row[1]}"
        title="${title#"${title%%[![:space:]]*}"}"  # Remove leading whitespace
        title="${title%"${title##*[![:space:]]}"}"  # Remove trailing whitespace

        TAB_ITEM_KEYS+=("$key")
        TAB_ITEM_ENTRIES+=("$title")
    done

    IFS="$OLD_IFS"
    NUMBER_OF_TABS=$((${#TAB_ITEM_ENTRIES[@]} - 1))

    # No more than 9 tabs for now, for shortkey reasons (F1 to f9, or t-1 to t-9)
    if [[ $NUMBER_OF_TABS -gt 8 ]]; then
        for ((i = 9; i < $NUMBER_OF_TABS + 1; i++)); do
            unset "TAB_ITEM_KEYS[$i]"
            unset "TAB_ITEM_ENTRIES[$i]"
        done

        NUMBER_OF_TABS=8
    fi

}

read_submenu_items(){

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=1

    MENU_ITEM_ENTRIES=()
    MENU_ITEM_DESCRIPTIONS=()
    MENU_ITEM_COMMANDS=()
    MENU_ITEMS_COUNT=0

    local tab_key="$1"
    local submenu_position=$2
    local submenu_toggle=false

    local -i main_idx=0
    local -i sub_idx=1

    # for ((n = 0; n < "${#MENU_ITEM_ROWS[@]}"; n++)); do
    for item_row in "${MENU_ITEM_ROWS[@]}"; do
        local -a current_row
        read -ra current_row <<< "$item_row" #"${MENU_ITEM_ROWS[$n]}"
 
        local sub_key="${current_row[0]}"
        sub_key="${sub_key#"${sub_key%%[![:space:]]*}"}"  # Remove leading whitespace
        sub_key="${sub_key%"${sub_key##*[![:space:]]}"}"  # Remove trailing whitespace

        if $submenu_toggle; then

            if [[ "$sub_key" == "--" ]]; then
                add_row_to_menu_items $sub_idx "${current_row[@]}"
                
                if [[ $? == 0 ]]; then
                    ((sub_idx++))
                fi
                
            else
                break
            fi

        elif [[ "$sub_key" == "$tab_key" ]]; then
            if [[ $main_idx == $submenu_position ]];then
                submenu_toggle=true
            else
                ((main_idx++))
            fi        
        fi

    done


    IFS="OLD_IFS"

    MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}

    
}



read_menu_items() {
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=1
    local -l system_menu_type=""

    if [[ -n "$1" ]]; then
        system_menu_type="$1"
    fi

    MENU_ITEM_ENTRIES=()
    MENU_ITEM_DESCRIPTIONS=()
    MENU_ITEM_COMMANDS=()
    MENU_ITEMS_COUNT=0

    if [[ -n $system_menu_type ]]; then
        for ((n = 0; n < "${#SYSTEM_MENU_ITEM_ROWS[@]}"; n++)); do
            local -a current_row
            read -ra current_row <<< "${SYSTEM_MENU_ITEM_ROWS[$n]}"

            local -l tab_key="${current_row[0]}"
            tab_key="${tab_key#"${tab_key%%[![:space:]]*}"}"  # Remove leading whitespace
            tab_key="${tab_key%"${tab_key##*[![:space:]]}"}"  # Remove trailing whitespace
            
            if [[ $tab_key == $system_menu_type ]]; then
                add_row_to_menu_items $idx $system_menu_type "${current_row[@]}" 

                if [[ $? == 0 ]]; then
                    ((idx++))
                fi
            fi 
        done
    else
        for ((n = 0; n < "${#MENU_ITEM_ROWS[@]}"; n++)); do
            local -a current_row
            read -ra current_row <<< "${MENU_ITEM_ROWS[$n]}"

            local tab_key="${current_row[0]}"
            tab_key="${tab_key#"${tab_key%%[![:space:]]*}"}"  # Remove leading whitespace
            tab_key="${tab_key%"${tab_key##*[![:space:]]}"}"  # Remove trailing whitespace
            
            if [[ $tab_key == "${TAB_ITEM_KEYS[$TAB_POS]}" ]] || [[ $tab_key == "${TAB_ITEM_ENTRIES[$TAB_POS]}" ]]; then
                add_row_to_menu_items $idx "${current_row[@]}"

                if [[ $? == 0 ]]; then
                    ((idx++))
                fi
            fi 
        done
    fi


    IFS="$OLD_IFS"
    MENU_HEIGHT=$NORMAL_MENU_HEIGHT
    MAX_MENU_LENGTH=$(($NORMAL_MENU_HEIGHT - 3))
    MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}

}

add_row_to_menu_items() {
    local -i idx=$1
    shift
    local system_function=""
    if [[ $1 == "setup" ]] || [[ $1 == "help" ]]; then
        system_function=$1
        shift
    fi

    local -a curent_row="$@"
    local menu_item="${current_row[1]}"

    menu_item="${menu_item#"${menu_item%%[![:space:]]*}"}"
    menu_item="${menu_item%"${menu_item##*[![:space:]]}"}"

    local description="${current_row[2]}"
    description="${description#"${description%%[![:space:]]*}"}"
    description="${description%"${description##*[![:space:]]}"}"

    local command="${current_row[3]}"
    command="${command#"${command%%[![:space:]]*}"}"
    command="${command%"${command##*[![:space:]]}"}"
    
    if [[ -z $menu_item ]]; then
        menu_item=skip
    fi

   
    if [[ $menu_item == "skip" ]] || [[ $menu_item == "---" ]] || [[ $menu_item == "[inline-label]" ]]; then
        MENU_ITEM_ENTRIES+=("$menu_item")
        if [[ $menu_item == "[inline-label]" ]]; then
             MENU_ITEM_DESCRIPTIONS+=("$description")
        else
            MENU_ITEM_DESCRIPTIONS+=("")
        fi
        MENU_ITEM_COMMANDS+=("")
        return 1
    else
        if [[ -z "$description" ]] && [[ -z "$command" ]]; then
            MENU_ITEM_ENTRIES+=("[inline-label]")
            MENU_ITEM_DESCRIPTIONS+=("$menu_item")
            MENU_ITEM_COMMANDS+=("")
            return 1
        else
            MENU_ITEM_ENTRIES+=("$idx - $menu_item")
            MENU_ITEM_DESCRIPTIONS+=("$description")
            if [[ -n $system_function ]]; then
                MENU_ITEM_COMMANDS+=("funct$system_function$idx")
            else
                MENU_ITEM_COMMANDS+=("$command")
            fi
            ((MENU_ITEMS_COUNT++))
            return 0
        fi
         
    fi
    

}

read_rightpanel_items() {    
    local menu_type_key

    if $IS_SUB_FLAGS_MENU; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi    

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"

    RIGHT_PANEL_ITEM_KEYS=()
    RIGHT_PANEL_ITEM_ENTRIES=()
    RIGHT_PANEL_ITEM_DESCRIPTIONS=()
    
    for ((n = 0; n < "${#RIGHT_PANEL_ITEM_ROWS[@]}"; n++)); do
        local -a current_row
        read -ra current_row <<< "${RIGHT_PANEL_ITEM_ROWS[$n]}"

        local menu_type="${current_row[0]}"
        menu_type="${menu_type#"${menu_type%%[![:space:]]*}"}"  # Remove leading whitespace
        menu_type="${menu_type%"${menu_type##*[![:space:]]}"}"  # Remove trailing whitespace
       
        local shortkey="${current_row[1]}"
        shortkey="${shortkey#"${shortkey%%[![:space:]]*}"}"
        shortkey="${shortkey%"${shortkey##*[![:space:]]}"}"
       
        local menu_item="${current_row[2]}"
        menu_item="${menu_item#"${menu_item%%[![:space:]]*}"}"
        menu_item="${menu_item%"${menu_item##*[![:space:]]}"}"
       
        local description="${current_row[3]}"
        description="${description#"${description%%[![:space:]]*}"}"
        description="${description%"${description##*[![:space:]]}"}"

        local ignore_item=false

        if [[ -z $shortkey ]]; then
            shortkey="skip"
        fi
    
        if  [[ "$menu_type" == "$menu_type_key" ]]; then  
           
            if [[ "$shortkey" == "o" ]]; then
                if $IS_SUBMENU; then
                    ignore_item=true
                fi
            elif [[ "$shortkey" == "b" ]]; then
                if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU; then
                    ignore_item=true
                fi
            elif [[ "$shortkey" == "h" ]] && $IS_HELP_SUBMENU; then
                shortkey="skip"
            fi

            if ! $ignore_item; then
                RIGHT_PANEL_ITEM_KEYS+=("$shortkey")
                if [[ "$shortkey" != "skip" ]]; then
                    RIGHT_PANEL_ITEM_ENTRIES+=("$shortkey - $menu_item")
                    RIGHT_PANEL_ITEM_DESCRIPTIONS+=("$description")
                else
                    RIGHT_PANEL_ITEM_ENTRIES+=("")
                    RIGHT_PANEL_ITEM_DESCRIPTIONS+=("")
                fi
            fi
        fi
    done

    IFS=$OLD_IFS
}



#Display the menu tabs
write_tab_items() {  
    TABS_DONT_FIT=false
    local current_tabs_length=0
    DISPLAYED_TAB_ENTRIES=1
    local just_toggled_setup_off=false

    ALL_TABS_LENTH=0
    local -i connector_offset=2
 

    for ((n = 0; n <= $NUMBER_OF_TABS; n++)); do
        ALL_TABS_LENTH=$(($ALL_TABS_LENTH + ${#TAB_ITEM_ENTRIES[$n]} + 3))
    done

    ((ALL_TABS_LENTH++))

    # Make sure tabs will fit
    for ((n = 0; n <= $NUMBER_OF_TABS; n++)); do
        current_tabs_length=$(($current_tabs_length + ${#TAB_ITEM_ENTRIES[$n]} + 3))
        if [[ $current_tabs_length -ge $TERMINAL_WIDTH ]]; then
            TABS_DONT_FIT=true
            ((DISPLAYED_TAB_ENTRIES--))
             if [[ $TAB_POS -ge $DISPLAYED_TAB_ENTRIES ]]; then
                select_tab $DISPLAYED_TAB_ENTRIES
                # reflow_menu
            fi
            break
        fi
        ((DISPLAYED_TAB_ENTRIES++))
    done

    # Not entirely sure why, but we need this only when all tabs are displayed
    # When some ar cut off, it should be zero. Apparntly. This is like black magic 
    # for now, because I'm lazy / too busy to properly look at what's happening, and
    # this seemed like a kwikk fiks
    
    if $TABS_DONT_FIT; then
        connector_offset=0
    fi

    local horizontal_connector_position=0
    # Display joints if on, but not for the last item
    if $DISPLAY_LINE_CONNECTORS; then
      
        # need to clear any lefrtovers inn case of resizing
        t_put cup $((HEADER_HEIGHT - 3)) 0
        draw_line
        
        for ((n = 0; n < $(($DISPLAYED_TAB_ENTRIES - $connector_offset)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#TAB_ITEM_ENTRIES[$n]} + 3))
            t_put cup $((HEADER_HEIGHT - 3)) $horizontal_connector_position
            echo -n "â¯"
        done
    fi

    # Then write out the tab items, with separators
    clear_line $((HEADER_HEIGHT - 2)) 1 "right"
    t_put cup $((HEADER_HEIGHT - 2)) 1
    
    for ((n = 0; n < $DISPLAYED_TAB_ENTRIES; n++)); do
       
        if [[ $n -eq $TAB_POS ]]; then
            echo -n -e "\e[00;30;47m ${TAB_ITEM_ENTRIES[$n]} \e[00m"
        else
            echo -n " ${TAB_ITEM_ENTRIES[$n]} "
        fi

        # Do not write separator after last item
        if [[ $n -lt $NUMBER_OF_TABS ]]; then
            echo -n "â"
        fi       
    
    done

   

    if $DISPLAY_LINE_CONNECTORS; then
        # Then draw connectors ont he bottom line, but not for the last item
        local rp_connector_drawn=false
        horizontal_connector_position=0

        # Need to clear old ones...
        t_put cup $((HEADER_HEIGHT-1)) 0
        draw_line
        
        for ((n = 0; n < $(($DISPLAYED_TAB_ENTRIES - $connector_offset)); n++)); do
            horizontal_connector_position=$(($horizontal_connector_position + ${#TAB_ITEM_ENTRIES[$n]} + 3))
            t_put cup $((HEADER_HEIGHT-1)) $horizontal_connector_position

            if $SHOW_RIGHT_PANEL && [[ $horizontal_connector_position == $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH)) ]]; then
                echo -n "â¿"
                rp_connector_drawn=true
            else
                echo -n "â·"
            fi
        done


        if $SHOW_RIGHT_PANEL && ! $rp_connector_drawn; then
            t_put cup $((HEADER_HEIGHT-1)) $LEFT_PANEL_WIDTH
            echo "â¯"
        fi


    fi

    if $TABS_DONT_FIT; then
        t_put cup $((HEADER_HEIGHT - 3)) $(($TERMINAL_WIDTH-1)) 
        # echo -e "\e[091mmâ\e[0m"
        echo -e "\e[091mâ\e[0m"
        t_put cup $((HEADER_HEIGHT - 2)) $(($TERMINAL_WIDTH-1))
        echo -e "\e[091mâ\e[0m"
        t_put cup $((HEADER_HEIGHT - 1)) $(($TERMINAL_WIDTH-1))
        # echo -e "\e[01m\e[091mâ\e[00m"
        echo -e "\e[091mâ\e[0m"
    fi

    check_for_warnings
}



write_menu_items() { 
    # Write out the menu items one by one
    # If the position is right, it changes the background.
    local max_entry_lenght=$(($LEFT_PANEL_WIDTH - 4))
    if $IS_SUB_FLAGS_MENU; then
        MAX_MENU_LENGTH=$(($NORMAL_MENU_HEIGHT - 2))
    else
        MAX_MENU_LENGTH=$(($NORMAL_MENU_HEIGHT - $FOOTER_HEIGHT))
    fi

   

    if [[ $MENU_POS -gt $(($MAX_MENU_LENGTH - 1)) ]]; then
        MENU_POS=$(($MAX_MENU_LENGTH-1))
        while [[ $MENU_POS > 0 ]]; do
                if [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; then
                    ((MENU_POS--))
                else
                    break
                fi   
        done
    else  
       
        while [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; do
        
            ((MENU_POS++))

            if [[ $MENU_POS == $(($MAX_MENU_LENGTH-1)) ]]; then
                break
            fi

        done   
        
    fi
    
    for ((n = 0; n < $MAX_MENU_LENGTH; n++)); do

        if [[ "${MENU_ITEM_ENTRIES[$n]}" == "---" ]]; then
            t_put cup $(($n + $HEADER_HEIGHT +1)) 0
            draw_divider_line "left"
            continue
        elif [[ "${MENU_ITEM_ENTRIES[$n]}" == "[inline-label]" ]]; then
            local menu_label_line=$(truncate_text "${MENU_ITEM_DESCRIPTIONS[$n]}" $max_entry_lenght)
            t_put cup $(($n + $HEADER_HEIGHT + 1)) 2 # To center, use: $((LEFT_PANEL_WIDTH / 2 - (${#menu_label_line} / 2)))
            echo -e "\e[01m$menu_label_line\e[00m"

        elif [[ ! "${MENU_ITEM_ENTRIES[$n]}" == "skip" ]]; then
         
            local menu_item_line=$(truncate_text "${MENU_ITEM_ENTRIES[$n]}" $max_entry_lenght)

            t_put cup $(($n + $HEADER_HEIGHT + 1)) 2

            if [[ $n -eq $MENU_POS ]] && [[ "$ACTIVE_PANEL" == "left" ]]; then
                echo -e "\e[00;30;47m$menu_item_line\e[00m"
            else
                echo "$menu_item_line"
            fi
        fi

    done

    local -i line_offset=2

    if $IS_SUB_FLAGS_MENU; then
        line_offset=2
    fi

    t_put cup $(($MAX_MENU_LENGTH + $HEADER_HEIGHT + $line_offset)) 1

    # If the item list was truncated, display a visual clue at the bottom
    if [[ ${#MENU_ITEM_ENTRIES[@]} -gt $MAX_MENU_LENGTH ]]; then
        MENU_LENGTH=$MAX_MENU_LENGTH

        for ((i = 0; i < $(($LEFT_PANEL_WIDTH-2)); i++)); do
            echo -en "\e[01m\e[091mâ\e[00m"
        done
    else
        MENU_LENGTH=${#MENU_ITEM_ENTRIES[@]}

        # Reset normal line, otherwise
        for ((i = 0; i < $(($LEFT_PANEL_WIDTH-2)); i++)); do
            echo -n "â"
        done
    fi

    if $IS_SUB_FLAGS_MENU && [[ "$ACTIVE_PANEL" == "left" ]]; then
        write_active_cmb_command
    elif $SHOW_FOOTER; then
        write_descriptor
    fi
}


# Simply write a one line descriptor, as read from the menu file
write_descriptor() { 
    local descriptor_line
    
    if [[ $ACTIVE_PANEL == "right" ]]; then
        descriptor_line=$(truncate_text "${RIGHT_PANEL_ITEM_DESCRIPTIONS[$MENU_POS]}" $(($TERMINAL_WIDTH-4)))
    else
        descriptor_line=$(truncate_text "${MENU_ITEM_DESCRIPTIONS[$MENU_POS]}" $(($TERMINAL_WIDTH-4)))
    fi

    CURSOR_POS=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    t_put cup $CURSOR_POS $MENU_WIDTH
    echo -e "\033[1K"
    t_put cup $CURSOR_POS 2
    echo "$descriptor_line"
}




# # This is hardcoded for now.
# # Might gonna get its own resource file in a future release
# # TODO Move these into a help-entries file, or something
# write_help_menu_items() { 
#     MENU_LENGTH=3
#     help_menu_entry[0]="1 - Lazy Admin usage guide"
#     help_menu_entry[1]="2 - Configuration and scripting guide"
#     help_menu_entry[2]="3 - Command builder usage guide"

#     local max_entry_lenght=$(($LEFT_PANEL_WIDTH - 4))

#     for ((n = 0; n < $MENU_LENGTH; n++)); do
                
#         if [[ "${help_menu_entry[$n]}" == "skip" ]]; then
#             ((n++))
#         fi

#         help_item_line=$(truncate_text "${help_menu_entry[$n]}" $max_entry_lenght)
#         t_put cup $((n + $HEADER_HEIGHT + 1)) 2

#         if [[ $n -eq $MENU_POS ]] && [[ "$ACTIVE_PANEL" == "left" ]]; then
#             echo -e "\e[00;30;47m$help_item_line\e[00m"
#         else
#             echo "$help_item_line"
#         fi

#     done
# }


write_rightpanel_items() { 
    local menu_type_key
    # clear_right_panel

    if $IS_SUB_FLAGS_MENU; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi  
    
    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
     
    for ((n = 0; n < ${#RIGHT_PANEL_ITEM_ENTRIES[@]}; n++)); do

        if  $IS_SUB_FLAGS_MENU && [[ $TERMINAL_HEIGHT -lt $MIN_TERM_H_FOR_R_PANEL_CMB ]]; then
            if [[ $n > 4 ]]; then
                break
            fi

        fi

        local shortkey="${RIGHT_PANEL_ITEM_KEYS[$n]}"

        if [[ "$shortkey" == "skip" ]]; then
            continue
        elif [[ "$shortkey" == "---" ]]; then
            t_put cup $(($n + $HEADER_HEIGHT +1)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH))
            draw_divider_line "right"
            continue
        else
            t_put cup $(($n + $HEADER_HEIGHT + 1)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH))
            local current_item="${RIGHT_PANEL_ITEM_ENTRIES[$n]}"
            current_item=$(truncate_text "$current_item" $(($ACTIVE_RIGHT_PANEL_WIDTH-4)))

            if [[ $n == $MENU_POS ]] && [[ "$ACTIVE_PANEL" == "right" ]]; then
                echo -e "â  \e[00;30;47m$current_item\e[00m"
            else
                echo -e "â  $current_item"
            fi
        fi
    done

    IFS=$OLD_IFS
    if $SHOW_FOOTER || $IS_SUB_FLAGS_MENU; then
        if [[ "$ACTIVE_PANEL" == "right" ]]; then
            write_descriptor
        fi
    fi
}

 write_right_panel_descriptor() { 
    
    local menu_type_key
    
    if $IS_SUB_FLAGS_MENU; then
        menu_type_key="$COMMAND_BUILDER_KEY"
    else
        menu_type_key="$MAIN_MENU_KEY"
    fi    

    OLD_IFS=$IFS
    IFS="$SAFE_DELIMITER"
    local -i idx=0

    local -a rp_item_descriptions=()
    for item in "${RIGHT_PANEL_ITEM_ROWS[@]}"; do

        local -a current_row
        read -ra current_row <<< "$item"

        local menu_type=${current_row[0]}
        local description=${current_row[6]}

        if [[ "$menu_type" == "$menu_type_key" ]]; then  
            rp_item_descriptions+=("$description")
        fi
    done

    IFS=$OLD_IFS

    descriptor_line=$(truncate_text "${rp_item_descriptions[$MENU_POS]}" $(($TERMINAL_WIDTH-4)))
    CURSOR_POS=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    t_put cup $CURSOR_POS $MENU_WIDTH
    echo -e "\033[1K"
    t_put cup $CURSOR_POS 2
    echo "$descriptor_line"
}
                      


#Draws a line
draw_line() { 

    local -i line_lenght=$MENU_WIDTH

    if [[ -n $1 ]] && [[ $1 -gt 0 ]] then
        line_lenght=$1
    fi

    for ((i = 0; i < $line_lenght; i++)); do
        echo -n "â"
    done
}

draw_divider_line() {
    local -i line_lenght

    if [[ "$1" == "right" ]]; then
        line_lenght=$(($ACTIVE_RIGHT_PANEL_WIDTH-1))
    else
        if $SHOW_RIGHT_PANEL; then
            line_lenght=$(($LEFT_PANEL_WIDTH))
        else
            line_lenght=$MENU_WIDTH
        fi
    fi

    if [[ "$1" == "right" ]]; then
        echo -n "â"
    fi

    for ((i = 0; i < $line_lenght; i++)); do
        echo -n "â¶"
    done


    # if [[ "$1" == "left" ]] && $SHOW_RIGHT_PANEL; then
    #     echo -n "â¤"
    # fi


}


#clear menu area
clear_menu() { 
    # echo "Clear menu called"
    for ((n = 1; n < $MENU_HEIGHT; n++)); do
        clear_line $((n + $HEADER_HEIGHT)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH - 1)) "left"
    done

    # echo "Menu cleared"
    # sleep 5
}

clear_right_panel() {
    for ((n = 0; n < (($MENU_HEIGHT-2)); n++)); do
        clear_line $((n + $HEADER_HEIGHT +1)) $(($MENU_WIDTH - $ACTIVE_RIGHT_PANEL_WIDTH + 1)) "right"
    done
}

# Usage clear_line $line_number $from_column "left|right"
clear_line() {

    if [[ $# -lt 3 ]]; then
        return 65
    fi

    local line_number=$1
    local from_column=$2
    local direction=$3

    t_put cup $line_number $from_column
    if [[ $direction == "left" ]]; then
        echo -ne "\e[1K"
    else
        echo -ne "\e[K"
    fi 
}

write_main_title(){
    local title=$MAIN_TITLE

    if $IS_ROOT; then
        title=$title$ROOT_TITLE
    fi

    t_put cup 1 $((MENU_WIDTH / 2 - (${#title} / 2)))

    if ! $IS_ROOT; then
        # Print it in bold
        echo -e "\e[01m$title\e[00m"
    else
        # Print it in bold and red
        echo -e "\e[01m\e[091m$title\e[00m"
    fi
}

#Draws the outline of the menu, with spaces left out for inclusion of items
draw_menu() {

    if $MENUS_FORCE_HIDDEN; then
        show_force_hide_error
        return 1
    fi
    
    t_put civis

    MENU_HEIGHT=$NORMAL_MENU_HEIGHT
  

   
    
    #clear menu area. Should be done each time tabs or submenus are changed
    clear_menu
    CURSOR_POS=0
    t_put cup $CURSOR_POS 0
    draw_line

    if $SHOW_HEADER; then
        # ((HEADER_HEIGHT+=2))
        write_main_title
        
        ((CURSOR_POS+=2))

        draw_line
        
    fi


    ((CURSOR_POS+=2))
    t_put cup $CURSOR_POS 0
    draw_line
    
    
    # If rigth panel is on, draw its separator
    if $SHOW_RIGHT_PANEL; then
        # CURSOR_POS=$((HEADER_HEIGHT - 3))

        
        # if $DISPLAY_LINE_CONNECTORS; then
        #     t_put cup $CURSOR_POS $LEFT_PANEL_WIDTH
        #     echo "â¯"
        # fi

        ((CURSOR_POS++))

        for ((i = 0; i <= MENU_HEIGHT; i++)); do
            t_put cup $CURSOR_POS $LEFT_PANEL_WIDTH
            echo "â"
            ((CURSOR_POS++))
        done
    fi

    CURSOR_POS=$(($HEADER_HEIGHT + $FOOTER_HEIGHT + $MENU_HEIGHT))
    t_put cup $CURSOR_POS 0
    draw_line
    
    if $SHOW_FOOTER || $IS_SUB_FLAGS_MENU; then
        ((CURSOR_POS -= $FOOTER_HEIGHT))
        t_put cup $CURSOR_POS 0
        draw_line
    fi

    if $SHOW_RIGHT_PANEL && $DISPLAY_LINE_CONNECTORS; then
        t_put cup $CURSOR_POS $LEFT_PANEL_WIDTH
        echo "â·"
    fi


    check_for_warnings
    
    
}

check_for_warnings() {

    local warning_position=$(($HEADER_HEIGHT + $MAX_MENU_HEIGHT + $FOOTER_HEIGHT +1))
 
    clear_line $warning_position 0 "right"

    clear_line $(($warning_position + 1)) 0 "right"

    local msg=""
    local warning_msg=""

    if $HEIGHT_WARNING || $TABS_DONT_FIT; then
        local menus_label=""
        local tabs_label=""
        local min_height_msg=""
        local min_width_msg=""

        if $HEIGHT_WARNING; then
            min_height_msg=" Min. H: "$(($MAX_MENU_ITEMS + 13))" ch."
            menus_label="Menus "
        fi

        if $TABS_DONT_FIT; then
            min_width_msg=" Min. W: "$ALL_TABS_LENTH" ch"
            if $HEIGHT_WARNING; then
                tabs_label="and tabs "
            else
                tabs_label="Tabs "
            fi
        fi

        msg="$menus_label$tabs_label""won't fit.$min_height_msg$min_width_msg"
        warning_msg=$(truncate_text "$msg" $(($TERMINAL_WIDTH-4)))
        t_put cup $warning_position 0
        echo -e "\e[01m\e[091m$warning_msg\e[00m"
        ((warning_position++))
        msg=""    
    fi

    if $RIGHT_PANEL_HEIGHT_WARNING; then
        msg="Right-panel and cmd-builder disabled. Min. H: $MIN_TERM_HEIGHT_FOR_R_PANEL ch."
    elif $RIGHT_PANEL_WIDTH_WARNING; then
        msg="Right-panel disabled. Min. W: "$(($RIGHT_PANEL_WIDTH * 2))" ch."
    fi

    if [[ -n "$msg" ]]; then
        warning_msg=$(truncate_text "$msg" $(($TERMINAL_WIDTH-4)))
        t_put cup $warning_position 0
        echo -ne "\e[01m\e[091m$warning_msg\e[00m"
    fi

  

}

truncate_text(){
    local text=$1
    local max_lenght=$2

    if [[ ${#text} -gt $max_lenght ]]; then
        text="${text:0:$(($max_lenght - 3))}..."
    fi

    echo "$text"
}


infinite_tab() {     
   local  limit=$(($DISPLAYED_TAB_ENTRIES - 1))

    if [[ $limit -lt $NUMBER_OF_TABS ]]; then
       ((limit++))
    fi

    if [[ $TAB_POS -eq $limit ]]; then
        TAB_POS=0
    fi

    if [[ $TAB_POS -lt 0 ]]; then
        TAB_POS=$(($limit - 1))
    fi

}


###################################
# Movement and menu item handling #
###################################

move_up() {
    #Double jump if run on skip
    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        while [[ "${MENU_ITEM_ENTRIES[$MENU_POS - 1]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS - 1]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS - 1]}" == "[inline-label]" ]]; do
            ((MENU_POS--))
        done
    fi

    # Alo in right panel
    if [[ "$ACTIVE_PANEL" == "right" ]]; then 
        while [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS - 1]}" == "skip" ]] || [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS - 1]}" == "---" ]]; do
           ((MENU_POS--))
        done
    fi

    ((MENU_POS--))
    infinite_menu
    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        write_menu_items
    else
        write_rightpanel_items
    fi
}


move_down() {
    #Double jump if running on skip
    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        while [[ "${MENU_ITEM_ENTRIES[$MENU_POS + 1]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS + 1]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS + 1]}" == "[inline-label]" ]]; do           
            ((MENU_POS++))
        done
    fi

    #Chexck for right panel too
    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        while [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS + 1]}" == "skip" ]] || [[ "${RIGHT_PANEL_ITEM_KEYS[$MENU_POS + 1]}" == "---" ]]; do
           ((MENU_POS++))
        done
    fi

    ((MENU_POS++))
    infinite_menu

    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        write_menu_items
    else
        write_rightpanel_items
    fi
}

# Causes the selector to jump to the "other end" of the menu, if reaching either the top or the bottom
infinite_menu() { 
    local -i limit=0
    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        limit=${#RIGHT_PANEL_ITEM_KEYS[@]}
    else
        limit=$MENU_LENGTH
    fi

    if [[ $MENU_POS -ge $limit ]]; then
        MENU_POS=0

        if [[ $ACTIVE_PANEL == "left" ]]; then
            while [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; do
                ((MENU_POS++))
            done
        fi
    fi

    if [[ $MENU_POS -lt 0 ]]; then
        MENU_POS=$(($limit - 1))
        
        if [[ $ACTIVE_PANEL == "left" ]]; then
            while [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "skip" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "---" ]] || [[ "${MENU_ITEM_ENTRIES[$MENU_POS]}" == "[inline-label]" ]]; do
                ((MENU_POS--))
            done
        fi
    fi
}

tab_left() {
    if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU && ! $IS_HELP_SUBMENU; then
        clear_menu
        MENU_POS=0
        ((TAB_POS--))
        infinite_tab
        write_tab_items
        read_menu_items
        write_menu_items
    fi
}


tab_right() {
   
    if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU && ! $IS_HELP_SUBMENU; then
        clear_menu
        MENU_POS=0
        ((TAB_POS++))

        infinite_tab
        write_tab_items
        read_menu_items
        write_menu_items
    fi
    

}


select_tab() {
    local -i target_tab=$(($1 - 1))
    if [[ $target_tab -lt $DISPLAYED_TAB_ENTRIES ]]; then
        if ! $IS_SUBMENU && ! $IS_SUB_FLAGS_MENU && ! $IS_HELP_SUBMENU; then
            if [[ $target_tab -eq 0 || $NUMBER_OF_TABS -ge $target_tab ]]; then
                clear_menu
                MENU_POS=0
                TAB_POS=$target_tab
                read_menu_items
                write_tab_items
                write_menu_items
                

            fi
        fi
    fi
}

# TODO: Add this to help files too
select_tab_by_number() {
    local tabkey=""
    read -sN1 -t 1 tabkey

    if [[ -n $tabkey ]]; then 
        if [[ $tabkey -ge 1 ]] && [[ $tabkey -le 9 ]]; then
            select_tab $tabkey
        fi
    fi
}


# "left", "right" or "swap"
change_panel() {
    case $1 in
    "right")
        if $SHOW_RIGHT_PANEL && [[ "$ACTIVE_PANEL" == "left" ]]; then
            ACTIVE_PANEL="right"
            MENU_POS=0
        fi
        ;;
    "left")
        if $SHOW_RIGHT_PANEL && [[ "$ACTIVE_PANEL" == "right" ]]; then
            ACTIVE_PANEL="left"
            MENU_POS=0
        fi
        ;;
    *)
        if $SHOW_RIGHT_PANEL; then
            if [[ "$ACTIVE_PANEL" == "right" ]]; then
                ACTIVE_PANEL="left"
                MENU_POS=0
            else
                ACTIVE_PANEL="right"
                MENU_POS=0
            fi
        fi
    esac

    write_menu_items
    if $SHOW_RIGHT_PANEL; then
        write_rightpanel_items
    fi
}

toggle_right_panel() {

    if $RIGHT_PANEL; then
        RIGHT_PANEL=false
    else
        RIGHT_PANEL=true
    fi

    SHOW_RIGHT_PANEL=$RIGHT_PANEL
    reflow_menu
}


toggle_line_connectors(){

    if $DISPLAY_LINE_CONNECTORS; then
        DISPLAY_LINE_CONNECTORS=false
    else
        DISPLAY_LINE_CONNECTORS=true
    fi

    reflow_menu

}



toggle_header(){
    if $SHOW_HEADER; then
        SHOW_HEADER=false
    else
        SHOW_HEADER=true
    fi

    reflow_menu
}

toggle_footer(){
    if $SHOW_FOOTER; then
        SHOW_FOOTER=false
    else
        SHOW_FOOTER=true
    fi

    if ! $IS_SUB_FLAGS_MENU; then
        reflow_menu
    fi
}






check_and_run(){
        local is_valid=false
        local is_navigation=false
        local delayed_return=false
        local validate_first=false
        local clear_before_running=false

        local command_item="$1"
        local command_function=""
        local command_args=""

        while true; do
            if [[ "$command_item" =~ " " ]]; then
                command_function="${command_item%% *}"

                if [[ "$command_function" == "/c" ]]; then
                    clear_before_running=true
                    command_item="${command_item:3}"
                    continue
                elif [[ "$command_function" == "/d" ]]; then
                    delayed_return=true
                    command_item="${command_item:3}"
                    continue
                elif [[ "$command_function" == "/v" ]]; then
                    
                    validate_first=true
                    command_item="${command_item:3}"
                    continue
                else
                    command_args="${command_item#* }"
                    break
                fi

            else
                command_function="$command_item"
                command_args=""
                break
            fi
        done
        
        is_valid=true
      
        case "$command_function" in
            "enter_submenu")
                is_navigation=true
                ;;
            "back_to_main_menu")
                is_navigation=true
                ;;
            "cmb")
                is_navigation=true
                ;;
        esac

        if $validate_first && ! $is_navigation; then
            is_valid=false
            if [[ $(validate_item $command_function) == 0 ]]; then
                is_valid=true
            else
                clear
                echo 
                echo "The specified command: '$command_function' is not a valid function or package name"
                echo
                return_to_menu
            fi
        fi

        if $is_valid; then
            if ! $is_navigation; then
                restore_terminal
            fi
            if $clear_before_running; then
                clear
            fi

            if [[ -n "$command_args" ]]; then
                eval "$command_function $command_args"
            else
                "$command_function"
            fi      

            if $delayed_return; then
                is_valid=false
                if ! $is_navigation; then
                    set_up_terminal
                fi
                return_to_menu
            fi

        fi
        if ! $is_navigation; then
            set_up_terminal
        fi
        if $is_navigation || ! $is_valid; then
            return 65
        else
            return 0
        fi
    
}


select_menu_item_by_number() {

    local key=$1
    local key2=""

    # Only read second digit if it makes sense, otherwise avoid the delay
    local read_second_digit=false

    if [[ $MENU_ITEMS_COUNT -gt 9 ]] && [[ $key -le $(($MENU_ITEMS_COUNT/10)) ]]; then
        read_second_digit=true
    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi

    local is_valid=1
    ((key--))

    local -i idx=0
    local -i item_idx=0

    for item in "${MENU_ITEM_COMMANDS[@]}"; do

        if [[ $item_idx == $key ]]; then
            # This is necessary, in case item is skipped, or the user left the command intentionally blank
            if [[ ${MENU_ITEM_ENTRIES[$idx]} != "skip" ]]  && [[ ${MENU_ITEM_ENTRIES[$idx]} != "---" ]] && [[ ${MENU_ITEM_ENTRIES[$idx]} != "[inline-label]" ]]; then     
                MENU_POS=$idx
                
                if [[ -n $item ]]; then
                    
                    check_and_run "$item"
                    is_valid=$?
                else
                    # Select the new position but do nothing else
                    write_menu_items
                fi
                break
            fi
        else
            # This is necessary, in case item is skipped, or the user left the command intentionally blank
            if [[ ${MENU_ITEM_ENTRIES[$idx]} != "skip" ]] && [[ ${MENU_ITEM_ENTRIES[$idx]} != "---" ]] && [[ ${MENU_ITEM_ENTRIES[$idx]} != "[inline-label]" ]]; then 
                ((item_idx++))
            fi 
        fi
        ((idx++))
    done


    if [[ $is_valid == 0 ]]; then
        reflow_menu
    fi

}


select_highlighted_menu_item() {
    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        functright$MENU_POS
    else

        local is_valid=1

        if [[ -n "${MENU_ITEM_COMMANDS[(($MENU_POS))]}" ]]; then
            check_and_run "${MENU_ITEM_COMMANDS[(($MENU_POS))]}"
            is_valid=$?
        fi
        
    fi

    if [[ $is_valid == 0 ]]; then
        reflow_menu
    fi

}


#########################################
# Command builder specific menu options #
#########################################

set_highlighted_cmb_arg() {
    # If enter is pressed
    if [[ "$ACTIVE_PANEL" == "right" ]]; then
        functright$MENU_POS
    else
        
        CMB_ARGS="$CMB_ARGS ${MENU_ITEM_COMMANDS[$MENU_POS]}"

        write_active_cmb_command
    fi
}


cmb_set_manual_args() {

    local space=" "
    if [[ "$1" == "nospace" ]]; then
        space=""
    fi
    echo
    restore_terminal
    local -i input_position=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    t_put cup $input_position 0
    # echo "Type your parameters here, and press <Enter>"
    clear_line $input_position 2 "right"

    read -p "Your args> " line_args
    CMB_ARGS="$CMB_ARGS$space$line_args"

    clear_line $input_position 0 "right"

    set_up_terminal
    # reflow_menu
    if [[ $ACTIVE_PANEL != "left " ]]; then
        change_panel "left"
    else
        write_active_cmb_command
    fi
}


cmb_commit_with_args() {
    clear
    echo
    echo "Executing:"
    echo "$CMB_COMMAND$CMB_ARGS"
    echo
    $CMB_COMMAND$CMB_ARGS
    echo
    echo "Now press a key to get back to the menu"
    read -n 1 -s key_press
    # IS_SUB_FLAGS_MENU=false
    back_to_main_menu 
}

cmb_clear_args() {
    CMB_ARGS=''
    write_active_cmb_command
}

cmb_set_arg_by_number() {

    local -i key=$1


    local read_second_digit=false
    if [[ ${#MENU_ITEM_COMMANDS[@]} -gt 9 ]]; then
        read_second_digit=true

    fi

    # Half a second should be more or less enough to type that double digit
    if $read_second_digit; then
        read -sN1 -t 0.4 key2

        if [[ -n $key2 ]]; then 
            case $key2 in
            [0-9])
                key=$(($key*10 + $key2))
                ;;
            esac
        fi  
    fi
    
    if [[ $key -le ${#MENU_ITEM_COMMANDS[@]} ]]; then
        CMB_ARGS="$CMB_ARGS ${MENU_ITEM_COMMANDS[$key-1]}"
        MENU_POS=$(($key-1))
        write_menu_items
        write_active_cmb_command
    fi

}

# Credit for the previous picking solution (first 5 lines) goes for eMPee584's 
# answer on the thread below:
# http://stackoverflow.com/questions/10679188/casing-arrow-keys-in-bash
#
# It allowed to read both arrow keys and single characters from a keyboard just 
# fine, but has since been replaced.
#
# Credit now goes to:
# https://stackoverflow.com/a/66500309/6078214
#
# This is the simplest way I have fund yet to read all sorts of special keys

pick_menu_item() { 
    local key=""
    local keytap=""

    # Attempt to flush tinput caches
    while read -t 0.01; do :; done

    while true; do
        
        if $AUTO_REFLOW; then
            # Could probably just use trap to biind it to the SIGWINCH signal
            # but I would have to rethink the whole architecture, and this seems to work just fine
            check_for_size_changes
            local size_changed=$?
            
            if [[ $size_changed -gt 0 ]]; then
                break
            fi

            read -rsN1 -t $AUTO_REFLOW_TICK keytap
        else
            read -rsN1 keytap
        fi
      
        # loop while read can read any additional character and join all of them ## Original comment, left unchanged
        
        while [ -n "$keytap" ]; 
        do  
            key="${key}${keytap}"
            read -sN1 -t 0.0001 keytap
        done

        if [[ -n $key ]]; then 

            # if $GOT_STTY; then
            #     restore_terminal
            # fi
            # TODO: Update User guide and key binding guide with F1-9 and t-# keys for tabs access and TAB key for changing panels
            case $key in
            $'\e[A' | $'\e0A')
                move_up
                ;;
            $'\e[B' | $'\e0B')
                move_down
                ;;
            $'\e[D' | $'\e0D')
                tab_left
                ;;
            $'\e[C' | $'\e0C')
                tab_right
                ;;
            $'\e[11~' | $'\eOP') 
                # F1 - Tab 1
                select_tab 1
                ;;
            $'\e[12~' | $'\eOQ')
                # F2 - Tab 2
                select_tab 2
                ;;
            $'\e[13~' | $'\eOR')
                # F3 - Tab 3
                select_tab 3
                ;;
            $'\e[14~' | $'\eOS') 
                # F4 - Tab 4
                select_tab 4
                ;;
            $'\e[15~')
                # F5 - Tab 5
                select_tab 5
                ;;
            $'\e[17~')
                # F6 - Tab 6
                select_tab 6
                ;;
            $'\e[18~')
                # F7 - Tab 7
                select_tab 7
                ;;
            $'\e[19~') 
                # F8 - Tab 8
                select_tab 8
                ;;
            $'\e[20~')
                # F9 - Tab 9
                select_tab 9
                ;; 
            $'\e[1;5C' | $'\e01;5C')
                change_panel "right"
                ;;
            $'\e[1;5D' | $'\e01;5D')
                change_panel "left"
                ;;
            $'\x09')
                change_panel "swap"
                ;;
            [a-zA-Z])
                shortkey_command "$key"
                ;;
            [1-9])
                if $IS_SUB_FLAGS_MENU; then
                    cmb_set_arg_by_number $key
                else
                    select_menu_item_by_number $key
                fi
                ;;
            $'\x0a' | '')
                # If enter is pressed
                if [[ $ACTIVE_PANEL == "right" ]]; then
                    shortkey_command ${RIGHT_PANEL_ITEM_KEYS[$MENU_POS]}
                else
                    if $IS_SUB_FLAGS_MENU; then
                        set_highlighted_cmb_arg "$@"
                    else
                        select_highlighted_menu_item
                    fi
                fi
                ;;

            esac
            
            break

        elif ! $AUTO_REFLOW; then
            break
        fi
    done
}

shortkey_command(){
    case $1 in
        "r")
            change_panel "right"
            ;;
        "l")
            change_panel "left"
            ;;
        "w")
            move_up
            ;;
       "s")
            move_down
            ;;
       "a")
            tab_left
            ;;
       "d")
            tab_right
            ;;
        "t")
            select_tab_by_number
            ;;
        "R")
            toggle_right_panel
            ;;
        "L")
            toggle_line_connectors
            ;;
        "H")
            toggle_header
            ;;
        "F")
            toggle_footer
            ;;
        "o")
            if ! $IS_SUBMENU; then
                enter_setupmenu
            fi
            ;;
        "f") 
            reflow_menu
            ;;
        "h")
            if ! $IS_HELP_SUBMENU; then
                display_help
            fi
            ;;
        "k")
            display_hotkeys
            ;;
        "q") #this handles exit function
            functright4
            ;;
        "b")
            if $IS_SUBMENU; then
                back_to_main_menu
            fi
            return
            ;;
        "m")
            if $IS_SUB_FLAGS_MENU; then
                cmb_set_manual_args
            fi
            ;;
        "p")
            if $IS_SUB_FLAGS_MENU; then
                cmb_set_manual_args "nospace"
            fi
            ;;
        "c")
            if $IS_SUB_FLAGS_MENU; then
                cmb_commit_with_args
            fi
            ;;
        "x")
            if $IS_SUB_FLAGS_MENU; then
                cmb_clear_args
            fi
            ;;
    esac

}

# This fnction will
# construct a submenu from the supplied arguments, from which
# the user can interactively build a command
#
# Arguments to supply:
# $1 - Title for the submenu
# $2 - base command to start the chain with. It can already contain preset arguments
# $3 - $11 - arguments to be represented as one of the possible 9 menu items.
#
# The arguments can contain more than one options, if supplied in quotes,
# it will be treated as a sibngle menu entry, such as passing e.g.
#
# "-c 5 --whatever_flag -f 8" as $4,
#
# will make
#
# -c 5 --whatever_flag -f 8
#
# the second menu entry. Selecting it will apply all the flags to the built chain


cmb() { 
    CMB_ARGS=""

    if $IS_SUBMENU; then
        REMAIN_IN_SUBMENU=true
        OLD_SUBMENU_TITLE="$SUBMENU_TITLE"
        OLD_TAB_POS=$TAB_POS
        OLD_MAIN_MENU_POS=$MAIN_MENU_POS
    else
        REMAIN_IN_SUBMENU=false
    fi
    

    IS_SUBMENU=true
    IS_SUB_FLAGS_MENU=true
    # First arg is always the menu title
    SUBMENU_TITLE="$1"
    shift

    #Next one is the main command itself
    CMB_COMMAND="$1"
    shift
    MENU_POS=0

    # Everythingelse goes to processing
    set_command_builder_items "$@"
    if ! $SHOW_FOOTER; then
        reflow_menu
    elif $RIGHT_PANEL && ! $SHOW_RIGHT_PANEL; then
        reflow_menu
    fi
    
    write_menu_items

    if $SHOW_RIGHT_PANEL; then
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items
    fi  

   # We do this instead of item descriptora here
    if [[ "$ACTIVE_PANEL" == "left" ]]; then
        write_active_cmb_command
    fi

    write_submenu_title

}

write_active_cmb_command(){

    # ~~TODO~~: Got to make sure this does not go ovber the screen limit. 
    # 7 years leter: No, that's the user's problem, terminal emulators can be resized
    # 1 Week later: Nah, I got it.

    local cmd_msg="Active command: $CMB_COMMAND$CMB_ARGS"
    cmd_msg=$(truncate_text "$cmd_msg" $(($TERMINAL_WIDTH-2)))

    CURSOR_POS=$(($HEADER_HEIGHT + $MENU_HEIGHT + $DESCRIPTOR_HEIGHT))
    t_put cup $CURSOR_POS $MENU_WIDTH
    echo -e "\033[1K"
    t_put cup $CURSOR_POS 2

    echo "$cmd_msg"  
}


#Right panel functions
#this is the standard reflow function

reflow_menu() { 
    clear
    set_menu_sizes
    if ! MENUS_FORCE_HIDDEN; then
        init_menu "reflow"
    fi
}


display_hotkeys() { 
    display_markdown_help "$RES_DIR/shortkeys.md" "$RES_DIR/shortkeys.txt"
    reflow_menu
}


# Calls the papproropriate help function, either the help submenu
# or the single help file, depending on where the user is
display_help() { 
    if $IS_SUB_FLAGS_MENU; then
        functhelp_commanbuilder
        reflow_menu
    else
        enter_helpmenu
    fi
}


# Quits Lazy Admin, and restores the cursor, but only if
# not returning from a nested root shell
# (It is possible to run another shell of ladmin form within)
exit_la_menus() { 
    t_put cnorm
    clear
    clear
    echo
    echo "$@"
    echo
    exit 0
}


# Misleading function name (TODO:change it)
# It will return to the calling menu, which can be a submenu in case of
# help menu or command builder
back_to_main_menu() { 

    ACTIVE_PANEL="left"
    MENU_POS=$MAIN_MENU_POS
    local should_reflow=false
    if $IS_SUB_FLAGS_MENU; then
        should_reflow=true
        IS_SUB_FLAGS_MENU=false
    fi
   
    IS_HELP_SUBMENU=false

    if $REMAIN_IN_SUBMENU; then
        IS_SUBMENU=true
        REMAIN_IN_SUBMENU=false
        
        TAB_POS=$OLD_TAB_POS
        MENU_POS=$OLD_MAIN_MENU_POS

        enter_submenu "$OLD_SUBMENU_TITLE"
    else
        IS_SUBMENU=false
        write_tab_items

        if $SHOW_HEADER; then
            write_main_title
        fi

        read_menu_items
        read_rightpanel_items

        clear_menu
        clear_right_panel
        write_menu_items
        if $SHOW_RIGHT_PANEL; then
            write_rightpanel_items
        fi
    fi

    if $should_reflow; then
        reflow_menu
    fi
   

    return
}



# Same as main menu, only this one invokes a submenu.
# decide menu type
submenu() { 
    if ! $MENUS_FORCE_HIDDEN; then
        if [[ $1 != "help" ]]; then
            IS_SUBMENU=true
        fi
    
        IS_SUB_FLAGS_MENU=false

        if [[ $1 != "help" ]]; then
            read_menu_items $1 $2
        fi
        

        # infinite_menu

        if [[ $1 != "help" ]]; then
            write_menu_items
        else
            write_help_menu_items
        fi

        if $SHOW_RIGHT_PANEL; then
            write_rightpanel_items
        fi

    fi
    pick_menu_item
}




# Initialise a menu, before drawing for the foirst timed
# Will set menu item and title variable
init_menu() {     
    if [[ "$(whoami)" != "root" ]]; then
        IS_ROOT=false
    else
        IS_ROOT=true
    fi

    clear
    
    if [[ $1 != "help" ]]; then
        if [[ $1 != "reflow" ]]; then
            if $IS_SUBMENU; then
                read_submenu_items "${TAB_ITEM_KEYS[$TAB_POS]}" $MAIN_MENU_POS
            else
                read_menu_items
            fi
        fi
    fi

    read_rightpanel_items
    draw_menu

    if ! $MENUS_FORCE_HIDDEN; then
        if $IS_SUBMENU; then
            write_submenu_title
        else
            write_tab_items
        fi
        write_menu_items

        if $SHOW_RIGHT_PANEL; then
            write_rightpanel_items
        fi
    fi
}


write_submenu_title() {
    
    t_put cup $((HEADER_HEIGHT - 3))
    draw_line
    clear_line $((HEADER_HEIGHT - 2)) 1 "right"
    t_put cup $((HEADER_HEIGHT - 1))
    draw_line
    # Put line connector for right panel back in plkace, if applicable
    if $SHOW_RIGHT_PANEL && $DISPLAY_LINE_CONNECTORS; then
        t_put cup $((HEADER_HEIGHT - 1)) $LEFT_PANEL_WIDTH
        echo "â¯"
    fi

    t_put cup $((HEADER_HEIGHT - 2)) $((MENU_WIDTH / 2 - (${#SUBMENU_TITLE} / 2)))
    echo "$SUBMENU_TITLE"
    
}

# This will be called whrn a submenu is selected
enter_submenu() {
    MAIN_MENU_POS="$MENU_POS"
    MENU_POS=0

    if [[ -z "$1" ]]; then
        SUBMENU_TITLE="${MENU_ITEM_ENTRIES[$MAIN_MENU_POS]}"
        SUBMENU_TITLE="Submenu: ${SUBMENU_TITLE#* - }"
    else
        SUBMENU_TITLE="$1"
    fi

    IS_SUBMENU=true
    REMAIN_IN_SUBMENU=false


    read_submenu_items "${TAB_ITEM_KEYS[$TAB_POS]}" $MAIN_MENU_POS
    clear_menu
    write_menu_items
    
    if $SHOW_RIGHT_PANEL; then
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items
    fi   

    write_submenu_title

}


# This will be called when help menu is selected
enter_helpmenu() { 
    IS_HELP_SUBMENU=true

    if $IS_SUBMENU; then
        REMAIN_IN_SUBMENU=true
        OLD_SUBMENU_TITLE="$SUBMENU_TITLE"
        OLD_TAB_POS=$TAB_POS
        OLD_MAIN_MENU_POS=$MAIN_MENU_POS
    else
        REMAIN_IN_SUBMENU=false
    fi

    IS_SUBMENU=true

    SUBMENU_TITLE="Help"
    MAIN_MENU_POS="$MENU_POS"
    MENU_POS=0

    read_menu_items "Help"
    clear_menu
    write_menu_items
    
    if $SHOW_RIGHT_PANEL; then
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items
    fi   

    write_submenu_title
}


# This will be called when setup menu is selected
enter_setupmenu() { 

    REMAIN_IN_SUBMENU=false
    IS_SUBMENU=true

    SUBMENU_TITLE="Setup Options"
    MAIN_MENU_POS="$MENU_POS"
    MENU_POS=0

    read_menu_items "Setup"
    clear_menu
    write_menu_items
    
    if $SHOW_RIGHT_PANEL; then
        read_rightpanel_items
        clear_right_panel 
        write_rightpanel_items
    fi   

    write_submenu_title
}


# Right panel functions. These function aliases are core functionality,
# so not really a part of the user aliases. This coudl change later
# so that users can easily alter right panel
function functright0 { 
    reflow_menu
}


function functright1 { 
    display_help
}


function functright2 { 
    display_hotkeys
}


function functright3 { 
    if IS_SUBMENU; then
        if [[ $IS_SUB_FLAGS_MENU ]]; then
            IS_SUB_FLAGS_MENU=false
        fi

        back_to_main_menu "read"
    fi
}


function functright4 { 
    if $IS_ROOT; then
        exit_la_menus "Leaving root shell"
    else
        exit_la_menus "Exiting..."
    fi
}


function_exists() {
    declare -f -F $1 > /dev/null
    echo $?
}

package_exists() {
    if hash "$1" 2>/dev/null; then
        echo 0
    else
        echo 1
    fi

}

validate_item() { 
    if [[ $(function_exists "$1") == 0 ]]; then
        echo 0
    elif [[ $(package_exists "$1") == 0 ]]; then
        echo 0
    else
        echo 65
    fi
}

return_to_menu() { 
    echo
    echo "Press any key to return to menu"
    read -n 1 -s key_press
    clear
    init_menu
}

restore_terminal(){

    if [[ -n "$_SAVED_STTY_SETTINGS" ]] && $GOT_STTY; then
        stty "$_SAVED_STTY_SETTINGS"
    fi

    t_put cnorm
  
}

set_up_terminal(){
    t_put civis
    if $USE_STTY && hash stty 2>/dev/null; then
        GOT_STTY=true
        _SAVED_STTY_SETTINGS=$(stty -g)
        stty -icanon -echo
    fi  
}



# Just in case tput might not be available for ANY reason
# This way it will stillbe used if present, but alternatives will be sought if not
# so technically tput is no longer a dependency
t_put() {
    if [[ $1 == "cols" ]]; then
        echo $(tput_cols) 
    elif [[ $1 == "lines" ]]; then
        echo $(tput_lines) 
    elif [[ $(package_exists "tput") == 0 ]]; then
        eval tput $@
    else
        case $1 in
            "cup")
                local row=$(($2+1))
                local col=$(($3+1))
                echo -ne "\e[${row};${col}H"
                ;;
            "civis")
                echo -e "\e[?25l"
                ;;
            "cnorm")
                echo -e "\e[?25h"
                ;;
        esac
    fi
    
}

tput_cols(){
    local columns=0
    if $USE_STTY && hash stty 2>/dev/null; then
        local terminal_size=$(stty size)
        columns=${terminal_size##* }  # Everything after the last space
    elif [[ $(package_exists "tput") == 0 ]]; then
        columns=$(tput cols)
    else  
        # Ensure checkwinsize is enabled for non-interactive shells to update these variables
        shopt -s checkwinsize

        # For non-interactive scripts, a subshell is needed to trigger the update
        # The `(:)` is a no-op command that creates a subshell.
        # This ensures $LINES and $COLUMNS are updated before you read them.
        (:)
        columns=$COLUMNS

    fi

    echo "$columns"

}

tput_lines(){
    local rows=0
    if $USE_STTY && hash stty 2>/dev/null; then
        local terminal_size=$(stty size)
        
        rows=${terminal_size%% *}  # Everything before the first space
    elif [[ $(package_exists "tput") == 0 ]]; then
        rows=$(tput lines)

    else  
        # Ensure checkwinsize is enabled for non-interactive shells to update these variables
        shopt -s checkwinsize

        # For non-interactive scripts, a subshell is needed to trigger the update
        # The `(:)` is a no-op command that creates a subshell.
        # This ensures $LINES and $COLUMNS are updated before you read them.
        (:)
        rows=$LINES

    fi

    echo "$rows"

}



# Initialises and displays the main menu
# This is what the launcher calls, basically
main() { 
    
    # Ensure everything is restored on script exit
    set_up_terminal

    trap restore_terminal EXIT HUP INT QUIT TERM

    set_up_menus

    for ((i = 1; i <= $#; i++)); do
        j=$((i + 1))

        # This can be extended with any number of arguments later, possibly to change defaults on the fly
        case "${!i}" in
        "-j" | "--join-lines")
            if [[ "${!j}" == "off" ]]; then
                DISPLAY_LINE_CONNECTORS=false
            elif [[ "${!j}" == "on" ]]; then
                DISPLAY_LINE_CONNECTORS=true
            fi
            ;;
        *)
            #Do nothing
            ;;
        esac
    done

    if ! MENUS_FORCE_HIDDEN; then
        init_menu
    fi

    while true; do
        pick_menu_item
    done
}


